<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository xmlns="http://www.gtk.org/introspection/core/1.0" xmlns:c="http://www.gtk.org/introspection/c/1.0" xmlns:glib="http://www.gtk.org/introspection/glib/1.0" version="1.1">
  <include name="GLib" version="2.0"/>
  <include name="GObject" version="2.0"/>
  <include name="Gio" version="2.0"/>
  <package name="dbus-glib-1"/>
  <package name="gio-2.0"/>
  <namespace name="TelepathyGLib" version="0.12" shared-library="libtelepathy-glib.so.0" c:prefix="tp">
    <alias name="Handle" target="uint" c:type="TpHandle"/>
    <constant name="ACCOUNT_MANAGER_BUS_NAME" value="org.freedesktop.Telepathy.AccountManager">
      <type name="utf8"/>
    </constant>
    <constant name="ACCOUNT_MANAGER_OBJECT_PATH" value="/org/freedesktop/Telepathy/AccountManager">
      <type name="utf8"/>
    </constant>
    <constant name="ACCOUNT_OBJECT_PATH_BASE" value="/org/freedesktop/Telepathy/Account/">
      <type name="utf8"/>
    </constant>
    <class name="Account" c:type="TpAccount" version="0.7.32" parent="Proxy" glib:type-name="TpAccount" glib:get-type="tp_account_get_type" glib:type-struct="AccountClass">
      <doc xml:whitespace="preserve">The Telepathy Account Manager stores the user's configured real-time
communication accounts. This object represents a stored account.
If this account is deleted from the account manager, the
#TpProxy::invalidated signal will be emitted
with the domain %TP_DBUS_ERRORS and the error code
%TP_DBUS_ERROR_OBJECT_REMOVED.
One can connect to the #GObject::notify signal to get change notifications
for many of the properties on this object. Refer to each property's
documentation for whether it can be used in this way.</doc>
      <constructor name="new" c:identifier="tp_account_new" throws="1">
        <doc xml:whitespace="preserve">Convenience function to create a new account proxy. The returned #TpAccount
is not guaranteed to be ready at the point of return.
not valid</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new reference to an account proxy, or %NULL if @object_path is</doc>
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
        <parameters>
          <parameter name="bus_daemon" transfer-ownership="none">
            <doc xml:whitespace="preserve">Proxy for the D-Bus daemon</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">The non-NULL object path of this account</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="get_feature_quark_core" c:identifier="tp_account_get_feature_quark_core" version="0.9.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;
#TpAccount</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the quark used for representing the core feature of a</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="parse_object_path" c:identifier="tp_account_parse_object_path" version="0.9.0" throws="1">
        <doc xml:whitespace="preserve">Validates and parses a Telepathy Account's object path, extracting the
connection manager's name, the protocol, and the account's unique identifier
from the path. This includes replacing underscores with hyphens in the
protocol name, as defined in the Account specification.
Any of the out parameters may be %NULL if not needed. If %TRUE is returned,
the caller is responsible for freeing the strings stored in any non-%NULL
out parameters, using g_free().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @object_path was successfully parsed; %FALSE and sets</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">a Telepathy Account's object path</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="cm" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:whitespace="preserve">location at which to store the account's connection manager's name</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="protocol" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:whitespace="preserve">location at which to store the account's protocol</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="account_id" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:whitespace="preserve">location at which to store the account's unique identifier</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </function>
      <function name="init_known_interfaces" c:identifier="tp_account_init_known_interfaces" version="0.7.32">
        <doc xml:whitespace="preserve">Ensure that the known interfaces for TpAccount have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_ACCOUNT.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <method name="get_connection" c:identifier="tp_account_get_connection" version="0.9.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">connection property</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </return-value>
      </method>
      <method name="ensure_connection" c:identifier="tp_account_ensure_connection" version="0.9.0">
        <doc xml:whitespace="preserve">Set the connection of the account by specifying the connection object path.
This function does not return a new ref and it is not guaranteed that the
returned #TpConnection object is ready.
The use-case for this function is in a HandleChannels callback and you
already know the object path for the connection, so you can let @account
create its #TpConnection and return it for use.
the object path @path is invalid or it is the null-value "/"</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the connection of the account, or %NULL if either</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the path to connection object for #TpAccount</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_display_name" c:identifier="tp_account_get_display_name" version="0.9.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:display-name property</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_connection_manager" c:identifier="tp_account_get_connection_manager" version="0.9.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:connection-manager property</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_protocol" c:identifier="tp_account_get_protocol" version="0.9.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:protocol property</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_service" c:identifier="tp_account_get_service" version="0.11.9">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:service property</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_icon_name" c:identifier="tp_account_get_icon_name" version="0.9.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:icon-name property</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="set_enabled_async" c:identifier="tp_account_set_enabled_async" version="0.9.0">
        <doc xml:whitespace="preserve">Requests an asynchronous set of the Enabled property of @account. When the
operation is finished, @callback will be called. You can then call
tp_account_set_enabled_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new enabled value of @account</doc>
            <type name="boolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="async" closure="3">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_enabled_finish" c:identifier="tp_account_set_enabled_finish" version="0.9.0" throws="1">
        <doc xml:whitespace="preserve">Finishes an async set of the Enabled property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the set was successful, otherwise %FALSE</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="reconnect_async" c:identifier="tp_account_reconnect_async" version="0.9.0">
        <doc xml:whitespace="preserve">Requests an asynchronous reconnect of @account. When the operation is
finished, @callback will be called. You can then call
tp_account_reconnect_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback" transfer-ownership="none" scope="async" closure="2">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="reconnect_finish" c:identifier="tp_account_reconnect_finish" version="0.9.0" throws="1">
        <doc xml:whitespace="preserve">Finishes an async reconnect of @account.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the reconnect call was successful, otherwise %FALSE</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_enabled" c:identifier="tp_account_is_enabled" version="0.9.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:enabled property</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_valid" c:identifier="tp_account_is_valid" version="0.9.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:valid property</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="update_parameters_async" c:identifier="tp_account_update_parameters_async" version="0.9.0">
        <doc xml:whitespace="preserve">Requests an asynchronous update of parameters of @account. When the
operation is finished, @callback will be called. You can then call
tp_account_update_parameters_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="parameters" transfer-ownership="none">
            <doc xml:whitespace="preserve">new parameters to set on @account</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
          <parameter name="unset_parameters" transfer-ownership="none">
            <doc xml:whitespace="preserve">list of parameters to unset on @account</doc>
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="async" closure="4">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="update_parameters_finish" c:identifier="tp_account_update_parameters_finish" version="0.9.0" throws="1">
        <doc xml:whitespace="preserve">Finishes an async update of the parameters on @account.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the request succeeded, otherwise %FALSE</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="reconnect_required" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GStrv to fill with properties that need a reconnect to take effect</doc>
            <type name="GObject.Strv" c:type="gchar***"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_async" c:identifier="tp_account_remove_async" version="0.9.0">
        <doc xml:whitespace="preserve">Requests an asynchronous removal of @account. When the operation is
finished, @callback will be called. You can then call
tp_account_remove_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback" transfer-ownership="none" scope="async" closure="2">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_finish" c:identifier="tp_account_remove_finish" version="0.9.0" throws="1">
        <doc xml:whitespace="preserve">Finishes an async removal of @account.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_display_name_async" c:identifier="tp_account_set_display_name_async" version="0.9.0">
        <doc xml:whitespace="preserve">Requests an asynchronous set of the DisplayName property of @account. When
the operation is finished, @callback will be called. You can then call
tp_account_set_display_name_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="display_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a new display name, or %NULL to unset the display name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="async" closure="3">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_display_name_finish" c:identifier="tp_account_set_display_name_finish" version="0.9.0" throws="1">
        <doc xml:whitespace="preserve">Finishes an async set of the DisplayName property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the call was successful, otherwise %FALSE</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_icon_name_async" c:identifier="tp_account_set_icon_name_async" version="0.9.0">
        <doc xml:whitespace="preserve">Requests an asynchronous set of the Icon property of @account. When
the operation is finished, @callback will be called. You can then call
tp_account_set_icon_name_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="icon_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a new icon name, or %NULL to unset the icon name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="async" closure="3">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_icon_name_finish" c:identifier="tp_account_set_icon_name_finish" version="0.9.0" throws="1">
        <doc xml:whitespace="preserve">Finishes an async set of the Icon parameter.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_service_async" c:identifier="tp_account_set_service_async" version="0.11.9">
        <doc xml:whitespace="preserve">Requests an asynchronous set of the Service property on @self. When
the operation is finished, @callback will be called. You can then call
tp_account_set_service_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="service" transfer-ownership="none">
            <doc xml:whitespace="preserve">a new service name, or %NULL or the empty string to unset the service name (which will result in the #TpAccount:service property becoming the same as #TpAccount:protocol)</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="async" closure="3">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_service_finish" c:identifier="tp_account_set_service_finish" version="0.11.9" throws="1">
        <doc xml:whitespace="preserve">Finishes an async set of the Service parameter.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_presence_async" c:identifier="tp_account_request_presence_async" version="0.9.0">
        <doc xml:whitespace="preserve">Requests an asynchronous change of presence on @account. When the
operation is finished, @callback will be called. You can then call
tp_account_request_presence_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the requested presence</doc>
            <type name="ConnectionPresenceType" c:type="TpConnectionPresenceType"/>
          </parameter>
          <parameter name="status" transfer-ownership="none">
            <doc xml:whitespace="preserve">a status message to set, or %NULL</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">a message for the change, or %NULL</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="async" closure="5">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_presence_finish" c:identifier="tp_account_request_presence_finish" version="0.9.0" throws="1">
        <doc xml:whitespace="preserve">Finishes an async presence change request on @account.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_connect_automatically" c:identifier="tp_account_get_connect_automatically" version="0.9.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:connect-automatically property</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="set_connect_automatically_async" c:identifier="tp_account_set_connect_automatically_async" version="0.9.0">
        <doc xml:whitespace="preserve">Requests an asynchronous set of the ConnectAutomatically property of
then call tp_account_set_display_name_finish() to get the result of the
operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="connect_automatically" transfer-ownership="none">
            <doc xml:whitespace="preserve">new value for the parameter</doc>
            <type name="boolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="async" closure="3">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_connect_automatically_finish" c:identifier="tp_account_set_connect_automatically_finish" version="0.9.0" throws="1">
        <doc xml:whitespace="preserve">Finishes an async set of the ConnectAutomatically property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the call was successful, otherwise %FALSE</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_has_been_online" c:identifier="tp_account_get_has_been_online" version="0.9.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:has-been-online property</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_connection_status" c:identifier="tp_account_get_connection_status" version="0.9.0">
        <doc xml:whitespace="preserve">Gets the connection status and reason from @account. The two values
are the same as the #TpAccount:connection-status and
#TpAccount:connection-status-reason properties.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the same as the #TpAccount:connection-status property</doc>
          <type name="ConnectionStatus" c:type="TpConnectionStatus"/>
        </return-value>
        <parameters>
          <parameter name="reason" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpConnectionStatusReason to fill, or %NULL</doc>
            <type name="ConnectionStatusReason" c:type="TpConnectionStatusReason*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_detailed_error" c:identifier="tp_account_get_detailed_error" version="0.11.7" introspectable="0">
        <doc xml:whitespace="preserve">If the account's connection is not connected, return the D-Bus error name
with which it last disconnected or failed to connect (in particular, this
is %TP_ERROR_STR_CANCELLED if it was disconnected by a user request).
This is the same as #TpAccount:connection-error.
If @details is not %NULL, it will be used to return additional details about
the error (the same as #TpAccount:connection-error-details).
Otherwise, return %NULL, without altering @details.
The returned string and @details may become invalid when the main loop is
re-entered or the account is destroyed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a D-Bus error name, or %NULL.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="details" direction="out" caller-allocates="0" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">optionally used to return a map from string to #GValue, which must not be modified, destroyed or unreffed by the caller</doc>
            <type name="GLib.HashTable" c:type="GHashTable**">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="get_current_presence" c:identifier="tp_account_get_current_presence" version="0.9.0">
        <doc xml:whitespace="preserve">Gets the current presence, status and status message of @account. These
values are the same as the #TpAccount:current-presence-type,
#TpAccount:current-status and #TpAccount:current-status-message properties.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the same as the #TpAccount:current-presence-type property</doc>
          <type name="ConnectionPresenceType" c:type="TpConnectionPresenceType"/>
        </return-value>
        <parameters>
          <parameter name="status" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:whitespace="preserve">return location for the current status</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="status_message" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:whitespace="preserve">return location for the current status message</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_requested_presence" c:identifier="tp_account_get_requested_presence" version="0.9.0">
        <doc xml:whitespace="preserve">Gets the requested presence, status and status message of @account. These
values are the same as the #TpAccount:requested-presence-type,
#TpAccount:requested-status and #TpAccount:requested-status-message
properties.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the same as the #TpAccount:requested-presence-type property</doc>
          <type name="ConnectionPresenceType" c:type="TpConnectionPresenceType"/>
        </return-value>
        <parameters>
          <parameter name="status" direction="out" caller-allocates="0" transfer-ownership="none">
            <doc xml:whitespace="preserve">return location for the requested status</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="status_message" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:whitespace="preserve">return location for the requested status message</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_parameters" c:identifier="tp_account_get_parameters" version="0.9.0">
        <doc xml:whitespace="preserve">Returns the parameters of the account, in a hash table where each string
is the parameter name (account, password, require-encryption etc.), and
each value is a #GValue. Using the tp_asv_get family of functions
(tp_asv_get_uint32(), tp_asv_get_string() etc.) to access the parameters is
recommended.
The allowed parameters depend on the connection manager, and can be found
via tp_connection_manager_get_protocol() and
tp_connection_manager_protocol_get_param(). Well-known parameters are
listed
&lt;ulink url="http://telepathy.freedesktop.org/spec/org.freedesktop.Telepathy.ConnectionManager.html#org.freedesktop.Telepathy.ConnectionManager.RequestConnection"&gt;in
the Telepathy D-Bus Interface Specification&lt;/ulink&gt;.
parameters on @account</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the hash table of</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </return-value>
      </method>
      <method name="get_nickname" c:identifier="tp_account_get_nickname" version="0.9.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:nickname property</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="set_nickname_async" c:identifier="tp_account_set_nickname_async" version="0.9.0">
        <doc xml:whitespace="preserve">Requests an asynchronous change of the Nickname parameter on @account. When
the operation is finished, @callback will be called. You can then call
tp_account_set_nickname_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="nickname" transfer-ownership="none">
            <doc xml:whitespace="preserve">a new nickname to set</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="async" closure="3">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_nickname_finish" c:identifier="tp_account_set_nickname_finish" version="0.9.0" throws="1">
        <doc xml:whitespace="preserve">Finishes an async nickname change request on @account.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_avatar_async" c:identifier="tp_account_get_avatar_async" version="0.9.0">
        <doc xml:whitespace="preserve">Requests an asynchronous get of @account's avatar. When
the operation is finished, @callback will be called. You can then call
tp_account_get_avatar_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback" transfer-ownership="none" scope="async" closure="2">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_avatar_finish" c:identifier="tp_account_get_avatar_finish" version="0.9.0" throws="1">
        <doc xml:whitespace="preserve">Finishes an async get operation of @account's avatar.
containing the bytes of the account's avatar, or %NULL on failure</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GArray of #guchar</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="uint8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_prepared" c:identifier="tp_account_is_prepared" version="0.9.0" introspectable="0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same thing as tp_proxy_is_prepared()</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:whitespace="preserve">a feature which is required</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepare_async" c:identifier="tp_account_prepare_async" version="0.9.0" introspectable="0">
        <doc xml:whitespace="preserve">Requests an asynchronous preparation of @account with the features specified
by @features. When the operation is finished, @callback will be called. You
can then call tp_account_prepare_finish() to get the result of the
operation.
If @features is %NULL, then @callback will be called when the implied
%TP_ACCOUNT_FEATURE_CORE feature is ready.
If %NULL is given to @callback, then no callback will be called when the
operation is finished. Instead, it will simply set @features on @manager.
Note that if @callback is %NULL, then @user_data must also be %NULL.
Since 0.11.3, this is equivalent to calling the new function
tp_proxy_prepare_async() with the same arguments.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="features" transfer-ownership="none">
            <doc xml:whitespace="preserve">a 0-terminated list of features, or %NULL</doc>
            <type name="GLib.Quark" c:type="GQuark*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="async" closure="3">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepare_finish" c:identifier="tp_account_prepare_finish" version="0.9.0" introspectable="0" throws="1">
        <doc xml:whitespace="preserve">Finishes an async preparation of the account @account.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the preparation was successful, otherwise %FALSE</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_avatar_async" c:identifier="tp_account_set_avatar_async" version="0.11.1">
        <doc xml:whitespace="preserve">Requests an asynchronous change of the Avatar parameter on @self. When
the operation is finished, @callback will be called. You can then call
tp_account_set_avatar_finish() to get the result of the operation.
If @len equals 0, the avatar is cleared.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="avatar" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">a new avatar to set; can be %NULL only if @len equals 0</doc>
            <array length="2" c:type="guchar*">
              <type name="uint8"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:whitespace="preserve">the length of the new avatar</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="mime_type" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">the MIME type of the new avatar; can be %NULL only if @len equals 0</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="async" closure="5">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_avatar_finish" c:identifier="tp_account_set_avatar_finish" version="0.11.1" throws="1">
        <doc xml:whitespace="preserve">Finishes an async avatar change request on @account.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_changing_presence" c:identifier="tp_account_get_changing_presence" version="0.11.6">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:changing-presence property</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
      </method>
      <property name="changing-presence" version="0.11.6" transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if an attempt is currently being made to change the account's
presence (#TpAccount:current-presence-type, #TpAccount:current-status
and #TpAccount:current-status-message) to match its requested presence
(#TpAccount:requested-presence-type, #TpAccount:requested-status
and #TpAccount:requested-status-message).
One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail.
This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%FALSE.</doc>
        <type name="boolean" c:type="gboolean"/>
      </property>
      <property name="connect-automatically" version="0.9.0" transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether the account should connect automatically or not. To change this
property, use tp_account_set_connect_automatically_async().
One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail.
This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%FALSE.</doc>
        <type name="boolean" c:type="gboolean"/>
      </property>
      <property name="connection" version="0.9.0" transfer-ownership="none">
        <doc xml:whitespace="preserve">The connection of the account, or NULL if account is offline.
It is not guaranteed that the returned #TpConnection object is ready.
One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail.
This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="Connection" c:type="TpConnection"/>
      </property>
      <property name="connection-error" version="0.11.7" transfer-ownership="none">
        <doc xml:whitespace="preserve">The D-Bus error name for the last disconnection or connection failure,
(in particular, %TP_ERROR_STR_CANCELLED if it was disconnected by user
request), or %NULL if the account is connected.
One can receive change notifications on this property by connecting
to the #TpAccount::status-changed signal, or by connecting
to the #GObject::notify signal and using this property as the signal
detail.
This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="utf8" c:type="gchararray"/>
      </property>
      <property name="connection-error-details" version="0.11.7" transfer-ownership="none">
        <doc xml:whitespace="preserve">A map from string to #GValue containing extensible error details
related to #TpAccount:connection-error. Functions like tp_asv_get_string()
can be used to read from this map.
The keys for this map are defined by
&lt;ulink url="http://telepathy.freedesktop.org/spec/"&gt;the Telepathy D-Bus
Interface Specification&lt;/ulink&gt;. They will typically include
&lt;literal&gt;debug-message&lt;/literal&gt;, which is a debugging message in the C
locale, analogous to #GError.message.
One can receive change notifications on this property by connecting
to the #TpAccount::status-changed signal, or by connecting
to the #GObject::notify signal and using this property as the signal
detail.
This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
an empty map.</doc>
        <type name="GLib.HashTable" c:type="GHashTable"/>
      </property>
      <property name="connection-manager" version="0.9.0" transfer-ownership="none">
        <doc xml:whitespace="preserve">The account's connection manager name.</doc>
        <type name="utf8" c:type="gchararray"/>
      </property>
      <property name="connection-status" version="0.9.0" transfer-ownership="none">
        <doc xml:whitespace="preserve">The account's connection status type (a %TpConnectionStatus).
One can receive change notifications on this property by connecting
to the #TpAccount::status-changed signal, or by connecting
to the #GObject::notify signal and using this property as the signal
detail.
This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%TP_CONNECTION_STATUS_DISCONNECTED.</doc>
        <type name="uint" c:type="guint"/>
      </property>
      <property name="connection-status-reason" version="0.9.0" transfer-ownership="none">
        <doc xml:whitespace="preserve">The account's connection status reason (a %TpConnectionStatusReason).
One can receive change notifications on this property by connecting
to the #TpAccount::status-changed signal, or by connecting
to the #GObject::notify signal and using this property as the signal
detail.
This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%TP_CONNECTION_STATUS_REASON_NONE_SPECIFIED.</doc>
        <type name="uint" c:type="guint"/>
      </property>
      <property name="current-presence-type" version="0.9.0" transfer-ownership="none">
        <doc xml:whitespace="preserve">The account connection's current presence type
(a %TpConnectionPresenceType).
One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail.
This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%TP_CONNECTION_PRESENCE_TYPE_UNSET.</doc>
        <type name="uint" c:type="guint"/>
      </property>
      <property name="current-status" version="0.9.0" transfer-ownership="none">
        <doc xml:whitespace="preserve">The current Status string of the account.
One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail.
This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="utf8" c:type="gchararray"/>
      </property>
      <property name="current-status-message" version="0.9.0" transfer-ownership="none">
        <doc xml:whitespace="preserve">The current status message message of the account.
One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail.
This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="utf8" c:type="gchararray"/>
      </property>
      <property name="display-name" version="0.9.0" transfer-ownership="none">
        <doc xml:whitespace="preserve">The account's display name, from the DisplayName property.
One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail.
This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="utf8" c:type="gchararray"/>
      </property>
      <property name="enabled" version="0.9.0" transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether this account is enabled or not.
One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail.
This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is FALSE.</doc>
        <type name="boolean" c:type="gboolean"/>
      </property>
      <property name="has-been-online" version="0.9.0" transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether this account has been online or not.
One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail.
This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%FALSE.</doc>
        <type name="boolean" c:type="gboolean"/>
      </property>
      <property name="icon-name" version="0.9.0" transfer-ownership="none">
        <doc xml:whitespace="preserve">The account's icon name. To change this propery, use
tp_account_set_icon_name_async().
One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail.
This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="utf8" c:type="gchararray"/>
      </property>
      <property name="nickname" transfer-ownership="none">
        <type name="utf8" c:type="gchararray"/>
      </property>
      <property name="protocol" version="0.9.0" transfer-ownership="none">
        <doc xml:whitespace="preserve">The account's machine-readable protocol name, such as "jabber", "msn" or
"local-xmpp". Recommended names for most protocols can be found in the
Telepathy D-Bus Interface Specification.</doc>
        <type name="utf8" c:type="gchararray"/>
      </property>
      <property name="requested-presence-type" version="0.9.0" transfer-ownership="none">
        <doc xml:whitespace="preserve">The account's requested presence type (a #TpConnectionPresenceType).
One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail.</doc>
        <type name="uint" c:type="guint"/>
      </property>
      <property name="requested-status" version="0.9.0" transfer-ownership="none">
        <doc xml:whitespace="preserve">The requested Status string of the account.
One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail.</doc>
        <type name="utf8" c:type="gchararray"/>
      </property>
      <property name="requested-status-message" version="0.9.0" transfer-ownership="none">
        <doc xml:whitespace="preserve">The requested status message message of the account.
One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail.</doc>
        <type name="utf8" c:type="gchararray"/>
      </property>
      <property name="service" version="0.11.9" transfer-ownership="none">
        <doc xml:whitespace="preserve">A machine-readable name identifying a specific service to which this
account connects, or a copy of #TpAccount:protocol if there is no more
specific service.
Well-known names for various services can be found in the Telepathy D-Bus
Interface Specification.
For instance, accounts for the "jabber" protocol should have the service
names "google-talk", "ovi-chat", "facebook" and "lj-talk" for accounts
that connect to Google Talk, Ovi Chat, Facebook and Livejournal,
respectively, and this property will be "jabber" for accounts that
connect to a generic Jabber server.
To change this property, use
tp_account_set_service_async().</doc>
        <type name="utf8" c:type="gchararray"/>
      </property>
      <property name="valid" version="0.9.0" transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether this account is valid.
One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail.
This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%FALSE.</doc>
        <type name="boolean" c:type="gboolean"/>
      </property>
      <field name="parent">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="priv">
        <type name="AccountPrivate" c:type="TpAccountPrivate*"/>
      </field>
      <glib:signal name="presence-changed" version="0.9.0">
        <doc xml:whitespace="preserve">Emitted when the presence of the account changes.</doc>
        <return-value transfer-ownership="full">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="presence" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new presence</doc>
            <type name="uint" c:type="guint"/>
          </parameter>
          <parameter name="status" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new presence status</doc>
            <type name="utf8" c:type="gchararray"/>
          </parameter>
          <parameter name="status_message" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new presence status message</doc>
            <type name="utf8" c:type="gchararray"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="status-changed" version="0.9.0">
        <doc xml:whitespace="preserve">Emitted when the connection status on the account changes.
The @dbus_error_name and @details parameters were present, but
non-functional (always %NULL), in older versions. They have been
available with their current behaviour since version 0.11.7.</doc>
        <return-value transfer-ownership="full">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="old_status" transfer-ownership="none">
            <doc xml:whitespace="preserve">old #TpAccount:connection-status</doc>
            <type name="uint" c:type="guint"/>
          </parameter>
          <parameter name="new_status" transfer-ownership="none">
            <doc xml:whitespace="preserve">new #TpAccount:connection-status</doc>
            <type name="uint" c:type="guint"/>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpAccount:connection-status-reason</doc>
            <type name="uint" c:type="guint"/>
          </parameter>
          <parameter name="dbus_error_name" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">connection-error</doc>
            <type name="utf8" c:type="gchararray"/>
          </parameter>
          <parameter name="details" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpAccount:connection-error-details</doc>
            <type name="GLib.HashTable" c:type="GHashTable">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <class name="AccountChannelRequest" c:type="TpAccountChannelRequest" version="0.11.12" parent="GObject.Object" glib:type-name="TpAccountChannelRequest" glib:get-type="tp_account_channel_request_get_type" glib:type-struct="AccountChannelRequestClass">
      <doc xml:whitespace="preserve">Data structure representing a #TpAccountChannelRequest object.</doc>
      <constructor name="new" c:identifier="tp_account_channel_request_new" version="0.11.12">
        <doc xml:whitespace="preserve">Convenience function to create a new #TpAccountChannelRequest object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #TpAccountChannelRequest object</doc>
          <type name="AccountChannelRequest" c:type="TpAccountChannelRequest*"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:whitespace="preserve">the requested properties of the channel (see #TpAccountChannelRequest:request)</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
          <parameter name="user_action_time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the time of the user action that caused this request, or one of the special values %TP_USER_ACTION_TIME_NOT_USER_ACTION or %TP_USER_ACTION_TIME_CURRENT_TIME (see #TpAccountChannelRequest:user-action-time)</doc>
            <type name="int64" c:type="gint64"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_account" c:identifier="tp_account_channel_request_get_account" version="0.11.12">
        <doc xml:whitespace="preserve">Return the #TpAccountChannelRequest:account construct-only property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">account</doc>
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
      </method>
      <method name="get_request" c:identifier="tp_account_channel_request_get_request" version="0.11.12">
        <doc xml:whitespace="preserve">Return the #TpAccountChannelRequest:request construct-only property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">request</doc>
          <type name="GLib.HashTable" c:type="GHashTable*"/>
        </return-value>
      </method>
      <method name="get_user_action_time" c:identifier="tp_account_channel_request_get_user_action_time" version="0.11.12">
        <doc xml:whitespace="preserve">Return the #TpAccountChannelRequest:user-action-time construct-only property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpAccountChannelRequest:user-action-time</doc>
          <type name="int64" c:type="gint64"/>
        </return-value>
      </method>
      <method name="create_and_handle_channel_async" c:identifier="tp_account_channel_request_create_and_handle_channel_async" version="0.11.12">
        <doc xml:whitespace="preserve">Asynchronously calls CreateChannel on the ChannelDispatcher to create a
channel with the properties defined in #TpAccountChannelRequest:request
that you are going to handle yourself.
When the operation is finished, @callback will be called. You can then call
tp_account_channel_request_create_and_handle_channel_finish() to get the
result of the operation.
(Behind the scenes, this works by creating a temporary #TpBaseClient, then
acting like tp_account_channel_request_create_channel_async() with the
temporary #TpBaseClient as the @preferred_handler.)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cancellable" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="async" closure="3">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_and_handle_channel_finish" c:identifier="tp_account_channel_request_create_and_handle_channel_finish" version="0.11.12" throws="1">
        <doc xml:whitespace="preserve">Finishes an async channel creation started using
tp_account_channel_request_create_and_handle_channel_async().
See tp_account_channel_request_ensure_and_handle_channel_finish()
for details of how @context can be used.
channel was successfully created and you are handling it, otherwise %NULL.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new reference on a #TpChannel if the</doc>
          <type name="Channel" c:type="TpChannel*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="context" direction="out" caller-allocates="0" transfer-ownership="full" allow-none="1">
            <doc xml:whitespace="preserve">pointer used to return a reference to the context of the HandleChannels() call, or %NULL</doc>
            <type name="HandleChannelsContext" c:type="TpHandleChannelsContext**"/>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_and_handle_channel_async" c:identifier="tp_account_channel_request_ensure_and_handle_channel_async" version="0.11.12">
        <doc xml:whitespace="preserve">Asynchronously calls EnsureChannel on the ChannelDispatcher to create a
channel with the properties defined in #TpAccountChannelRequest:request
that you are going to handle yourself.
When the operation is finished, @callback will be called. You can then call
tp_account_channel_request_ensure_and_handle_channel_finish() to get the
result of the operation.
If the channel already exists and is already being handled, or if a
newly created channel is sent to a different handler, this operation
will fail with the error %TP_ERROR_NOT_YOURS. The other handler
will be notified that the channel was requested again (for instance
with #TpAccountChannelRequest::re-handled,
#TpBaseClientClassHandleChannelsImpl or #TpSimpleHandler:callback),
and can move its window to the foreground, if applicable.
(Behind the scenes, this works by creating a temporary #TpBaseClient, then
acting like tp_account_channel_request_ensure_channel_async() with the
temporary #TpBaseClient as the @preferred_handler.)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cancellable" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="async" closure="3">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_and_handle_channel_finish" c:identifier="tp_account_channel_request_ensure_and_handle_channel_finish" version="0.11.12" throws="1">
        <doc xml:whitespace="preserve">Finishes an async channel creation started using
tp_account_channel_request_ensure_and_handle_channel_async().
If the channel already exists and is already being handled, or if a
newly created channel is sent to a different handler, this operation
will fail with the error %TP_ERROR_NOT_YOURS.
via tp_handle_channels_context_get_handler_info(), and any similar methods
that are added in future. It is not valid for the caller of this method
to call tp_handle_channels_context_accept(),
tp_handle_channels_context_delay() or tp_handle_channels_context_fail().
channel was successfully created and you are handling it, otherwise %NULL.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new reference on a #TpChannel if the</doc>
          <type name="Channel" c:type="TpChannel*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="context" direction="out" caller-allocates="0" transfer-ownership="full" allow-none="1">
            <doc xml:whitespace="preserve">pointer used to return a reference to the context of the HandleChannels() call, or %NULL</doc>
            <type name="HandleChannelsContext" c:type="TpHandleChannelsContext**"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_channel_async" c:identifier="tp_account_channel_request_create_channel_async" version="0.11.12">
        <doc xml:whitespace="preserve">Asynchronously calls CreateChannel on the ChannelDispatcher to create a
channel with the properties defined in #TpAccountChannelRequest:request
and let the ChannelDispatcher dispatch it to an handler.
or the request has failed.
You can then call tp_account_channel_request_create_channel_finish() to
get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="preferred_handler" transfer-ownership="none">
            <doc xml:whitespace="preserve">Either the well-known bus name (starting with %TP_CLIENT_BUS_NAME_BASE) of the preferred handler for the channel, or %NULL to indicate that any handler would be acceptable.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="async" closure="4">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_channel_finish" c:identifier="tp_account_channel_request_create_channel_finish" version="0.11.12" throws="1">
        <doc xml:whitespace="preserve">Finishes an async channel creation started using
tp_account_channel_request_create_channel_async().
otherwise %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the channel was successfully created and dispatched,</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_channel_async" c:identifier="tp_account_channel_request_ensure_channel_async" version="0.11.12">
        <doc xml:whitespace="preserve">Asynchronously calls EnsureChannel on the ChannelDispatcher to create a
channel with the properties defined in #TpAccountChannelRequest:request
and let the ChannelDispatcher dispatch it to an handler.
If a suitable channel already existed, its handler will be notified that
the channel was requested again (for instance with
#TpAccountChannelRequest::re-handled, #TpBaseClientClassHandleChannelsImpl
or #TpSimpleHandler:callback), and can move its window to the foreground,
if applicable. Otherwise, a new channel will be created and dispatched to
a handler.
notified, a new channel has been created and dispatched, or the request
has failed.
You can then call tp_account_channel_request_ensure_channel_finish() to
get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="preferred_handler" transfer-ownership="none">
            <doc xml:whitespace="preserve">Either the well-known bus name (starting with %TP_CLIENT_BUS_NAME_BASE) of the preferred handler for the channel, or %NULL to indicate that any handler would be acceptable.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="async" closure="4">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_channel_finish" c:identifier="tp_account_channel_request_ensure_channel_finish" version="0.11.12" throws="1">
        <doc xml:whitespace="preserve">Finishes an async channel creation started using
tp_account_channel_request_ensure_channel_async().
otherwise %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the channel was successfully ensured and (re-)dispatched,</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="account" version="0.11.12" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The #TpAccount used to request the channel.
Read-only except during construction.
This property can't be %NULL.</doc>
        <type name="Account" c:type="TpAccount"/>
      </property>
      <property name="user-action-time" version="0.11.12" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The user action time that will be passed to the channel dispatcher when
requesting the channel.
This may be the time at which user action occurred, or one of the special
values %TP_USER_ACTION_TIME_NOT_USER_ACTION or
%TP_USER_ACTION_TIME_CURRENT_TIME.
If %TP_USER_ACTION_TIME_NOT_USER_ACTION, the action doesn't involve any
user action. Clients should avoid stealing focus when presenting the
channel.
If %TP_USER_ACTION_TIME_CURRENT_TIME, clients SHOULD behave as though the
user action happened at the current time, e.g. a client may
request that its window gains focus.
On X11-based systems, Gdk 2.x, Clutter 1.0 etc.,
tp_user_action_time_from_x11() can be used to convert an X11 timestamp to
a Telepathy user action time.
If the channel request succeeds, this user action time will be passed on
to the channel's handler. If the handler is a GUI, it may use
tp_user_action_time_should_present() to decide whether to bring its
window to the foreground.</doc>
        <type name="int64" c:type="gint64"/>
      </property>
      <glib:signal name="re-handled" version="0.11.12">
        <doc xml:whitespace="preserve">Emitted when the channel created using @self has been "re-handled".
This means that a Telepathy client has made another request for a
matching channel using an "ensure" API like
tp_account_channel_request_ensure_channel_async(), while the channel
still exists. Instead of creating a new channel, the channel dispatcher
notifies the existing handler of @channel, resulting in this signal.
Most GUI handlers should respond to this signal by checking
via tp_handle_channels_context_get_handler_info(), and any similar methods
that are added in future. It is not valid for the receiver of this signal
to call tp_handle_channels_context_accept(),
tp_handle_channels_context_delay() or tp_handle_channels_context_fail().</doc>
        <return-value transfer-ownership="full">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="channel" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpChannel being re-handled</doc>
            <type name="Channel" c:type="TpChannel"/>
          </parameter>
          <parameter name="user_action_time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the time at which user action occurred, or one of the special values %TP_USER_ACTION_TIME_NOT_USER_ACTION or %TP_USER_ACTION_TIME_CURRENT_TIME; see #TpAccountChannelRequest:user-action-time</doc>
            <type name="int64" c:type="gint64"/>
          </parameter>
          <parameter name="context" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpHandleChannelsContext representing the context of the HandleChannels() call.</doc>
            <type name="HandleChannelsContext" c:type="TpHandleChannelsContext"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="AccountChannelRequestClass" c:type="TpAccountChannelRequestClass" glib:is-gtype-struct-for="AccountChannelRequest" version="0.11.12">
      <doc xml:whitespace="preserve">The class of a #TpAccountChannelRequest.</doc>
    </record>
    <record name="AccountChannelRequestPrivate" c:type="TpAccountChannelRequestPrivate">
    </record>
    <record name="AccountClass" c:type="TpAccountClass" glib:is-gtype-struct-for="Account">
      <doc xml:whitespace="preserve">The class of a #TpAccount.</doc>
      <field name="parent_class">
        <type name="ProxyClass" c:type="TpProxyClass"/>
      </field>
      <field name="_padding">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback"/>
        </array>
      </field>
      <field name="priv">
        <type name="AccountClassPrivate" c:type="TpAccountClassPrivate*"/>
      </field>
    </record>
    <record name="AccountClassPrivate" c:type="TpAccountClassPrivate">
    </record>
    <class name="AccountManager" c:type="TpAccountManager" version="0.7.32" parent="Proxy" glib:type-name="TpAccountManager" glib:get-type="tp_account_manager_get_type" glib:type-struct="AccountManagerClass">
      <doc xml:whitespace="preserve">The Telepathy Account Manager stores real-time communication accounts and
their configuration, places accounts online on request, and manipulates
accounts' presence, nicknames and avatars.</doc>
      <constructor name="new" c:identifier="tp_account_manager_new">
        <doc xml:whitespace="preserve">Convenience function to create a new account manager proxy. The returned
#TpAccountManager is not guaranteed to be ready on return.
Use tp_account_manager_dup() instead if you want an account manager proxy
on the starter or session bus (which is almost always the right thing for
Telepathy).</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new reference to an account manager proxy</doc>
          <type name="AccountManager" c:type="TpAccountManager*"/>
        </return-value>
        <parameters>
          <parameter name="bus_daemon" transfer-ownership="none">
            <doc xml:whitespace="preserve">Proxy for the D-Bus daemon</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="get_feature_quark_core" c:identifier="tp_account_manager_get_feature_quark_core" version="0.9.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;
#TpAccountManager</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the quark used for representing the core feature of a</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="dup" c:identifier="tp_account_manager_dup" version="0.9.0">
        <doc xml:whitespace="preserve">Returns an account manager proxy on the D-Bus daemon on which this
process was activated (if it was launched by D-Bus service activation), or
the session bus (otherwise).
The returned #TpAccountManager is cached; the same #TpAccountManager object
will be returned by this function repeatedly, as long as at least one
reference exists. Note that the returned #TpAccountManager is not guaranteed
to be ready on return.
if it wasn't possible to get a dbus daemon proxy for the
appropriate bus</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">an account manager proxy on the starter or session bus, or %NULL</doc>
          <type name="AccountManager" c:type="TpAccountManager*"/>
        </return-value>
      </function>
      <function name="init_known_interfaces" c:identifier="tp_account_manager_init_known_interfaces" version="0.7.32">
        <doc xml:whitespace="preserve">Ensure that the known interfaces for TpAccountManager have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_ACCOUNT_MANAGER.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <method name="ensure_account" c:identifier="tp_account_manager_ensure_account" version="0.9.0">
        <doc xml:whitespace="preserve">Lookup an account in the account manager @manager. If the desired account
has already been ensured then the same object will be returned, otherwise
it will create a new #TpAccount and add it to @manager. As a result, if
to be ready on return.
The caller must keep a ref to the returned object using g_object_ref() if
it is to be kept.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a new #TpAccount at @path</doc>
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object path for an account</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_valid_accounts" c:identifier="tp_account_manager_get_valid_accounts" version="0.9.0">
        <doc xml:whitespace="preserve">Returns a newly allocated #GList of valid accounts in @manager. The list
must be freed with g_list_free() after used. None of the accounts in the
returned list are guaranteed to be ready.
Note that the #TpAccount&lt;!-- --&gt;s in the returned #GList are not reffed
before returning from this function. One could ref every item in the list
like the following example:
|[
GList *accounts;
account = tp_account_manager_get_valid_accounts (manager);
g_list_foreach (accounts, (GFunc) g_object_ref, NULL);
]|
The list of valid accounts returned is not guaranteed to have been retrieved
until %TP_ACCOUNT_MANAGER_FEATURE_CORE is prepared
(tp_proxy_prepare_async() has returned). Until this feature has
been prepared, an empty list (%NULL) will be returned.</doc>
        <return-value transfer-ownership="container">
          <doc xml:whitespace="preserve">a newly allocated #GList of valid accounts in @manager</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="TelepathyGLib.Account"/>
          </type>
        </return-value>
      </method>
      <method name="set_all_requested_presences" c:identifier="tp_account_manager_set_all_requested_presences" version="0.9.0">
        <doc xml:whitespace="preserve">Iterates through the accounts in @manager and requests the presence
(@type, @status and @message). Note that the presence requested here is
merely a request, and if might not be satisfiable.
You can find the most available presence across all accounts by calling
tp_account_manager_get_most_available_presence().
Setting a requested presence on all accounts will have no effect
until tp_proxy_prepare_async()
(or the older tp_account_manager_prepare_async()) has finished.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a presence type to request</doc>
            <type name="ConnectionPresenceType" c:type="TpConnectionPresenceType"/>
          </parameter>
          <parameter name="status" transfer-ownership="none">
            <doc xml:whitespace="preserve">a status to request</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">a status message to request</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_most_available_presence" c:identifier="tp_account_manager_get_most_available_presence" version="0.9.0">
        <doc xml:whitespace="preserve">Gets the most available presence over all accounts in @manager. This
function does not average presences across all accounts, but it merely
finds the "most available" presence. As a result, there is a guarantee
that there exists at least one account in @manager with the returned
presence.
If no accounts are enabled or valid the output will be
(%TP_CONNECTION_PRESENCE_TYPE_OFFLINE, "offline", "").
The return value of this function is not guaranteed to have been retrieved
until tp_proxy_prepare_async() has finished; until then, the
value will be the same as if no accounts are enabled or valid.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the most available presence across all accounts</doc>
          <type name="ConnectionPresenceType" c:type="TpConnectionPresenceType"/>
        </return-value>
        <parameters>
          <parameter name="status" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:whitespace="preserve">a string to fill with the actual status</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="message" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:whitespace="preserve">a string to fill with the actual status message</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_account_async" c:identifier="tp_account_manager_create_account_async" version="0.9.0">
        <doc xml:whitespace="preserve">Requests an asynchronous create of an account on the account manager
then call tp_account_manager_create_account_finish() to get the result of
the operation.
%TP_ACCOUNT_FEATURE_CORE feature ready on it, so when calling
tp_account_manager_create_account_finish(), one can guarantee this feature
will be ready.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="connection_manager" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a connection manager</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="protocol" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a protocol</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="display_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the display name for the account</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="parameters" transfer-ownership="none">
            <doc xml:whitespace="preserve">parameters for the new account</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
          <parameter name="properties" transfer-ownership="none">
            <doc xml:whitespace="preserve">properties for the new account</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="async" closure="7">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_account_finish" c:identifier="tp_account_manager_create_account_finish" version="0.9.0" throws="1">
        <doc xml:whitespace="preserve">Finishes an async create account operation, and returns a new #TpAccount
object, with the %TP_ACCOUNT_FEATURE_CORE feature ready on it.
The caller must keep a ref to the returned object using g_object_ref() if
it is to be kept.
success, otherwise %NULL</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a new #TpAccount which was just created on</doc>
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_prepared" c:identifier="tp_account_manager_is_prepared" version="0.9.0" introspectable="0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same thing as tp_proxy_is_prepared()</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:whitespace="preserve">a feature which is required</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepare_async" c:identifier="tp_account_manager_prepare_async" version="0.9.0" introspectable="0">
        <doc xml:whitespace="preserve">Requests an asynchronous preparation of @manager with
%TP_ACCOUNT_MANAGER_FEATURE_CORE, plus any features specified
by @features. When the operation is finished, @callback will be called. You
can then call tp_account_manager_prepare_finish() to get the result of the
operation.
If %NULL is given to @callback, then no callback will be called when the
operation is finished. Instead, it will simply set @features on @manager.
Note that if @callback is %NULL, then @user_data must also be %NULL.
In version 0.11.3 or later, this is equivalent to calling
tp_proxy_prepare_async() with the same arguments.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="features" transfer-ownership="none">
            <doc xml:whitespace="preserve">a 0-terminated list of features, or %NULL</doc>
            <type name="GLib.Quark" c:type="GQuark*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="async" closure="3">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepare_finish" c:identifier="tp_account_manager_prepare_finish" version="0.9.0" introspectable="0" throws="1">
        <doc xml:whitespace="preserve">Finishes an async preparation of the account manager @manager.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the preparation was successful, otherwise %FALSE</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="enable_restart" c:identifier="tp_account_manager_enable_restart">
        <doc xml:whitespace="preserve">Enable autostarting the account manager D-Bus service. This means
that the account manager will be restarted if it disappears from
the bus.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <field name="parent">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="priv">
        <type name="AccountManagerPrivate" c:type="TpAccountManagerPrivate*"/>
      </field>
      <glib:signal name="account-disabled" version="0.9.0">
        <doc xml:whitespace="preserve">Emitted when an account from @manager is disabled.</doc>
        <return-value transfer-ownership="full">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="account-enabled" version="0.9.0">
        <doc xml:whitespace="preserve">Emitted when an account from @manager is enabled.
Note that the returned #TpAccount @account is not guaranteed to have any
features pre-prepared, including %TP_ACCOUNT_FEATURE_CORE.</doc>
        <return-value transfer-ownership="full">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="account-removed" version="0.9.0">
        <doc xml:whitespace="preserve">Emitted when an account is removed from @manager.</doc>
        <return-value transfer-ownership="full">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="account-validity-changed" version="0.9.0">
        <doc xml:whitespace="preserve">Emitted when the validity on @account changes. @account is not guaranteed
to be ready when this signal is emitted.</doc>
        <return-value transfer-ownership="full">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount"/>
          </parameter>
          <parameter name="valid" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the account is now valid</doc>
            <type name="boolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="most-available-presence-changed" version="0.9.0">
        <doc xml:whitespace="preserve">Emitted when the most available presence on @manager changes.</doc>
        <return-value transfer-ownership="full">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="presence" transfer-ownership="none">
            <doc xml:whitespace="preserve">new presence type</doc>
            <type name="uint" c:type="guint"/>
          </parameter>
          <parameter name="status" transfer-ownership="none">
            <doc xml:whitespace="preserve">new status</doc>
            <type name="utf8" c:type="gchararray"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">new status message</doc>
            <type name="utf8" c:type="gchararray"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="AccountManagerClass" c:type="TpAccountManagerClass" glib:is-gtype-struct-for="AccountManager">
      <doc xml:whitespace="preserve">The class of a #TpAccount.</doc>
      <field name="parent_class">
        <type name="ProxyClass" c:type="TpProxyClass"/>
      </field>
      <field name="_padding">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback"/>
        </array>
      </field>
      <field name="priv">
        <type name="AccountManagerClassPrivate" c:type="TpAccountManagerClassPrivate*"/>
      </field>
    </record>
    <record name="AccountManagerClassPrivate" c:type="TpAccountManagerClassPrivate">
    </record>
    <record name="AccountManagerPrivate" c:type="TpAccountManagerPrivate">
    </record>
    <record name="AccountPrivate" c:type="TpAccountPrivate">
    </record>
    <class name="AddDispatchOperationContext" c:type="TpAddDispatchOperationContext" version="0.11.5" parent="GObject.Object" glib:type-name="TpAddDispatchOperationContext" glib:get-type="tp_add_dispatch_operation_context_get_type" glib:type-struct="AddDispatchOperationContextClass">
      <doc xml:whitespace="preserve">Data structure representing the context of a Approver.AddDispatchOperation()
call.</doc>
      <method name="accept" c:identifier="tp_add_dispatch_operation_context_accept" version="0.11.5">
        <doc xml:whitespace="preserve">Called by #TpBaseClientClassAddDispatchOperationImpl when it's done so
the D-Bus method can return.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="fail" c:identifier="tp_add_dispatch_operation_context_fail" version="0.11.5">
        <doc xml:whitespace="preserve">Called by #TpBaseClientClassAddDispatchOperationImpl to raise a D-Bus error.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="error" transfer-ownership="none">
            <doc xml:whitespace="preserve">the error to return from the method</doc>
            <type name="GLib.Error" c:type="GError*"/>
          </parameter>
        </parameters>
      </method>
      <method name="delay" c:identifier="tp_add_dispatch_operation_context_delay" version="0.11.5">
        <doc xml:whitespace="preserve">Called by #TpBaseClientClassAddDispatchOperationImpl to indicate that it
implements the method in an async way. The caller must take a reference
to the #TpAddDispatchOperationContext before calling this function, and
is responsible for calling either
tp_add_dispatch_operation_context_accept() or
tp_add_dispatch_operation_context_fail() later.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <property name="account" version="0.11.5" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TpAccount object representing the Account of the DispatchOperation
that has been passed to AddDispatchOperation.
Read-only except during construction.
This property can't be %NULL.</doc>
        <type name="Account" c:type="TpAccount"/>
      </property>
      <property name="channels" version="0.11.5" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GPtrArray containing #TpChannel objects representing the channels
that have been passed to AddDispatchOperation.
Read-only except during construction.
This property can't be %NULL.</doc>
        <type name="GLib.PtrArray" c:type="GPtrArray"/>
      </property>
      <property name="connection" version="0.11.5" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TpConnection object representing the Connection of the DispatchOperation
that has been passed to AddDispatchOperation.
Read-only except during construction.
This property can't be %NULL.</doc>
        <type name="Connection" c:type="TpConnection"/>
      </property>
      <property name="dbus-context" version="0.11.5" introspectable="0" readable="0" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The #DBusGMethodInvocation representing the D-Bus context of the
AddDispatchOperation call.
Can only be written during construction.</doc>
        <type name="any" c:type="gpointer"/>
      </property>
      <property name="dispatch-operation" version="0.11.5" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TpChannelDispatchOperation object representing the
ChannelDispatchOperation that has been passed to AddDispatchOperation.
Read-only except during construction.
This property can't be %NULL.</doc>
        <type name="ChannelDispatchOperation" c:type="TpChannelDispatchOperation"/>
      </property>
    </class>
    <record name="AddDispatchOperationContextClass" c:type="TpAddDispatchOperationContextClass" glib:is-gtype-struct-for="AddDispatchOperationContext" version="0.11.5">
      <doc xml:whitespace="preserve">The class of a #TpAddDispatchOperationContext.</doc>
    </record>
    <record name="AddDispatchOperationContextPrivate" c:type="TpAddDispatchOperationContextPrivate">
    </record>
    <enumeration name="AnonymityModeFlags" c:type="TpAnonymityModeFlags">
      <member name="client_info" value="1" c:identifier="TP_ANONYMITY_MODE_CLIENT_INFO"/>
      <member name="show_client_info" value="2" c:identifier="TP_ANONYMITY_MODE_SHOW_CLIENT_INFO"/>
      <member name="network_info" value="4" c:identifier="TP_ANONYMITY_MODE_NETWORK_INFO"/>
    </enumeration>
    <record name="AvatarRequirements" c:type="TpAvatarRequirements" glib:type-name="TpAvatarRequirements" glib:get-type="tp_avatar_requirements_get_type">
      <field name="supported_mime_types" writable="1">
        <array c:type="GStrv">
          <type name="utf8"/>
        </array>
      </field>
      <field name="minimum_width" writable="1">
        <type name="uint" c:type="guint"/>
      </field>
      <field name="minimum_height" writable="1">
        <type name="uint" c:type="guint"/>
      </field>
      <field name="recommended_width" writable="1">
        <type name="uint" c:type="guint"/>
      </field>
      <field name="recommended_height" writable="1">
        <type name="uint" c:type="guint"/>
      </field>
      <field name="maximum_width" writable="1">
        <type name="uint" c:type="guint"/>
      </field>
      <field name="maximum_height" writable="1">
        <type name="uint" c:type="guint"/>
      </field>
      <field name="maximum_bytes" writable="1">
        <type name="uint" c:type="guint"/>
      </field>
      <field name="_1" writable="1">
        <type name="any" c:type="gpointer"/>
      </field>
      <field name="_2" writable="1">
        <type name="any" c:type="gpointer"/>
      </field>
      <field name="_3" writable="1">
        <type name="any" c:type="gpointer"/>
      </field>
      <field name="_4" writable="1">
        <type name="any" c:type="gpointer"/>
      </field>
      <constructor name="new" c:identifier="tp_avatar_requirements_new">
        <return-value transfer-ownership="full">
          <type name="AvatarRequirements" c:type="TpAvatarRequirements*"/>
        </return-value>
        <parameters>
          <parameter name="supported_mime_types" transfer-ownership="none">
            <array c:type="GStrv">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="minimum_width" transfer-ownership="none">
            <type name="uint" c:type="guint"/>
          </parameter>
          <parameter name="minimum_height" transfer-ownership="none">
            <type name="uint" c:type="guint"/>
          </parameter>
          <parameter name="recommended_width" transfer-ownership="none">
            <type name="uint" c:type="guint"/>
          </parameter>
          <parameter name="recommended_height" transfer-ownership="none">
            <type name="uint" c:type="guint"/>
          </parameter>
          <parameter name="maximum_width" transfer-ownership="none">
            <type name="uint" c:type="guint"/>
          </parameter>
          <parameter name="maximum_height" transfer-ownership="none">
            <type name="uint" c:type="guint"/>
          </parameter>
          <parameter name="maximum_bytes" transfer-ownership="none">
            <type name="uint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy" c:identifier="tp_avatar_requirements_copy">
        <return-value transfer-ownership="full">
          <type name="AvatarRequirements" c:type="TpAvatarRequirements*"/>
        </return-value>
      </method>
      <method name="destroy" c:identifier="tp_avatar_requirements_destroy">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <class name="BaseClient" c:type="TpBaseClient" version="0.11.5" parent="GObject.Object" abstract="1" glib:type-name="TpBaseClient" glib:get-type="tp_base_client_get_type" glib:type-struct="BaseClientClass">
      <doc xml:whitespace="preserve">Data structure representing a generic #TpSvcClient implementation.</doc>
      <function name="implement_observe_channels" c:identifier="tp_base_client_implement_observe_channels" version="0.11.5" introspectable="0">
        <doc xml:whitespace="preserve">Called by subclasses to define the actual implementation of the
ObserveChannels() D-Bus method.
Since 0.11.13 this is exactly equivalent to setting the
#TpBaseClientClass.observe_channels function pointer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="klass" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpBaseClientClass of the object</doc>
            <type name="BaseClientClass" c:type="TpBaseClientClass*"/>
          </parameter>
          <parameter name="impl" transfer-ownership="none" scope="call">
            <doc xml:whitespace="preserve">the #TpBaseClientClassObserveChannelsImpl function implementing ObserveChannels()</doc>
            <type name="BaseClientClassObserveChannelsImpl" c:type="TpBaseClientClassObserveChannelsImpl"/>
          </parameter>
        </parameters>
      </function>
      <function name="implement_add_dispatch_operation" c:identifier="tp_base_client_implement_add_dispatch_operation" version="0.11.5" introspectable="0">
        <doc xml:whitespace="preserve">Called by subclasses to define the actual implementation of the
AddDispatchOperation() D-Bus method.
Since 0.11.13 this is exactly equivalent to setting the
#TpBaseClientClass.add_dispatch_operation function pointer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="klass" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpBaseClientClass of the object</doc>
            <type name="BaseClientClass" c:type="TpBaseClientClass*"/>
          </parameter>
          <parameter name="impl" transfer-ownership="none" scope="call">
            <doc xml:whitespace="preserve">the #TpBaseClientClassAddDispatchOperationImpl function implementing AddDispatchOperation()</doc>
            <type name="BaseClientClassAddDispatchOperationImpl" c:type="TpBaseClientClassAddDispatchOperationImpl"/>
          </parameter>
        </parameters>
      </function>
      <function name="implement_handle_channels" c:identifier="tp_base_client_implement_handle_channels" version="0.11.6" introspectable="0">
        <doc xml:whitespace="preserve">Called by subclasses to define the actual implementation of the
HandleChannels() D-Bus method.
Since 0.11.13 this is exactly equivalent to setting the
#TpBaseClientClass.handle_channels function pointer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="klass" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpBaseClientClass of the object</doc>
            <type name="BaseClientClass" c:type="TpBaseClientClass*"/>
          </parameter>
          <parameter name="impl" transfer-ownership="none" scope="call">
            <doc xml:whitespace="preserve">the #TpBaseClientClassHandleChannelsImpl function implementing HandleCHannels()</doc>
            <type name="BaseClientClassHandleChannelsImpl" c:type="TpBaseClientClassHandleChannelsImpl"/>
          </parameter>
        </parameters>
      </function>
      <method name="add_observer_filter" c:identifier="tp_base_client_add_observer_filter" version="0.11.5">
        <doc xml:whitespace="preserve">Register a new channel class as Observer.ObserverChannelFilter.
The #TpBaseClientClass.observe_channels virtual method will be called
whenever a new channel's properties match the ones in @filter.
This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.observe_channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="filter" transfer-ownership="none">
            <doc xml:whitespace="preserve">a %TP_HASH_TYPE_CHANNEL_CLASS</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="take_observer_filter" c:identifier="tp_base_client_take_observer_filter" version="0.11.5" introspectable="0">
        <doc xml:whitespace="preserve">The same as tp_base_client_add_observer_filter(), but ownership of @filter
is taken by @self. This makes it convenient to call using tp_asv_new():
|[
tp_base_client_take_observer_filter (client,
tp_asv_new (
TP_PROP_CHANNEL_CHANNEL_TYPE, G_TYPE_STRING,
TP_IFACE_CHANNEL_TYPE_TEXT,
TP_PROP_CHANNEL_TARGET_HANDLE_TYPE, G_TYPE_UINT,
TP_HANDLE_TYPE_CONTACT,
...));
]|</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="filter" transfer-ownership="full">
            <doc xml:whitespace="preserve">a %TP_HASH_TYPE_CHANNEL_CLASS, ownership of which is taken by @self</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="set_observer_recover" c:identifier="tp_base_client_set_observer_recover" version="0.11.5">
        <doc xml:whitespace="preserve">Set whether the channel dispatcher should attempt to recover
this Observer if it crashes. (This is implemented by setting
the value of its Recover D-Bus property.)
Normally, Observers are only notified when new channels
appear. If an Observer is set to recover, when it registers with
tp_base_client_register(), it will also be told about any channels
that already existed before it started.
For Observers that are activatable as a D-Bus service, if the
Observer exits or crashes while there are any channels that match
its filter, it will automatically be restarted by service-activation.
This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.observe_channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="recover" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the Observer.Recover property</doc>
            <type name="boolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_approver_filter" c:identifier="tp_base_client_add_approver_filter" version="0.11.5">
        <doc xml:whitespace="preserve">Register a new channel class as Approver.ApproverChannelFilter.
The #TpBaseClientClass.add_dispatch_operation virtual method will be called
whenever a new channel's properties match the ones in @filter.
This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.add_dispatch_operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="filter" transfer-ownership="none">
            <doc xml:whitespace="preserve">a %TP_HASH_TYPE_CHANNEL_CLASS</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="take_approver_filter" c:identifier="tp_base_client_take_approver_filter" version="0.11.5" introspectable="0">
        <doc xml:whitespace="preserve">The same as tp_base_client_add_approver_filter(), but ownership of @filter
is taken by @self. This makes it convenient to call using tp_asv_new():
|[
tp_base_client_take_approver_filter (client,
tp_asv_new (
TP_PROP_CHANNEL_CHANNEL_TYPE, G_TYPE_STRING,
TP_IFACE_CHANNEL_TYPE_TEXT,
TP_PROP_CHANNEL_TARGET_HANDLE_TYPE, G_TYPE_UINT,
TP_HANDLE_TYPE_CONTACT,
...));
]|</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="filter" transfer-ownership="full">
            <doc xml:whitespace="preserve">a %TP_HASH_TYPE_CHANNEL_CLASS, ownership of which is taken by @self</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="be_a_handler" c:identifier="tp_base_client_be_a_handler" version="0.11.6">
        <doc xml:whitespace="preserve">Register @self as a ChannelHandler with an empty list of filter.
This is useful if you want to create a client that only handle channels
for which it's the PreferredHandler.
This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class has called
#TpBaseClientClass.handle_channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="add_handler_filter" c:identifier="tp_base_client_add_handler_filter" version="0.11.6">
        <doc xml:whitespace="preserve">Register a new channel class as Handler.HandlerChannelFilter.
The #TpBaseClientClass.handle_channels virtual method will be called
whenever a new channel's properties match the ones in @filter.
This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.handle_channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="filter" transfer-ownership="none">
            <doc xml:whitespace="preserve">a %TP_HASH_TYPE_CHANNEL_CLASS</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="take_handler_filter" c:identifier="tp_base_client_take_handler_filter" version="0.11.6" introspectable="0">
        <doc xml:whitespace="preserve">The same as tp_base_client_add_handler_filter(), but ownership of @filter
is taken by @self. This makes it convenient to call using tp_asv_new():
|[
tp_base_client_take_handler_filter (client,
tp_asv_new (
TP_PROP_CHANNEL_CHANNEL_TYPE, G_TYPE_STRING,
TP_IFACE_CHANNEL_TYPE_TEXT,
TP_PROP_CHANNEL_TARGET_HANDLE_TYPE, G_TYPE_UINT,
TP_HANDLE_TYPE_CONTACT,
...));
]|</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="filter" transfer-ownership="full">
            <doc xml:whitespace="preserve">a %TP_HASH_TYPE_CHANNEL_CLASS, ownership of which is taken by @self</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="set_handler_bypass_approval" c:identifier="tp_base_client_set_handler_bypass_approval" version="0.11.6">
        <doc xml:whitespace="preserve">Set whether the channels destined for this handler are automatically
handled, without invoking approvers.
(This is implemented by setting the value of its BypassApproval
D-Bus property.)
This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.handle_channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="bypass_approval" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the Handler.BypassApproval property</doc>
            <type name="boolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_handler_request_notification" c:identifier="tp_base_client_set_handler_request_notification" version="0.11.6">
        <doc xml:whitespace="preserve">Indicate that @self is a Handler willing to be notified about requests for
channels that it is likely to be asked to handle.
That means the TpBaseClient::request-added and TpBaseClient::request-removed:
signals will be fired and tp_base_client_get_pending_requests() will
return the list of pending requests.
This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.handle_channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="add_handler_capability" c:identifier="tp_base_client_add_handler_capability" version="0.11.6">
        <doc xml:whitespace="preserve">Add one capability token to this client, as if via
tp_base_client_add_handler_capabilities().
This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.handle_channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="token" transfer-ownership="none">
            <doc xml:whitespace="preserve">a capability token as defined by the Telepathy D-Bus API Specification</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_handler_capabilities" c:identifier="tp_base_client_add_handler_capabilities" version="0.11.6">
        <doc xml:whitespace="preserve">Add several capability tokens to this client. These are used to signal
that Telepathy connection managers should advertise certain capabilities
to other contacts, such as the ability to receive audio/video calls using
particular streaming protocols and codecs.
This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.handle_channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="tokens" transfer-ownership="none">
            <doc xml:whitespace="preserve">capability tokens as defined by the Telepathy D-Bus API Specification</doc>
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="add_handler_capabilities_varargs" c:identifier="tp_base_client_add_handler_capabilities_varargs" version="0.11.6" introspectable="0">
        <doc xml:whitespace="preserve">Convenience C API equivalent to calling
tp_base_client_add_handler_capability() for each capability token.
This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.handle_channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="first_token" transfer-ownership="none">
            <doc xml:whitespace="preserve">a capability token from the Telepathy D-Bus API Specification</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="add_account_features" c:identifier="tp_base_client_add_account_features" version="0.11.14">
        <doc xml:whitespace="preserve">Request that the given features are prepared on each #TpAccount (in
addition to %TP_ACCOUNT_FEATURE_CORE) before calling
#TpBaseClient.observe_channels, #TpBaseClient.add_dispatch_operation or
#TpBaseClient.handle_channels, or emitting #TpBaseClient::request-added.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="features" transfer-ownership="none">
            <doc xml:whitespace="preserve">the features</doc>
            <array length="2" c:type="GQuark*">
              <type name="GLib.Quark"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of features, or -1 if @features is 0-terminated</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_account_features_varargs" c:identifier="tp_base_client_add_account_features_varargs" version="0.11.14" introspectable="0">
        <doc xml:whitespace="preserve">The same as tp_base_client_add_account_features(), but with a more
convenient calling convention from C.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:whitespace="preserve">the first feature</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="add_channel_features" c:identifier="tp_base_client_add_channel_features" version="0.11.14">
        <doc xml:whitespace="preserve">Request that the given features are prepared on each #TpChannel (in
addition to %TP_CHANNEL_FEATURE_CORE) before calling
#TpBaseClient.observe_channels, #TpBaseClient.add_dispatch_operation or
#TpBaseClient.handle_channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="features" transfer-ownership="none">
            <doc xml:whitespace="preserve">the features</doc>
            <array length="2" c:type="GQuark*">
              <type name="GLib.Quark"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of features, or -1 if @features is 0-terminated</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_channel_features_varargs" c:identifier="tp_base_client_add_channel_features_varargs" version="0.11.14" introspectable="0">
        <doc xml:whitespace="preserve">The same as tp_base_client_add_channel_features(), but with a more
convenient calling convention from C.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:whitespace="preserve">the first feature</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="add_connection_features" c:identifier="tp_base_client_add_connection_features" version="0.11.14">
        <doc xml:whitespace="preserve">Request that the given features are prepared on each #TpConnection (in
addition to %TP_CONNECTION_FEATURE_CORE) before calling
#TpBaseClient.observe_channels, #TpBaseClient.add_dispatch_operation or
#TpBaseClient.handle_channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="features" transfer-ownership="none">
            <doc xml:whitespace="preserve">the features</doc>
            <array length="2" c:type="GQuark*">
              <type name="GLib.Quark"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of features, or -1 if @features is 0-terminated</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_connection_features_varargs" c:identifier="tp_base_client_add_connection_features_varargs" version="0.11.14" introspectable="0">
        <doc xml:whitespace="preserve">The same as tp_base_client_add_connection_features(), but with a more
convenient calling convention from C.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:whitespace="preserve">the first feature</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="register" c:identifier="tp_base_client_register" version="0.11.5" throws="1">
        <doc xml:whitespace="preserve">Publish @self as an available client. After this method is called, as long
as it continues to exist, it will receive and process whatever events were
requested via the various filters.
Methods that set the filters and other immutable state, such as
tp_base_client_add_observer_filter(), cannot be called after this one.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the client was registered successfully</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_pending_requests" c:identifier="tp_base_client_get_pending_requests" version="0.11.6">
        <doc xml:whitespace="preserve">Only works if tp_base_client_set_handler_request_notification() has been
called.
Returns the list of requests @self is likely be asked to handle.
#GList of #TpChannelRequest</doc>
        <return-value transfer-ownership="container">
          <doc xml:whitespace="preserve">a</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="TelepathyGLib.ChannelRequest"/>
          </type>
        </return-value>
      </method>
      <method name="get_handled_channels" c:identifier="tp_base_client_get_handled_channels" version="0.11.6">
        <doc xml:whitespace="preserve">Returns the set of channels currently handled by this base client or by any
other #TpBaseClient with which it shares a unique name.
handled channels</doc>
        <return-value transfer-ownership="container">
          <doc xml:whitespace="preserve">the</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="TelepathyGLib.Channel"/>
          </type>
        </return-value>
      </method>
      <method name="get_name" c:identifier="tp_base_client_get_name" version="0.11.11" introspectable="0">
        <doc xml:whitespace="preserve">Return the #TpBaseClient:name construct-only property, which is used as
part of the bus name and object path.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpBaseClient:name</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_uniquify_name" c:identifier="tp_base_client_get_uniquify_name" version="0.11.11" introspectable="0">
        <doc xml:whitespace="preserve">Return the #TpBaseClient:uniquify-name construct-only property; if this
is true, the bus name and object path will be made unique by appending
a suffix that includes the D-Bus unique name and a per-process counter.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpBaseClient:uniquify-name</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_bus_name" c:identifier="tp_base_client_get_bus_name" version="0.11.5">
        <doc xml:whitespace="preserve">Return the bus name of @self. Note that doesn't mean the client is
actually owning this name; for example if tp_base_client_register()
has not been called yet or failed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the bus name of the client</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_object_path" c:identifier="tp_base_client_get_object_path" version="0.11.5">
        <doc xml:whitespace="preserve">Return the object path of @self. Note that doesn't mean the client is
actually registered on this path; for example if tp_base_client_register()
has not been called yet or failed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the object path of the client</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_dbus_daemon" c:identifier="tp_base_client_get_dbus_daemon" version="0.11.11" introspectable="0">
        <doc xml:whitespace="preserve">Return the #TpBaseClient:dbus-daemon construct-only property, which
represents the D-Bus connection used to export this client object.
The returned object's reference count is not incremented, so it is not
necessarily valid after @self is destroyed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">dbus-daemon</doc>
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </return-value>
      </method>
      <method name="get_account_manager" c:identifier="tp_base_client_get_account_manager" version="0.11.14" introspectable="0">
        <doc xml:whitespace="preserve">Return the #TpBaseClient:account-manager construct-only property, which
is the account manager used to look up or create #TpAccount objects.
The returned object's reference count is not incremented, so it is not
necessarily valid after @self is destroyed.
It is not guaranteed that any particular features are prepared on this
object; enable and wait for features with tp_proxy_prepare_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">account-manager</doc>
          <type name="AccountManager" c:type="TpAccountManager*"/>
        </return-value>
      </method>
      <method name="unregister" c:identifier="tp_base_client_unregister" version="0.11.6">
        <doc xml:whitespace="preserve">Remove this client object from D-Bus, if tp_base_client_register()
has already been called.
If the object is not registered, this method may be called, but has
no effect.
Releasing the last reference to the object also has the same effect
as calling this method, but this method should be preferred, as it
has more deterministic behaviour.
If the object still exists, tp_base_client_register() may be used to
attempt to register it again.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <property name="account-manager" version="0.11.14" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">Account manager for this base client, used to look up or create
#TpAccount objects. This may be specified in the constructor in order
to get existing #TpAccount objects.
It is not guaranteed that any of its features have been prepared, and
it is not necessary to wait for any features before specifying this
property in the constructor.
Clients that interact with the #TpAccount should usually
set this property instead of #TpBaseClient:dbus-daemon. Doing this
will ensure that each account, connection or contact is represented by
a single #TpAccount, #TpConnection or #TpContact object, shared between
all the cooperating modules that have the same #TpAccountManager.
If the #TpBaseClient:dbus-daemon is set to the result of
tp_dbus_daemon_dup(), then this property defaults to
the result of tp_account_manager_dup().
This property may be %NULL initially, but will always be non-%NULL
after the #TpBaseClient has been constructed.
It is an error to specify both a non-%NULL account manager, and a
non-%NULL #TpBaseClient:dbus-daemon that is not the same as the
account manager's #TpProxy:dbus-daemon.</doc>
        <type name="AccountManager" c:type="TpAccountManager"/>
      </property>
      <property name="dbus-daemon" version="0.11.5" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">#TpDBusDaemon object encapsulating this object's connection to D-Bus.
Read-only except during construction.
This property can't be %NULL after construction.
Since 0.11.14 this property may be %NULL or unspecified in
g_object_new(), but only if #TpBaseClient:account-manager is provided
instead, in which case its #TpProxy:dbus-daemon property will be
used.</doc>
        <type name="DBusDaemon" c:type="TpDBusDaemon"/>
      </property>
      <property name="name" version="0.11.5" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The name of the client. This is used to register the D-Bus service name
and object path of the service.
This property can't be %NULL.</doc>
        <type name="utf8" c:type="gchararray"/>
      </property>
      <property name="uniquify-name" version="0.11.5" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">If %TRUE, tp_base_client_register() will append an unique token to the
service bus name and object path to ensure they are unique.</doc>
        <type name="boolean" c:type="gboolean"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="BaseClientPrivate" c:type="TpBaseClientPrivate*"/>
      </field>
      <glib:signal name="request-added" version="0.11.6">
        <doc xml:whitespace="preserve">Emitted when a channels have been requested, and that if the
request is successful, they will probably be handled by this Handler.
This signal is only fired if
tp_base_client_set_handler_request_notification() has been called
on @self previously.</doc>
        <return-value transfer-ownership="full">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpAccount on which the request was made, with %TP_ACCOUNT_FEATURE_CORE, and any other features added via tp_base_client_add_account_features(), prepared if possible</doc>
            <type name="Account" c:type="TpAccount"/>
          </parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpChannelRequest having its object-path defined but is not guaranteed to be prepared.</doc>
            <type name="ChannelRequest" c:type="TpChannelRequest"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="request-removed" version="0.11.6">
        <doc xml:whitespace="preserve">Emitted when a request has failed and should be disregarded.
This signal is only fired if
tp_base_client_set_handler_request_notification() has been called
on @self previously.</doc>
        <return-value transfer-ownership="full">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="request" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpChannelRequest being removed</doc>
            <type name="ChannelRequest" c:type="TpChannelRequest"/>
          </parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the D-Bus error with which the request failed.</doc>
            <type name="utf8" c:type="gchararray"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">any message supplied with the D-Bus error.</doc>
            <type name="utf8" c:type="gchararray"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="BaseClientClass" c:type="TpBaseClientClass" glib:is-gtype-struct-for="BaseClient" version="0.11.5">
      <doc xml:whitespace="preserve">The class of a #TpBaseClient.
The virtual methods @observe_channels, @add_dispatch_operation and
tp_base_client_implement_observe_channels(),
tp_base_client_implement_add_dispatch_operation() and
tp_base_client_implement_handle_channels(). This is compatible with
telepathy-glib versions older than 0.11.13.</doc>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="observe_channels">
        <type name="BaseClientClassObserveChannelsImpl" c:type="TpBaseClientClassObserveChannelsImpl"/>
      </field>
      <field name="add_dispatch_operation">
        <type name="BaseClientClassAddDispatchOperationImpl" c:type="TpBaseClientClassAddDispatchOperationImpl"/>
      </field>
      <field name="handle_channels">
        <type name="BaseClientClassHandleChannelsImpl" c:type="TpBaseClientClassHandleChannelsImpl"/>
      </field>
      <field name="_padding">
        <array zero-terminated="0" c:type="GCallback" fixed-size="4">
          <type name="GObject.Callback"/>
        </array>
      </field>
      <field name="dbus_properties_class">
        <type name="DBusPropertiesMixinClass" c:type="TpDBusPropertiesMixinClass"/>
      </field>
      <field name="priv">
        <type name="BaseClientClassPrivate" c:type="TpBaseClientClassPrivate*"/>
      </field>
    </record>
    <callback name="BaseClientClassAddDispatchOperationImpl" c:type="TpBaseClientClassAddDispatchOperationImpl" version="0.11.5">
      <doc xml:whitespace="preserve">Signature of the implementation of the AddDispatchOperation method.
This function must call either tp_add_dispatch_operation_context_accept(),
tp_add_dispatch_operation_context_delay() or
tp_add_dispatch_operation_context_fail() on @context before it returns.
The implementation can then use
tp_channel_dispatch_operation_handle_with_async() to approve handling of the
channels, or tp_channel_dispatch_operation_claim_async() to take
responsibility for handling or closing them".</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="client" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpBaseClient instance</doc>
          <type name="BaseClient" c:type="TpBaseClient*"/>
        </parameter>
        <parameter name="account" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpAccount with %TP_ACCOUNT_FEATURE_CORE, and any other features added via tp_base_client_add_account_features(), prepared if possible</doc>
          <type name="Account" c:type="TpAccount*"/>
        </parameter>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpConnection with %TP_CONNECTION_FEATURE_CORE, and any other features added via tp_base_client_add_connection_features(), prepared if possible</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GList of #TpChannel, each with %TP_CHANNEL_FEATURE_CORE, and any other features added via tp_base_client_add_channel_features(), prepared if possible</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="TelepathyGLib.Channel"/>
          </type>
        </parameter>
        <parameter name="dispatch_operation" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpChannelDispatchOperation having %TP_CHANNEL_DISPATCH_OPERATION_FEATURE_CORE prepared if possible</doc>
          <type name="ChannelDispatchOperation" c:type="TpChannelDispatchOperation*"/>
        </parameter>
        <parameter name="context" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpObserveChannelsContext representing the context of this D-Bus call</doc>
          <type name="AddDispatchOperationContext" c:type="TpAddDispatchOperationContext*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="BaseClientClassHandleChannelsImpl" c:type="TpBaseClientClassHandleChannelsImpl" version="0.11.6">
      <doc xml:whitespace="preserve">Signature of the implementation of the HandleChannels method.
This function must call either tp_handle_channels_context_accept(),
tp_handle_channels_context_delay() or tp_handle_channels_context_fail()
on @context before it returns.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="client" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpBaseClient instance</doc>
          <type name="BaseClient" c:type="TpBaseClient*"/>
        </parameter>
        <parameter name="account" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpAccount with %TP_ACCOUNT_FEATURE_CORE, and any other features added via tp_base_client_add_account_features(), prepared if possible</doc>
          <type name="Account" c:type="TpAccount*"/>
        </parameter>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpConnection with %TP_CONNECTION_FEATURE_CORE, and any other features added via tp_base_client_add_connection_features(), prepared if possible</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GList of #TpChannel, each with %TP_CHANNEL_FEATURE_CORE, and any other features added via tp_base_client_add_channel_features(), prepared if possible</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="TelepathyGLib.Channel"/>
          </type>
        </parameter>
        <parameter name="requests_satisfied" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GList of #TpChannelRequest having their object-path defined but are not guaranteed to be prepared.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="TelepathyGLib.ChannelRequest"/>
          </type>
        </parameter>
        <parameter name="user_action_time" transfer-ownership="none">
          <doc xml:whitespace="preserve">the time at which user action occurred, or one of the special values %TP_USER_ACTION_TIME_NOT_USER_ACTION or %TP_USER_ACTION_TIME_CURRENT_TIME (see #TpAccountChannelRequest:user-action-time for details)</doc>
          <type name="int64" c:type="gint64"/>
        </parameter>
        <parameter name="context" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpHandleChannelsContext representing the context of this D-Bus call</doc>
          <type name="HandleChannelsContext" c:type="TpHandleChannelsContext*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="BaseClientClassObserveChannelsImpl" c:type="TpBaseClientClassObserveChannelsImpl" version="0.11.5">
      <doc xml:whitespace="preserve">Signature of the implementation of the ObserveChannels method.
This function must call either tp_observe_channels_context_accept(),
tp_observe_channels_context_delay() or tp_observe_channels_context_fail()
on @context before it returns.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="client" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpBaseClient instance</doc>
          <type name="BaseClient" c:type="TpBaseClient*"/>
        </parameter>
        <parameter name="account" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpAccount with %TP_ACCOUNT_FEATURE_CORE, and any other features added via tp_base_client_add_account_features(), prepared if possible</doc>
          <type name="Account" c:type="TpAccount*"/>
        </parameter>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpConnection with %TP_CONNECTION_FEATURE_CORE, and any other features added via tp_base_client_add_connection_features(), prepared if possible</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GList of #TpChannel, each with %TP_CHANNEL_FEATURE_CORE, and any other features added via tp_base_client_add_channel_features(), prepared if possible</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="TelepathyGLib.Channel"/>
          </type>
        </parameter>
        <parameter name="dispatch_operation" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">a #TpChannelDispatchOperation or %NULL; the dispatch_operation is not guaranteed to be prepared</doc>
          <type name="ChannelDispatchOperation" c:type="TpChannelDispatchOperation*"/>
        </parameter>
        <parameter name="requests" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GList of #TpChannelRequest having their object-path defined but are not guaranteed to be prepared.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="TelepathyGLib.ChannelRequest"/>
          </type>
        </parameter>
        <parameter name="context" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpObserveChannelsContext representing the context of this D-Bus call</doc>
          <type name="ObserveChannelsContext" c:type="TpObserveChannelsContext*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="BaseClientClassPrivate" c:type="TpBaseClientClassPrivate">
    </record>
    <record name="BaseClientPrivate" c:type="TpBaseClientPrivate">
    </record>
    <class name="BaseConnection" c:type="TpBaseConnection" parent="GObject.Object" abstract="1" glib:type-name="TpBaseConnection" glib:get-type="tp_base_connection_get_type" glib:type-struct="BaseConnectionClass">
      <doc xml:whitespace="preserve">Data structure representing a generic #TpSvcConnection implementation.
In addition to the fields documented here, there are four gpointer fields
which must currently be %NULL (a meaning may be defined for these in a
future version of telepathy-glib), and a pointer to opaque private data.</doc>
      <function name="dbus_request_handles" c:identifier="tp_base_connection_dbus_request_handles" introspectable="0">
        <doc xml:whitespace="preserve">Implements D-Bus method RequestHandles on interface
org.freedesktop.Telepathy.Connection. Exported so subclasses can
use it as a basis for their own implementations (for instance,
at the time of writing Gabble's GabbleConnection does its own processing
for room handles, in order to validate them asynchronously, but delegates
to this implementation for all other types).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="iface" transfer-ownership="none">
            <doc xml:whitespace="preserve">A pointer to #TpBaseConnection, cast to a pointer to #TpSvcConnection</doc>
            <type name="TpSvcConnection" c:type="TpSvcConnection*"/>
          </parameter>
          <parameter name="handle_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">The handle type (#TpHandleType) as a guint</doc>
            <type name="uint" c:type="guint"/>
          </parameter>
          <parameter name="names" transfer-ownership="none">
            <doc xml:whitespace="preserve">A strv of handle names</doc>
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="context" transfer-ownership="none">
            <doc xml:whitespace="preserve">The dbus-glib method invocation context</doc>
            <type name="DBusGMethodInvocation" c:type="DBusGMethodInvocation*"/>
          </parameter>
        </parameters>
      </function>
      <function name="channel_manager_iter_init" c:identifier="tp_base_connection_channel_manager_iter_init" version="0.7.15" introspectable="0">
        <doc xml:whitespace="preserve">Initializes an iterator over the #TpChannelManager objects known to
&lt;informalexample&gt;&lt;programlisting&gt;
TpChannelManagerIter iter;
TpChannelManager *manager;
tp_base_connection_channel_manager_iter_init (&amp;amp;iter, base_conn);
while (tp_base_connection_channel_manager_iter_next (&amp;amp;iter, &amp;amp;manager))
{
...do something with manager...
}
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:whitespace="preserve">an uninitialized #TpChannelManagerIter</doc>
            <type name="ChannelManagerIter" c:type="TpChannelManagerIter*"/>
          </parameter>
          <parameter name="self" transfer-ownership="none">
            <doc xml:whitespace="preserve">a connection</doc>
            <type name="BaseConnection" c:type="TpBaseConnection*"/>
          </parameter>
        </parameters>
      </function>
      <function name="channel_manager_iter_next" c:identifier="tp_base_connection_channel_manager_iter_next" version="0.7.15" introspectable="0">
        <doc xml:whitespace="preserve">Advances @iter, and retrieves the #TpChannelManager it now points to.  If
there are no more channel managers, @manager_out is not set and %FALSE is
returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%FALSE if there are no more channel managers; else %TRUE.</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:whitespace="preserve">an initialized #TpChannelManagerIter</doc>
            <type name="ChannelManagerIter" c:type="TpChannelManagerIter*"/>
          </parameter>
          <parameter name="manager_out" transfer-ownership="none">
            <doc xml:whitespace="preserve">a location to store the channel manager, or %NULL.</doc>
            <type name="TpChannelManager" c:type="TpChannelManager**"/>
          </parameter>
        </parameters>
      </function>
      <method name="get_handles" c:identifier="tp_base_connection_get_handles">
        <doc xml:whitespace="preserve">&lt;!----&gt;
handle type, or #NULL if it's unsupported or invalid.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the handle repository corresponding to the given</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </return-value>
        <parameters>
          <parameter name="handle_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">The handle type</doc>
            <type name="HandleType" c:type="TpHandleType"/>
          </parameter>
        </parameters>
      </method>
      <method name="register" c:identifier="tp_base_connection_register" throws="1">
        <doc xml:whitespace="preserve">Make the connection object appear on the bus, returning the bus
name and object path used. If %TRUE is returned, the connection owns the
bus name, and will release it when destroyed.
Since 0.11.11, @bus_name and @object_path may be %NULL if the
strings are not needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="cm_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">The name of the connection manager in the Telepathy protocol</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="bus_name" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:whitespace="preserve">Used to return the bus name corresponding to the connection if %TRUE is returned. To be freed by the caller.</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="object_path" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:whitespace="preserve">Used to return the object path of the connection if %TRUE is returned. To be freed by the caller.</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="disconnect_with_dbus_error" c:identifier="tp_base_connection_disconnect_with_dbus_error" version="0.7.24" introspectable="0">
        <doc xml:whitespace="preserve">Change the status of the connection to %TP_CONNECTION_STATUS_DISCONNECTED,
as if by a call to tp_base_connection_change_status(). Before doing so,
emit the ConnectionError D-Bus signal to give more details of the error.
"debug-message", whose value should have type G_TYPE_STRING.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="error_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">The D-Bus error with which the connection changed status to Disconnected</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="details" transfer-ownership="none">
            <doc xml:whitespace="preserve">Further details of the error, as a hash table where the keys are strings as defined in the Telepathy specification, and the values are GValues. %NULL is allowed, and treated as empty.</doc>
            <type name="GLib.HashTable" c:type="GHashTable*"/>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:whitespace="preserve">The reason code to use in the StatusChanged signal (a less specific, non-extensible version of @error_name)</doc>
            <type name="ConnectionStatusReason" c:type="TpConnectionStatusReason"/>
          </parameter>
        </parameters>
      </method>
      <method name="change_status" c:identifier="tp_base_connection_change_status">
        <doc xml:whitespace="preserve">Change the status of the connection. The allowed state transitions are:
&lt;itemizedlist&gt;
&lt;listitem&gt;NEW -&gt; CONNECTING&lt;/listitem&gt;
&lt;listitem&gt;CONNECTING -&gt; CONNECTED&lt;/listitem&gt;
&lt;listitem&gt;NEW -&gt; CONNECTED (equivalent to both of the above one after the
other - see below)&lt;/listitem&gt;
&lt;listitem&gt;(anything except DISCONNECTED) -&gt; DISCONNECTED&lt;/listitem&gt;
&lt;/itemizedlist&gt;
Before the transition to CONNECTED, the implementation must have discovered
the handle for the local user, obtained a reference to that handle and
stored it in the @self_handle member of #TpBaseConnection.
Changing from NEW to CONNECTED is implemented by doing the transition from
NEW to CONNECTING, followed by the transition from CONNECTING to CONNECTED;
it's exactly equivalent to calling tp_base_connection_change_status for
those two transitions one after the other.
Any other valid transition does the following, in this order:
&lt;itemizedlist&gt;
&lt;listitem&gt;Update the @status member of #TpBaseConnection&lt;/listitem&gt;
&lt;listitem&gt;If the new state is DISCONNECTED, call the close_all_channels
callback on all channel factories&lt;/listitem&gt;
&lt;listitem&gt;Emit the D-Bus StatusChanged signal&lt;/listitem&gt;
&lt;listitem&gt;Call the subclass' status change callback&lt;/listitem&gt;
&lt;listitem&gt;Call the channel factories' status change callbacks&lt;/listitem&gt;
&lt;listitem&gt;If the new state is DISCONNECTED, call the subclass'
&lt;/itemizedlist&gt;
previously set to 0 at this stage. It now remains non-zero until the object
is disposed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="status" transfer-ownership="none">
            <doc xml:whitespace="preserve">The new status</doc>
            <type name="ConnectionStatus" c:type="TpConnectionStatus"/>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:whitespace="preserve">The reason for the status change</doc>
            <type name="ConnectionStatusReason" c:type="TpConnectionStatusReason"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_self_handle" c:identifier="tp_base_connection_get_self_handle" version="0.7.15" introspectable="0">
        <doc xml:whitespace="preserve">Returns the #TpBaseConnection:self-handle property, which is guaranteed not
to be 0 once the connection has moved to the CONNECTED state.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the current self handle of the connection.</doc>
          <type name="Handle" c:type="TpHandle"/>
        </return-value>
      </method>
      <method name="set_self_handle" c:identifier="tp_base_connection_set_self_handle" version="0.7.15">
        <doc xml:whitespace="preserve">Sets the #TpBaseConnection:self-handle property.  self_handle may not be 0
once the connection has moved to the CONNECTED state.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="self_handle" transfer-ownership="none">
            <doc xml:whitespace="preserve">The new self handle for the connection.</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </method>
      <method name="finish_shutdown" c:identifier="tp_base_connection_finish_shutdown" introspectable="0">
        <doc xml:whitespace="preserve">Tell the connection manager that this Connection has been disconnected,
has emitted StatusChanged and is ready to be removed from D-Bus.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="add_interfaces" c:identifier="tp_base_connection_add_interfaces" introspectable="0">
        <doc xml:whitespace="preserve">Add some interfaces to the list supported by this Connection. If you're
going to call this function at all, you must do so before moving to state
CONNECTED (or DISCONNECTED); if you don't call it, only the set of
interfaces always present (@interfaces_always_present in
#TpBaseConnectionClass) will be supported.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="interfaces" transfer-ownership="none">
            <doc xml:whitespace="preserve">A %NULL-terminated array of D-Bus interface names, which must remain valid at least until the connection enters state #TP_CONNECTION_STATUS_DISCONNECTED (in practice, you should either use static strings, or use strdup'd strings and free them in the dispose callback).</doc>
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="register_with_contacts_mixin" c:identifier="tp_base_connection_register_with_contacts_mixin" introspectable="0">
        <doc xml:whitespace="preserve">Register the Connection interface with the Contacts interface to make it
inspectable. The Contacts mixin should be initialized before this function
is called</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get_dbus_daemon" c:identifier="tp_base_connection_get_dbus_daemon" version="0.11.3" introspectable="0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;
#TpBaseConnectionManager:dbus-daemon property. The caller must reference
the returned object with g_object_ref() if it will be kept.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of the</doc>
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </return-value>
      </method>
      <property name="dbus-daemon" version="0.11.3" introspectable="0" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">#TpDBusDaemon object encapsulating this object's connection to D-Bus.
Read-only except during construction.
If this property is %NULL or omitted during construction, the object will
automatically attempt to connect to the starter or session bus with
tp_dbus_daemon_dup() just after it is constructed; if this fails, this
property will remain %NULL, and tp_base_connection_register() will fail.</doc>
        <type name="DBusDaemon" c:type="TpDBusDaemon"/>
      </property>
      <property name="dbus-status" version="0.11.3" introspectable="0" transfer-ownership="none">
        <doc xml:whitespace="preserve">The Connection.Status as visible on D-Bus, which is the same as
#TpBaseConnection.status except that %TP_INTERNAL_CONNECTION_STATUS_NEW
is replaced by %TP_CONNECTION_STATUS_DISCONNECTED.
The #GObject::notify signal is not currently emitted for this property.</doc>
        <type name="uint" c:type="guint"/>
      </property>
      <property name="interfaces" version="0.11.3" introspectable="0" transfer-ownership="none">
        <doc xml:whitespace="preserve">The set of D-Bus interfaces available on this Connection, other than
Connection itself.</doc>
        <type name="GObject.Strv" c:type="GStrv"/>
      </property>
      <property name="protocol" introspectable="0" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">Identifier used in the Telepathy protocol when this connection's protocol
name is required.</doc>
        <type name="utf8" c:type="gchararray"/>
      </property>
      <property name="self-handle" version="0.7.15" introspectable="0" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The handle of type %TP_HANDLE_TYPE_CONTACT representing the local user.
Must be set nonzero by the subclass before moving to state CONNECTED.</doc>
        <type name="uint" c:type="guint"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="bus_name">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="object_path">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="status">
        <type name="ConnectionStatus" c:type="TpConnectionStatus"/>
      </field>
      <field name="self_handle">
        <type name="Handle" c:type="TpHandle"/>
      </field>
      <field name="_future1">
        <type name="any" c:type="gpointer"/>
      </field>
      <field name="_future2">
        <type name="any" c:type="gpointer"/>
      </field>
      <field name="_future3">
        <type name="any" c:type="gpointer"/>
      </field>
      <field name="_future4">
        <type name="any" c:type="gpointer"/>
      </field>
      <field name="priv">
        <type name="BaseConnectionPrivate" c:type="TpBaseConnectionPrivate*"/>
      </field>
      <glib:signal name="shutdown-finished" introspectable="0">
        <doc xml:whitespace="preserve">Emitted by tp_base_connection_finish_shutdown() when the underlying
network connection has been closed; #TpBaseConnectionManager listens
for this signal and removes connections from its table of active
connections when it is received.</doc>
        <return-value transfer-ownership="full">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="BaseConnectionClass" c:type="TpBaseConnectionClass" glib:is-gtype-struct-for="BaseConnection">
      <doc xml:whitespace="preserve">The class of a #TpBaseConnection. Many members are virtual methods etc.
to be filled in in the subclass' class_init function.
In addition to the fields documented here, there are three gpointer fields
which must currently be %NULL (a meaning may be defined for these in a
future version of telepathy-glib), and a pointer to opaque private data.</doc>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="_internal_create_handle_repos">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="create_channel_factories">
        <type name="BaseConnectionCreateChannelFactoriesImpl" c:type="TpBaseConnectionCreateChannelFactoriesImpl"/>
      </field>
      <field name="get_unique_connection_name">
        <type name="BaseConnectionGetUniqueConnectionNameImpl" c:type="TpBaseConnectionGetUniqueConnectionNameImpl"/>
      </field>
      <field name="connecting">
        <type name="BaseConnectionProc" c:type="TpBaseConnectionProc"/>
      </field>
      <field name="connected">
        <type name="BaseConnectionProc" c:type="TpBaseConnectionProc"/>
      </field>
      <field name="disconnected">
        <type name="BaseConnectionProc" c:type="TpBaseConnectionProc"/>
      </field>
      <field name="shut_down">
        <type name="BaseConnectionProc" c:type="TpBaseConnectionProc"/>
      </field>
      <field name="start_connecting">
        <type name="BaseConnectionStartConnectingImpl" c:type="TpBaseConnectionStartConnectingImpl"/>
      </field>
      <field name="interfaces_always_present">
        <type name="utf8" c:type="gchar**"/>
      </field>
      <field name="create_channel_managers">
        <type name="BaseConnectionCreateChannelManagersImpl" c:type="TpBaseConnectionCreateChannelManagersImpl"/>
      </field>
      <field name="_future2">
        <type name="any" c:type="gpointer"/>
      </field>
      <field name="_future3">
        <type name="any" c:type="gpointer"/>
      </field>
      <field name="_future4">
        <type name="any" c:type="gpointer"/>
      </field>
      <field name="priv">
        <type name="any" c:type="gpointer"/>
      </field>
    </record>
    <callback name="BaseConnectionCreateChannelFactoriesImpl" c:type="TpBaseConnectionCreateChannelFactoriesImpl">
      <doc xml:whitespace="preserve">Signature of an implementation of the create_channel_factories method
of #TpBaseConnection.
which, between them, implement all channel types this Connection
supports.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a GPtrArray of objects implementing #TpChannelFactoryIface</doc>
        <array name="GLib.PtrArray" c:type="GPtrArray*">
          <type name="any" c:type="gpointer"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">The implementation, a subclass of TpBaseConnection</doc>
          <type name="BaseConnection" c:type="TpBaseConnection*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="BaseConnectionCreateChannelManagersImpl" c:type="TpBaseConnectionCreateChannelManagersImpl">
      <doc xml:whitespace="preserve">Signature of an implementation of the create_channel_managers method
of #TpBaseConnection.
which, between them, implement all channel types this Connection
supports.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a GPtrArray of objects implementing #TpChannelManager</doc>
        <array name="GLib.PtrArray" c:type="GPtrArray*">
          <type name="any" c:type="gpointer"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">The implementation, a subclass of TpBaseConnection</doc>
          <type name="BaseConnection" c:type="TpBaseConnection*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="BaseConnectionCreateHandleReposImpl" c:type="TpBaseConnectionCreateHandleReposImpl" introspectable="0">
      <doc xml:whitespace="preserve">Signature of an implementation of the create_handle_repos method
of #TpBaseConnection.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">The connection object</doc>
          <type name="BaseConnection" c:type="TpBaseConnection*"/>
        </parameter>
        <parameter name="repos" transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of pointers to be filled in; the implementation may assume all are initially NULL.</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="BaseConnectionGetUniqueConnectionNameImpl" c:type="TpBaseConnectionGetUniqueConnectionNameImpl">
      <doc xml:whitespace="preserve">Signature of the @get_unique_connection_name virtual method
on #TpBaseConnection.
connection manager process, as a string which the caller must free
with #g_free.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a name for this connection which will be unique within this</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">The implementation, a subclass of TpBaseConnection</doc>
          <type name="BaseConnection" c:type="TpBaseConnection*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="BaseConnectionPrivate" c:type="TpBaseConnectionPrivate">
    </record>
    <callback name="BaseConnectionProc" c:type="TpBaseConnectionProc">
      <doc xml:whitespace="preserve">Signature of a virtual method on #TpBaseConnection that takes no
additional parameters and returns nothing.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">The connection object</doc>
          <type name="BaseConnection" c:type="TpBaseConnection*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="BaseConnectionStartConnectingImpl" c:type="TpBaseConnectionStartConnectingImpl" throws="1">
      <doc xml:whitespace="preserve">Signature of an implementation of the start_connecting method
of #TpBaseConnection.
On entry, the implementation may assume that it is in state NEW.
If %TRUE is returned, the Connect D-Bus method succeeds; the
implementation must either have already set the status to CONNECTED by
calling tp_base_connection_change_status(), or have arranged for a
status change to either state DISCONNECTED or CONNECTED to be signalled by
calling tp_base_connection_change_status() at some later time.
If the status is still NEW after returning %TRUE, #TpBaseConnection will
automatically change it to CONNECTING for reason REQUESTED.
If %FALSE is returned, the error will be raised from Connect as an
exception. If the status is not DISCONNECTED after %FALSE is returned,
#TpBaseConnection will automatically change it to DISCONNECTED
with a reason appropriate to the error; NetworkError results in
NETWORK_ERROR, PermissionDenied results in AUTHENTICATION_FAILED, and all
other errors currently result in NONE_SPECIFIED.
All except the simplest connection managers are expected to implement this
asynchronously, returning %TRUE in most cases and changing the status
to CONNECTED or DISCONNECTED later.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%FALSE if failure has already occurred, else %TRUE.</doc>
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">The connection object</doc>
          <type name="BaseConnection" c:type="TpBaseConnection*"/>
        </parameter>
      </parameters>
    </callback>
    <constant name="CHANNEL_DISPATCHER_BUS_NAME" value="org.freedesktop.Telepathy.ChannelDispatcher">
      <type name="utf8"/>
    </constant>
    <constant name="CHANNEL_DISPATCHER_OBJECT_PATH" value="/org/freedesktop/Telepathy/ChannelDispatcher">
      <type name="utf8"/>
    </constant>
    <constant name="CLIENT_BUS_NAME_BASE" value="org.freedesktop.Telepathy.Client.">
      <type name="utf8"/>
    </constant>
    <constant name="CLIENT_OBJECT_PATH_BASE" value="/org/freedesktop/Telepathy/Client/">
      <type name="utf8"/>
    </constant>
    <enumeration name="CMInfoSource" version="0.7.1" c:type="TpCMInfoSource">
      <doc xml:whitespace="preserve">Describes possible sources of information on connection managers'
supported protocols.
Since 0.11.5, there is a corresponding #GEnumClass type,
%TP_TYPE_CM_INFO_SOURCE.</doc>
      <member name="none" value="0" c:identifier="TP_CM_INFO_SOURCE_NONE"/>
      <member name="file" value="1" c:identifier="TP_CM_INFO_SOURCE_FILE"/>
      <member name="live" value="2" c:identifier="TP_CM_INFO_SOURCE_LIVE"/>
    </enumeration>
    <constant name="CM_BUS_NAME_BASE" value="org.freedesktop.Telepathy.ConnectionManager.">
      <type name="utf8"/>
    </constant>
    <constant name="CM_OBJECT_PATH_BASE" value="/org/freedesktop/Telepathy/ConnectionManager/">
      <type name="utf8"/>
    </constant>
    <constant name="CONN_BUS_NAME_BASE" value="org.freedesktop.Telepathy.Connection.">
      <type name="utf8"/>
    </constant>
    <constant name="CONN_OBJECT_PATH_BASE" value="/org/freedesktop/Telepathy/Connection/">
      <type name="utf8"/>
    </constant>
    <class name="Capabilities" c:type="TpCapabilities" version="0.11.3" parent="GObject.Object" glib:type-name="TpCapabilities" glib:get-type="tp_capabilities_get_type" glib:type-struct="CapabilitiesClass">
      <doc xml:whitespace="preserve">An object representing capabilities a #TpConnection or #TpContact supports.</doc>
      <method name="get_channel_classes" c:identifier="tp_capabilities_get_channel_classes" version="0.11.3">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;
#TpCapabilities:channel-classes property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same #GPtrArray as the</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="any" c:type="gpointer"/>
          </array>
        </return-value>
      </method>
      <method name="is_specific_to_contact" c:identifier="tp_capabilities_is_specific_to_contact" version="0.11.3">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same #gboolean as the #TpCapabilities:contact-specific property</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="supports_text_chats" c:identifier="tp_capabilities_supports_text_chats" version="0.11.3">
        <doc xml:whitespace="preserve">Return whether private text channels can be established by providing
a contact identifier.
If the protocol is such that text chats can be established, but only via a
more elaborate D-Bus API than normal (because more information is needed),
then this method will return %FALSE.
HandleTypeContact as TargetHandleType and a contact identifier can be
expected to work, %FALSE otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if a channel request containing Text as ChannelType,</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="supports_text_chatrooms" c:identifier="tp_capabilities_supports_text_chatrooms" version="0.11.3">
        <doc xml:whitespace="preserve">If the #TpCapabilities:contact-specific property is %FALSE, this function
checks if named text chatrooms can be joined by providing a chatroom
identifier.
If the #TpCapabilities:contact-specific property is %TRUE, this function
checks if the contact associated with this #TpCapabilities can be invited
to named text chatrooms.
If the protocol is such that chatrooms can be joined or contacts can be
invited, but only via a more elaborate D-Bus API than normal
(because more information is needed), then this method will return %FALSE.
HandleTypeRoom as TargetHandleType and a channel identifier can be
expected to work, %FALSE otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if a channel request containing Text as ChannelType,</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
      </method>
      <property name="contact-specific" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether this object accurately describes the capabilities of a particular
contact, or if it's only a guess based on the capabilities of the
underlying connection.</doc>
        <type name="boolean" c:type="gboolean"/>
      </property>
    </class>
    <record name="CapabilitiesClass" c:type="TpCapabilitiesClass" glib:is-gtype-struct-for="Capabilities">
    </record>
    <record name="CapabilitiesPrivate" c:type="TpCapabilitiesPrivate">
    </record>
    <class name="Channel" c:type="TpChannel" version="0.7.1" parent="Proxy" glib:type-name="TpChannel" glib:get-type="tp_channel_get_type" glib:type-struct="ChannelClass">
      <doc xml:whitespace="preserve">A proxy object for a Telepathy channel.
A proxy object for a Telepathy channel. There are no interesting
public struct fields.
(Changed in 0.7.12: the layout of the structure is visible, allowing
subclassing.)</doc>
      <constructor name="new" c:identifier="tp_channel_new" version="0.7.1" throws="1">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new channel proxy, or %NULL on invalid arguments.</doc>
          <type name="Channel" c:type="TpChannel*"/>
        </return-value>
        <parameters>
          <parameter name="conn" transfer-ownership="none">
            <doc xml:whitespace="preserve">a connection; may not be %NULL</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object path of the channel; may not be %NULL</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="optional_channel_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the channel type if already known, or %NULL if not</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="optional_handle_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the handle type if already known, or %TP_UNKNOWN_HANDLE_TYPE if not</doc>
            <type name="HandleType" c:type="TpHandleType"/>
          </parameter>
          <parameter name="optional_handle" transfer-ownership="none">
            <doc xml:whitespace="preserve">the handle if already known, or 0 if not (if @optional_handle_type is %TP_UNKNOWN_HANDLE_TYPE or %TP_HANDLE_TYPE_NONE, this must be 0)</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_properties" c:identifier="tp_channel_new_from_properties" version="0.7.19" throws="1">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new channel proxy, or %NULL on invalid arguments</doc>
          <type name="Channel" c:type="TpChannel*"/>
        </return-value>
        <parameters>
          <parameter name="conn" transfer-ownership="none">
            <doc xml:whitespace="preserve">a connection; may not be %NULL</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object path of the channel; may not be %NULL</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <doc xml:whitespace="preserve">the immutable properties of the channel, as signalled by the NewChannel D-Bus signal or returned by the CreateChannel and EnsureChannel D-Bus methods: a mapping from strings (D-Bus interface name + "." + property name) to #GValue instances</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </constructor>
      <function name="init_known_interfaces" c:identifier="tp_channel_init_known_interfaces" version="0.7.6">
        <doc xml:whitespace="preserve">Ensure that the known interfaces for TpChannel have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_CHANNEL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <function name="get_feature_quark_core" c:identifier="tp_channel_get_feature_quark_core">
        <return-value transfer-ownership="full">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_group" c:identifier="tp_channel_get_feature_quark_group">
        <return-value transfer-ownership="full">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_chat_states" c:identifier="tp_channel_get_feature_quark_chat_states">
        <return-value transfer-ownership="full">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <method name="run_until_ready" c:identifier="tp_channel_run_until_ready" version="0.7.1" introspectable="0" deprecated="Use tp_connection_call_when_ready," deprecated-version="0.11.0">
        <doc xml:whitespace="preserve">If @self is ready for use (introspection has finished, etc.), return
immediately. Otherwise, re-enter the main loop until the channel either
becomes invalid or becomes ready for use, or until the main loop stored
via @loop is cancelled.
%FALSE if the channel has become invalid.
or restructure your program in such a way as to avoid re-entering the
main loop.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the channel has been introspected and is ready for use,</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="error" transfer-ownership="none">
            <doc xml:whitespace="preserve">if not %NULL and %FALSE is returned, used to raise an error</doc>
            <type name="GLib.Error" c:type="GError**"/>
          </parameter>
          <parameter name="loop" transfer-ownership="none">
            <doc xml:whitespace="preserve">if not %NULL, a #GMainLoop is placed here while it is being run (so calling code can call g_main_loop_quit() to abort), and %NULL is placed here after the loop has been run</doc>
            <type name="GLib.MainLoop" c:type="GMainLoop**"/>
          </parameter>
        </parameters>
      </method>
      <method name="call_when_ready" c:identifier="tp_channel_call_when_ready" version="0.7.7" introspectable="0">
        <doc xml:whitespace="preserve">If @self is ready for use or has been invalidated, call @callback
immediately, then return. Otherwise, arrange
for @callback to be called when @self either becomes ready for use
or becomes invalid.
This is a less general form of tp_proxy_prepare_async(), which should be
used in new code. (One important difference is that this function can call
calls @callback from the main loop.)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback" transfer-ownership="none" scope="call" closure="2">
            <doc xml:whitespace="preserve">called when the channel becomes ready or invalidated, whichever happens first</doc>
            <type name="ChannelWhenReadyCb" c:type="TpChannelWhenReadyCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data passed to the callback</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_ready" c:identifier="tp_channel_is_ready" version="0.7.12" introspectable="0">
        <doc xml:whitespace="preserve">Returns the same thing as the #TpChannel:channel-ready property.
New code should use tp_proxy_is_prepared(), which is a more general form of
this method.
For group channels, this method is equivalent to checking for the
combination of %TP_CHANNEL_FEATURE_CORE and %TP_CHANNEL_FEATURE_GROUP; for
non-group channels, it's equivalent to checking for
%TP_CHANNEL_FEATURE_CORE.
One important difference is that after #TpProxy::invalidated is
signalled, #TpChannel:channel-ready keeps its current value - which might
be %TRUE, if the channel was successfully prepared before it became
invalidated - but tp_proxy_is_prepared() returns %FALSE for all features.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if introspection has completed</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_channel_type" c:identifier="tp_channel_get_channel_type" version="0.7.12">
        <doc xml:whitespace="preserve">Get the D-Bus interface name representing this channel's type,
if it has been discovered.
This is the same as the #TpChannelIface:channel-type property; it isn't
guaranteed to be non-%NULL until the %TP_CHANNEL_FEATURE_CORE feature has
been prepared.
type or %NULL, if the channel is not yet ready.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the channel type, if the channel is ready; either the channel</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_channel_type_id" c:identifier="tp_channel_get_channel_type_id" version="0.7.12">
        <doc xml:whitespace="preserve">Get the D-Bus interface name representing this channel's type, as a GQuark,
if it has been discovered.
This is the same as the #TpChannelIface:channel-type property, except that it
is a GQuark rather than a string. It isn't guaranteed to be nonzero until
the %TP_CHANNEL_FEATURE_CORE property is ready.
type or 0, if the channel is not yet ready.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the channel type, if the channel is ready; either the channel</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </method>
      <method name="get_handle" c:identifier="tp_channel_get_handle" version="0.7.12">
        <doc xml:whitespace="preserve">Get the handle representing the contact, chatroom, etc. with which this
channel communicates for its whole lifetime, or 0 if there is no such
handle or it has not yet been discovered.
This is the same as the #TpChannelIface:handle property. It isn't
guaranteed to have its final value until the %TP_CHANNEL_FEATURE_CORE
feature is ready.
If %handle_type is not %NULL, the type of handle is written into it.
This will be %TP_UNKNOWN_HANDLE_TYPE if the handle has not yet been
discovered, or %TP_HANDLE_TYPE_NONE if there is no handle with which this
channel will always communicate. This is the same as the
#TpChannelIface:handle-type property.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the handle</doc>
          <type name="Handle" c:type="TpHandle"/>
        </return-value>
        <parameters>
          <parameter name="handle_type" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:whitespace="preserve">if not %NULL, used to return the type of this handle</doc>
            <type name="HandleType" c:type="TpHandleType*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_identifier" c:identifier="tp_channel_get_identifier" version="0.7.21">
        <doc xml:whitespace="preserve">This channel's associated identifier, or the empty string if no identifier
or unknown.
This is the same as the #TpChannel:identifier property, and isn't guaranteed
to be set until the %TP_CHANNEL_FEATURE_CORE property is ready.
previously either be %NULL or the empty string if there was no suitable
value. It is now non-%NULL in all cases.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the identifier</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="borrow_connection" c:identifier="tp_channel_borrow_connection" version="0.7.12">
        <doc xml:whitespace="preserve">Returns the connection for this channel. The returned pointer is only valid
while this channel is valid - reference it with g_object_ref() if needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">connection</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </return-value>
      </method>
      <method name="borrow_immutable_properties" c:identifier="tp_channel_borrow_immutable_properties">
        <doc xml:whitespace="preserve">Returns the immutable D-Bus properties of this channel, the same as
#TpChannel:channel-properties.
The returned hash table should not be altered, and is not necessarily
valid after the main loop is next re-entered. Copy it with
g_boxed_copy() (its type is %TP_HASH_TYPE_QUALIFIED_PROPERTY_VALUE_MAP)
if a copy that remains valid must be kept.
If the #TpChannel:channel-properties property was not set during
construction (e.g. by calling tp_channel_new_from_properties()), a
reasonable but possibly incomplete version will be made up from the values
of individual properties; reading this property repeatedly may yield
progressively more complete values until the %TP_CHANNEL_FEATURE_CORE
feature is prepared.
where the keys are strings,
D-Bus interface name + "." + property name, and the values are #GValue
instances</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </return-value>
      </method>
      <method name="group_get_self_handle" c:identifier="tp_channel_group_get_self_handle">
        <return-value transfer-ownership="full">
          <type name="Handle" c:type="TpHandle"/>
        </return-value>
      </method>
      <method name="group_get_flags" c:identifier="tp_channel_group_get_flags">
        <return-value transfer-ownership="full">
          <type name="ChannelGroupFlags" c:type="TpChannelGroupFlags"/>
        </return-value>
      </method>
      <method name="group_get_members" c:identifier="tp_channel_group_get_members">
        <return-value transfer-ownership="none">
          <type name="IntSet" c:type="TpIntSet*"/>
        </return-value>
      </method>
      <method name="group_get_local_pending" c:identifier="tp_channel_group_get_local_pending">
        <return-value transfer-ownership="none">
          <type name="IntSet" c:type="TpIntSet*"/>
        </return-value>
      </method>
      <method name="group_get_remote_pending" c:identifier="tp_channel_group_get_remote_pending">
        <return-value transfer-ownership="none">
          <type name="IntSet" c:type="TpIntSet*"/>
        </return-value>
      </method>
      <method name="group_get_local_pending_info" c:identifier="tp_channel_group_get_local_pending_info">
        <return-value transfer-ownership="none">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="local_pending" transfer-ownership="none">
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
          <parameter name="actor" transfer-ownership="none">
            <type name="Handle" c:type="TpHandle*"/>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <type name="ChannelGroupChangeReason" c:type="TpChannelGroupChangeReason*"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="group_get_handle_owner" c:identifier="tp_channel_group_get_handle_owner">
        <return-value transfer-ownership="full">
          <type name="Handle" c:type="TpHandle"/>
        </return-value>
        <parameters>
          <parameter name="handle" transfer-ownership="none">
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_chat_state" c:identifier="tp_channel_get_chat_state" version="0.11.3">
        <doc xml:whitespace="preserve">Return the chat state for the given contact. If tp_proxy_is_prepared()
would return %FALSE for the feature %TP_CHANNEL_FEATURE_CHAT_STATES,
the result will always be %TP_CHANNEL_CHAT_STATE_INACTIVE.
if their chat state is not known</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the chat state for @contact, or %TP_CHANNEL_CHAT_STATE_INACTIVE</doc>
          <type name="ChannelChatState" c:type="TpChannelChatState"/>
        </return-value>
        <parameters>
          <parameter name="contact" transfer-ownership="none">
            <doc xml:whitespace="preserve">a contact handle</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </method>
      <property name="channel-ready" transfer-ownership="none">
        <doc xml:whitespace="preserve">Initially %FALSE; changes to %TRUE when tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_FEATURE_CORE, and if the channel is a
group, %TP_CHANNEL_FEATURE_GROUP.
This is a less general form of tp_proxy_is_prepared(), which should be
used in new code.
One important difference is that after #TpProxy::invalidated is
signalled, #TpChannel:channel-ready keeps its current value - which might
be %TRUE, if the channel was successfully prepared before it became
invalidated - but tp_proxy_is_prepared() returns %FALSE for all features.
Change notification is via notify::channel-ready.</doc>
        <type name="boolean" c:type="gboolean"/>
      </property>
      <property name="connection" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The #TpConnection to which this #TpChannel belongs. Used for e.g.
handle manipulation.</doc>
        <type name="Connection" c:type="TpConnection"/>
      </property>
      <property name="group-flags" version="0.7.12" transfer-ownership="none">
        <doc xml:whitespace="preserve">If the %TP_CHANNEL_FEATURE_GROUP feature has been prepared successfully,
#TpChannelGroupFlags indicating the capabilities and behaviour of that
group.
Otherwise, this may be 0.
Change notification is via notify::group-flags or
TpChannel::group-flags-changed.</doc>
        <type name="uint" c:type="guint"/>
      </property>
      <property name="group-self-handle" version="0.7.12" transfer-ownership="none">
        <doc xml:whitespace="preserve">If this channel is a group and %TP_CHANNEL_FEATURE_GROUP has been
prepared, and the user is a member of the group, the #TpHandle
representing them in this group.
Otherwise, the result may be either a handle representing the user, or 0.
Change notification is via notify::group-self-handle.</doc>
        <type name="uint" c:type="guint"/>
      </property>
      <property name="identifier" transfer-ownership="none">
        <doc xml:whitespace="preserve">This channel's associated identifier, or the empty string if it has
handle type %TP_HANDLE_TYPE_NONE.
For channels where #TpChannelIface:handle is non-zero, this is the result
of inspecting #TpChannelIface:handle.
This is not guaranteed to be set until tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_FEATURE_CORE; until then, it may be
the empty string.
it was %NULL before an identifier was known, or when a channel
with no TargetID D-Bus property had TargetHandleType %TP_HANDLE_TYPE_NONE.</doc>
        <type name="utf8" c:type="gchararray"/>
      </property>
      <field name="parent">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="priv">
        <type name="ChannelPrivate" c:type="TpChannelPrivate*"/>
      </field>
      <glib:signal name="chat-state-changed" version="0.11.3">
        <doc xml:whitespace="preserve">Emitted when a contact's chat state changes after tp_proxy_prepare_async()
has finished preparing the feature %TP_CHANNEL_FEATURE_CHAT_STATES.</doc>
        <return-value transfer-ownership="full">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="contact" transfer-ownership="none">
            <doc xml:whitespace="preserve">a contact handle for the local user or another contact</doc>
            <type name="uint" c:type="guint"/>
          </parameter>
          <parameter name="state" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new #TpChannelChatState for the contact</doc>
            <type name="uint" c:type="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="group-flags-changed" version="0.7.12">
        <doc xml:whitespace="preserve">Emitted when the #TpChannel:group-flags property changes while the
channel is ready.</doc>
        <return-value transfer-ownership="full">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="added" transfer-ownership="none">
            <doc xml:whitespace="preserve">#TpChannelGroupFlags which are newly set</doc>
            <type name="uint" c:type="guint"/>
          </parameter>
          <parameter name="removed" transfer-ownership="none">
            <doc xml:whitespace="preserve">#TpChannelGroupFlags which are no longer set</doc>
            <type name="uint" c:type="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="group-members-changed" version="0.7.12" introspectable="0">
        <doc xml:whitespace="preserve">Emitted when the group members change in a Group channel that is ready.</doc>
        <return-value transfer-ownership="full">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">an optional textual message</doc>
            <type name="utf8" c:type="gchararray"/>
          </parameter>
          <parameter name="added" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GArray of #guint containing the full members added</doc>
            <type name="GArray_guint_" c:type="GArray_guint_"/>
          </parameter>
          <parameter name="removed" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GArray of #guint containing the members (full, local-pending or remote-pending) removed</doc>
            <type name="GArray_guint_" c:type="GArray_guint_"/>
          </parameter>
          <parameter name="local_pending" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GArray of #guint containing the local-pending members added</doc>
            <type name="GArray_guint_" c:type="GArray_guint_"/>
          </parameter>
          <parameter name="remote_pending" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GArray of #guint containing the remote-pending members added</doc>
            <type name="GArray_guint_" c:type="GArray_guint_"/>
          </parameter>
          <parameter name="actor" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpHandle of the contact causing the change, or 0</doc>
            <type name="uint" c:type="guint"/>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:whitespace="preserve">the reason for the change as a #TpChannelGroupChangeReason</doc>
            <type name="uint" c:type="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="group-members-changed-detailed" version="0.7.21">
        <doc xml:whitespace="preserve">Emitted when the group members change in a Group channel that is ready.
Contains a superset of the information in the
TpChannel::group-members-changed signal, and is emitted at the same time;
applications can connect to this signal and ignore the other.</doc>
        <return-value transfer-ownership="full">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="added" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GArray of #guint containing the full members added</doc>
            <array name="GLib.Array" c:type="GArray_guint_">
              <type name="uint"/>
            </array>
          </parameter>
          <parameter name="removed" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GArray of #guint containing the members (full, local-pending or remote-pending) removed</doc>
            <array name="GLib.Array" c:type="GArray_guint_">
              <type name="uint"/>
            </array>
          </parameter>
          <parameter name="local_pending" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GArray of #guint containing the local-pending members added</doc>
            <array name="GLib.Array" c:type="GArray_guint_">
              <type name="uint"/>
            </array>
          </parameter>
          <parameter name="remote_pending" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GArray of #guint containing the remote-pending members added</doc>
            <array name="GLib.Array" c:type="GArray_guint_">
              <type name="uint"/>
            </array>
          </parameter>
          <parameter name="details" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GHashTable mapping (gchar *) to #GValue containing details about the change, as described in the specification of the MembersChangedDetailed signal.</doc>
            <type name="GLib.HashTable" c:type="GHashTable_gchararray+GValue_">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <enumeration name="ChannelCallStateFlags" c:type="TpChannelCallStateFlags">
      <member name="ringing" value="1" c:identifier="TP_CHANNEL_CALL_STATE_RINGING"/>
      <member name="queued" value="2" c:identifier="TP_CHANNEL_CALL_STATE_QUEUED"/>
      <member name="held" value="4" c:identifier="TP_CHANNEL_CALL_STATE_HELD"/>
      <member name="forwarded" value="8" c:identifier="TP_CHANNEL_CALL_STATE_FORWARDED"/>
      <member name="in_progress" value="16" c:identifier="TP_CHANNEL_CALL_STATE_IN_PROGRESS"/>
      <member name="conference_host" value="32" c:identifier="TP_CHANNEL_CALL_STATE_CONFERENCE_HOST"/>
    </enumeration>
    <enumeration name="ChannelChatState" c:type="TpChannelChatState">
      <member name="gone" value="0" c:identifier="TP_CHANNEL_CHAT_STATE_GONE"/>
      <member name="inactive" value="1" c:identifier="TP_CHANNEL_CHAT_STATE_INACTIVE"/>
      <member name="active" value="2" c:identifier="TP_CHANNEL_CHAT_STATE_ACTIVE"/>
      <member name="paused" value="3" c:identifier="TP_CHANNEL_CHAT_STATE_PAUSED"/>
      <member name="composing" value="4" c:identifier="TP_CHANNEL_CHAT_STATE_COMPOSING"/>
    </enumeration>
    <record name="ChannelClass" c:type="TpChannelClass" glib:is-gtype-struct-for="Channel" version="0.7.1">
      <doc xml:whitespace="preserve">The class of a #TpChannel. In addition to @parent_class there are four
pointers reserved for possible future use.
(Changed in 0.7.12: the layout of the structure is visible, allowing
subclassing.)</doc>
      <field name="parent_class">
        <type name="ProxyClass" c:type="TpProxyClass"/>
      </field>
      <field name="_1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_2">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_3">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_4">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
    </record>
    <enumeration name="ChannelContactSearchState" c:type="TpChannelContactSearchState">
      <member name="not_started" value="0" c:identifier="TP_CHANNEL_CONTACT_SEARCH_STATE_NOT_STARTED"/>
      <member name="in_progress" value="1" c:identifier="TP_CHANNEL_CONTACT_SEARCH_STATE_IN_PROGRESS"/>
      <member name="more_available" value="2" c:identifier="TP_CHANNEL_CONTACT_SEARCH_STATE_MORE_AVAILABLE"/>
      <member name="completed" value="3" c:identifier="TP_CHANNEL_CONTACT_SEARCH_STATE_COMPLETED"/>
      <member name="failed" value="4" c:identifier="TP_CHANNEL_CONTACT_SEARCH_STATE_FAILED"/>
    </enumeration>
    <class name="ChannelDispatchOperation" c:type="TpChannelDispatchOperation" version="0.7.32" parent="Proxy" glib:type-name="TpChannelDispatchOperation" glib:get-type="tp_channel_dispatch_operation_get_type" glib:type-struct="ChannelDispatchOperationClass">
      <doc xml:whitespace="preserve">One of the channel dispatcher's functions is to offer incoming channels to
Approver clients for approval. An approver should generally ask the user
whether they want to participate in the requested communication channels
(join the chat or chatroom, answer the call, accept the file transfer, or
whatever is appropriate). A collection of channels offered in this way
is represented by a ChannelDispatchOperation object.
If the user wishes to accept the communication channels, the approver
should call tp_cli_channel_dispatch_operation_call_handle_with() to
indicate the user's or approver's preferred handler for the channels (the
empty string indicates no particular preference, and will cause any
suitable handler to be used).
If the user wishes to reject the communication channels, or if the user
accepts the channels and the approver will handle them itself, the approver
should call tp_cli_channel_dispatch_operation_call_claim(). If this method
succeeds, the approver immediately has control over the channels as their
primary handler, and may do anything with them (in particular, it may close
them in whatever way seems most appropriate).
There are various situations in which the channel dispatch operation will
be closed, causing the #TpProxy::invalidated signal to be emitted. If this
happens, the approver should stop prompting the user.
Because all approvers are launched simultaneously, the user might respond
to another approver; if this happens, the #TpProxy::invalidated signal
will be emitted with the domain %TP_DBUS_ERRORS and the error code
%TP_DBUS_ERROR_OBJECT_REMOVED.
If a channel closes, the #TpChannelDispatchOperation::channel-lost signal
is emitted. If all channels
close, there is nothing more to dispatch, so the #TpProxy::invalidated
signal will be emitted with the domain %TP_DBUS_ERRORS and the error code
%TP_DBUS_ERROR_OBJECT_REMOVED.
If the channel dispatcher crashes or exits, the #TpProxy::invalidated
signal will be emitted with the domain %TP_DBUS_ERRORS and the error code
%TP_DBUS_ERROR_NAME_OWNER_LOST. In a high-quality implementation, the
dispatcher should be restarted, at which point it will create new
channel dispatch operations for any undispatched channels, and the approver
will be notified again.
be added in a later version of telepathy-glib, along with a mechanism
similar to tp_connection_call_when_ready().</doc>
      <constructor name="new" c:identifier="tp_channel_dispatch_operation_new" throws="1">
        <doc xml:whitespace="preserve">Convenience function to create a new channel dispatch operation proxy.
The @immutable_properties argument is not yet used.
running</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new reference to an channel dispatch operation proxy, or %NULL if</doc>
          <type name="ChannelDispatchOperation" c:type="TpChannelDispatchOperation*"/>
        </return-value>
        <parameters>
          <parameter name="bus_daemon" transfer-ownership="none">
            <doc xml:whitespace="preserve">Proxy for the D-Bus daemon</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">The non-NULL object path of this channel dispatch operation</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <doc xml:whitespace="preserve">As many as are known of the immutable D-Bus properties of this channel dispatch operation, or %NULL if none are known</doc>
            <type name="GLib.HashTable" c:type="GHashTable*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="init_known_interfaces" c:identifier="tp_channel_dispatch_operation_init_known_interfaces" version="0.7.32">
        <doc xml:whitespace="preserve">Ensure that the known interfaces for TpChannelDispatchOperation have been
set up. This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_CHANNEL_DISPATCH_OPERATION.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <function name="get_feature_quark_core" c:identifier="tp_channel_dispatch_operation_get_feature_quark_core">
        <return-value transfer-ownership="full">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <method name="borrow_connection" c:identifier="tp_channel_dispatch_operation_borrow_connection" version="0.11.5" introspectable="0">
        <doc xml:whitespace="preserve">Returns the #TpConnection of this ChannelDispatchOperation.
The returned pointer is only valid while @self is valid - reference
it with g_object_ref() if needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">connection</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </return-value>
      </method>
      <method name="borrow_account" c:identifier="tp_channel_dispatch_operation_borrow_account" version="0.11.5" introspectable="0">
        <doc xml:whitespace="preserve">Returns the #TpAccount of this ChannelDispatchOperation.
The returned pointer is only valid while @self is valid - reference
it with g_object_ref() if needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">account</doc>
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
      </method>
      <method name="borrow_channels" c:identifier="tp_channel_dispatch_operation_borrow_channels" version="0.11.5" introspectable="0">
        <doc xml:whitespace="preserve">Returns a #GPtrArray containing the #TpChannel of this
ChannelDispatchOperation.
The returned array and its #TpChannel are only valid while @self is
valid - copy array and reference channels with g_object_ref() if needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">channels</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="any" c:type="gpointer"/>
          </array>
        </return-value>
      </method>
      <method name="borrow_possible_handlers" c:identifier="tp_channel_dispatch_operation_borrow_possible_handlers" version="0.11.5" introspectable="0">
        <doc xml:whitespace="preserve">Returns a #GStrv containing the possible handlers of this
ChannelDispatchOperation.
The returned array and its strings are only valid while @self is
valid - copy it with g_strdupv if needed.
#TpChannelDispatchOperation:possible-handlers</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of</doc>
          <array c:type="GStrv">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="borrow_immutable_properties" c:identifier="tp_channel_dispatch_operation_borrow_immutable_properties" version="0.11.5" introspectable="0">
        <doc xml:whitespace="preserve">Returns the immutable D-Bus properties of this channel.
The returned hash table is only valid while @self is valid - reference
it with g_hash_table_ref() if needed.
#TpChannelDispatchOperation:cdo-properties</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </return-value>
      </method>
      <method name="handle_with_async" c:identifier="tp_channel_dispatch_operation_handle_with_async" version="0.11.5">
        <doc xml:whitespace="preserve">Called by an approver to accept a channel bundle and request that the
given handler be used to handle it.
If successful, this method will cause the #TpProxy::invalidated signal
to be emitted with the TP_DBUS_ERROR_OBJECT_REMOVED error code.
However, this method may fail because the dispatch has already been
completed and the object has already gone. If this occurs, it indicates
that another approver has asked for the bundle to be handled by a
particular handler. The approver MUST NOT attempt to interact with
the channels further in this case, unless it is separately
invoked as the handler.
Approvers which are also channel handlers SHOULD use
tp_channel_dispatch_operation_claim_async() instead
of tp_channel_dispatch_operation_handle_with_async() to request
that they can handle a channel bundle themselves.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="handler" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">The well-known bus name (starting with #TP_CLIENT_BUS_NAME_BASE) of the channel handler that should handle the channel, or %NULL if the client has no preferred channel handler</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="async" closure="3">
            <doc xml:whitespace="preserve">a callback to call when the call returns</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="handle_with_finish" c:identifier="tp_channel_dispatch_operation_handle_with_finish" version="0.11.5" throws="1">
        <doc xml:whitespace="preserve">Finishes an async call to HandleWith().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the HandleWith() call was successful, otherwise %FALSE</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="claim_async" c:identifier="tp_channel_dispatch_operation_claim_async" version="0.11.5">
        <doc xml:whitespace="preserve">Called by an approver to claim channels for handling internally.
If this method is called successfully, the process calling this
method becomes the handler for the channel.
If successful, this method will cause the #TpProxy::invalidated signal
to be emitted, in the same wayas for
tp_channel_dispatch_operation_handle_with_async().
This method may fail because the dispatch operation has already
been completed. Again, see tp_channel_dispatch_operation_claim_async()
for more details. The approver MUST NOT attempt to interact with
the channels further in this case.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback" transfer-ownership="none" scope="async" closure="2">
            <doc xml:whitespace="preserve">a callback to call when the call returns</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="claim_finish" c:identifier="tp_channel_dispatch_operation_claim_finish" version="0.11.5" throws="1">
        <doc xml:whitespace="preserve">Finishes an async call to Claim().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the Claim() call was successful, otherwise %FALSE</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="handle_with_time_async" c:identifier="tp_channel_dispatch_operation_handle_with_time_async" version="0.11.7">
        <doc xml:whitespace="preserve">A variant of tp_channel_dispatch_operation_handle_with_async()
allowing the approver to pass an user action time.
This timestamp will be passed to the Handler when HandleChannels is called.
If an X server timestamp for the user action causing this method call is
available, @user_action_time should be this timestamp (for instance, the
result of gdk_event_get_time() if it is not %GDK_CURRENT_TIME). Otherwise, it
may be %TP_USER_ACTION_TIME_NOT_USER_ACTION to behave as if there was no
user action or it happened a long time ago, or
%TP_USER_ACTION_TIME_CURRENT_TIME to have the Handler behave as though the
user action had just happened (resembling, but not numerically equal to,
%GDK_CURRENT_TIME).
This method has been introduced in telepathy-mission-control 5.5.0.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="handler" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">The well-known bus name (starting with #TP_CLIENT_BUS_NAME_BASE) of the channel handler that should handle the channel, or %NULL if the client has no preferred channel handler</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="user_action_time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the time at which user action occurred, or one of the special values %TP_USER_ACTION_TIME_NOT_USER_ACTION or %TP_USER_ACTION_TIME_CURRENT_TIME</doc>
            <type name="int64" c:type="gint64"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="async" closure="4">
            <doc xml:whitespace="preserve">a callback to call when the call returns</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="handle_with_time_finish" c:identifier="tp_channel_dispatch_operation_handle_with_time_finish" version="0.11.7" throws="1">
        <doc xml:whitespace="preserve">Finishes an async call to HandleWithTime().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the HandleWithTime() call was successful, otherwise %FALSE</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="account" version="0.11.5" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The #TpAccount with which the connection and channels are associated.
Read-only except during construction.
This is not guaranteed to be set until tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_DISPATCH_OPERATION_FEATURE_CORE.</doc>
        <type name="Account" c:type="TpAccount"/>
      </property>
      <property name="channels" version="0.11.5" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GPtrArray containing the #TpChannel to be dispatched.
Read-only.
This is not guaranteed to be set until tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_DISPATCH_OPERATION_FEATURE_CORE.</doc>
        <type name="GLib.PtrArray" c:type="GPtrArray"/>
      </property>
      <property name="connection" version="0.11.5" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The #TpConnection with which the channels are associated.
Read-only except during construction.
This is not guaranteed to be set until tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_DISPATCH_OPERATION_FEATURE_CORE.</doc>
        <type name="Connection" c:type="TpConnection"/>
      </property>
      <property name="possible-handlers" version="0.11.5" transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GStrv containing the well known bus names (starting
with TP_CLIENT_BUS_NAME_BASE) of the possible Handlers for
the channels
Read-only except during construction.
This is not guaranteed to be set until tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_DISPATCH_OPERATION_FEATURE_CORE.</doc>
        <type name="GObject.Strv" c:type="GStrv"/>
      </property>
      <field name="parent">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="priv">
        <type name="ChannelDispatchOperationPrivate" c:type="TpChannelDispatchOperationPrivate*"/>
      </field>
      <glib:signal name="channel-lost" version="0.11.5">
        <doc xml:whitespace="preserve">Emitted when a channel has closed before it could be claimed or handled.</doc>
        <return-value transfer-ownership="full">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="channel" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpChannel that closed</doc>
            <type name="Channel" c:type="TpChannel"/>
          </parameter>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:whitespace="preserve">domain of a #GError indicating why the channel has been closed</doc>
            <type name="uint" c:type="guint"/>
          </parameter>
          <parameter name="code" transfer-ownership="none">
            <doc xml:whitespace="preserve">error code of a #GError indicating why the channel has been closed</doc>
            <type name="int" c:type="gint"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">a message associated with the error</doc>
            <type name="utf8" c:type="gchararray"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ChannelDispatchOperationClass" c:type="TpChannelDispatchOperationClass" glib:is-gtype-struct-for="ChannelDispatchOperation">
      <doc xml:whitespace="preserve">The class of a #TpChannelDispatchOperation.</doc>
      <field name="parent_class">
        <type name="ProxyClass" c:type="TpProxyClass"/>
      </field>
      <field name="_padding">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback"/>
        </array>
      </field>
      <field name="priv">
        <type name="ChannelDispatchOperationClassPrivate" c:type="TpChannelDispatchOperationClassPrivate*"/>
      </field>
    </record>
    <record name="ChannelDispatchOperationClassPrivate" c:type="TpChannelDispatchOperationClassPrivate">
    </record>
    <record name="ChannelDispatchOperationPrivate" c:type="TpChannelDispatchOperationPrivate">
    </record>
    <enumeration name="ChannelGroupChangeReason" c:type="TpChannelGroupChangeReason">
      <member name="none" value="0" c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_NONE"/>
      <member name="offline" value="1" c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_OFFLINE"/>
      <member name="kicked" value="2" c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_KICKED"/>
      <member name="busy" value="3" c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_BUSY"/>
      <member name="invited" value="4" c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_INVITED"/>
      <member name="banned" value="5" c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_BANNED"/>
      <member name="error" value="6" c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_ERROR"/>
      <member name="invalid_contact" value="7" c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_INVALID_CONTACT"/>
      <member name="no_answer" value="8" c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_NO_ANSWER"/>
      <member name="renamed" value="9" c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_RENAMED"/>
      <member name="permission_denied" value="10" c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_PERMISSION_DENIED"/>
      <member name="separated" value="11" c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_SEPARATED"/>
    </enumeration>
    <enumeration name="ChannelGroupFlags" c:type="TpChannelGroupFlags">
      <member name="can_add" value="1" c:identifier="TP_CHANNEL_GROUP_FLAG_CAN_ADD"/>
      <member name="can_remove" value="2" c:identifier="TP_CHANNEL_GROUP_FLAG_CAN_REMOVE"/>
      <member name="can_rescind" value="4" c:identifier="TP_CHANNEL_GROUP_FLAG_CAN_RESCIND"/>
      <member name="message_add" value="8" c:identifier="TP_CHANNEL_GROUP_FLAG_MESSAGE_ADD"/>
      <member name="message_remove" value="16" c:identifier="TP_CHANNEL_GROUP_FLAG_MESSAGE_REMOVE"/>
      <member name="message_accept" value="32" c:identifier="TP_CHANNEL_GROUP_FLAG_MESSAGE_ACCEPT"/>
      <member name="message_reject" value="64" c:identifier="TP_CHANNEL_GROUP_FLAG_MESSAGE_REJECT"/>
      <member name="message_rescind" value="128" c:identifier="TP_CHANNEL_GROUP_FLAG_MESSAGE_RESCIND"/>
      <member name="channel_specific_handles" value="256" c:identifier="TP_CHANNEL_GROUP_FLAG_CHANNEL_SPECIFIC_HANDLES"/>
      <member name="only_one_group" value="512" c:identifier="TP_CHANNEL_GROUP_FLAG_ONLY_ONE_GROUP"/>
      <member name="handle_owners_not_available" value="1024" c:identifier="TP_CHANNEL_GROUP_FLAG_HANDLE_OWNERS_NOT_AVAILABLE"/>
      <member name="properties" value="2048" c:identifier="TP_CHANNEL_GROUP_FLAG_PROPERTIES"/>
      <member name="members_changed_detailed" value="4096" c:identifier="TP_CHANNEL_GROUP_FLAG_MEMBERS_CHANGED_DETAILED"/>
      <member name="message_depart" value="8192" c:identifier="TP_CHANNEL_GROUP_FLAG_MESSAGE_DEPART"/>
    </enumeration>
    <record name="ChannelManagerIter" c:type="TpChannelManagerIter" version="0.7.15" introspectable="0">
      <doc xml:whitespace="preserve">An iterator over the #TpChannelManager objects known to a #TpBaseConnection.
It has no public fields.
Use tp_base_connection_channel_manager_iter_init() to start iteration and
tp_base_connection_channel_manager_iter_next() to continue.</doc>
      <field name="self" writable="1">
        <type name="BaseConnection" c:type="TpBaseConnection*"/>
      </field>
      <field name="index" writable="1">
        <type name="uint" c:type="guint"/>
      </field>
      <field name="_future" writable="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="2">
          <type name="any"/>
        </array>
      </field>
    </record>
    <enumeration name="ChannelMediaCapabilities" c:type="TpChannelMediaCapabilities">
      <member name="audio" value="1" c:identifier="TP_CHANNEL_MEDIA_CAPABILITY_AUDIO"/>
      <member name="video" value="2" c:identifier="TP_CHANNEL_MEDIA_CAPABILITY_VIDEO"/>
      <member name="nat_traversal_stun" value="4" c:identifier="TP_CHANNEL_MEDIA_CAPABILITY_NAT_TRAVERSAL_STUN"/>
      <member name="nat_traversal_gtalk_p2p" value="8" c:identifier="TP_CHANNEL_MEDIA_CAPABILITY_NAT_TRAVERSAL_GTALK_P2P"/>
      <member name="nat_traversal_ice_udp" value="16" c:identifier="TP_CHANNEL_MEDIA_CAPABILITY_NAT_TRAVERSAL_ICE_UDP"/>
      <member name="immutable_streams" value="32" c:identifier="TP_CHANNEL_MEDIA_CAPABILITY_IMMUTABLE_STREAMS"/>
    </enumeration>
    <enumeration name="ChannelPasswordFlags" c:type="TpChannelPasswordFlags">
      <member name="channel_password_flag_provide" value="8" c:identifier="TP_CHANNEL_PASSWORD_FLAG_PROVIDE"/>
    </enumeration>
    <record name="ChannelPrivate" c:type="TpChannelPrivate">
    </record>
    <class name="ChannelRequest" c:type="TpChannelRequest" version="0.7.32" parent="Proxy" glib:type-name="TpChannelRequest" glib:get-type="tp_channel_request_get_type" glib:type-struct="ChannelRequestClass">
      <doc xml:whitespace="preserve">Requesting a channel from the channel dispatcher can take some time, so an
object is created in the channel dispatcher to represent each request. This
proxy represents one of those objects.
Any client can call tp_cli_channel_request_call_cancel() at any time to
attempt to cancel the request.
On success, the #TpChannelRequest::succeeded signal will be emitted.
Immediately after that, the #TpProxy::invalidated signal will be emitted,
with the domain %TP_DBUS_ERRORS and the error code
%TP_DBUS_ERROR_OBJECT_REMOVED (this is not an error condition, it merely
indicates that the channel request no longer exists).
On failure, the #TpProxy::invalidated signal will be emitted with some
other suitable error, usually from the %TP_ERRORS domain.
If the channel dispatcher crashes or exits, the #TpProxy::invalidated
signal will be emitted with the domain %TP_DBUS_ERRORS and the error code
%TP_DBUS_ERROR_NAME_OWNER_LOST.
UserActionTime, PreferredHandler, Requests and Interfaces properties will
be added in a later version of telepathy-glib, along with a mechanism
similar to tp_connection_call_when_ready().
Until suitable convenience methods are implemented, the generic
tp_cli_dbus_properties_call_get_all() method can be used to get those
properties.</doc>
      <constructor name="new" c:identifier="tp_channel_request_new" throws="1">
        <doc xml:whitespace="preserve">Convenience function to create a new channel request proxy.
If the channel request was newly created, the client making the request
is responsible for calling tp_cli_channel_request_call_proceed() when it
is ready for the channel request to proceed.
The @immutable_properties argument is not yet used.
not running</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new reference to an channel request proxy, or %NULL if</doc>
          <type name="ChannelRequest" c:type="TpChannelRequest*"/>
        </return-value>
        <parameters>
          <parameter name="bus_daemon" transfer-ownership="none">
            <doc xml:whitespace="preserve">Proxy for the D-Bus daemon</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">The non-NULL object path of this channel request</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <doc xml:whitespace="preserve">As many as are known of the immutable D-Bus properties of this channel request, or %NULL if none are known</doc>
            <type name="GLib.HashTable" c:type="GHashTable*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="init_known_interfaces" c:identifier="tp_channel_request_init_known_interfaces" version="0.7.32">
        <doc xml:whitespace="preserve">Ensure that the known interfaces for TpChannelRequest have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_CHANNEL_REQUEST.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <field name="parent">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="priv">
        <type name="ChannelRequestPrivate" c:type="TpChannelRequestPrivate*"/>
      </field>
      <glib:signal name="succeeded">
        <doc xml:whitespace="preserve">Emitted when the channel request succeeds.</doc>
        <return-value transfer-ownership="full">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="ChannelRequestClass" c:type="TpChannelRequestClass" glib:is-gtype-struct-for="ChannelRequest">
      <doc xml:whitespace="preserve">The class of a #TpChannelRequest.</doc>
      <field name="parent_class">
        <type name="ProxyClass" c:type="TpProxyClass"/>
      </field>
      <field name="_padding">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback"/>
        </array>
      </field>
      <field name="priv">
        <type name="ChannelRequestClassPrivate" c:type="TpChannelRequestClassPrivate*"/>
      </field>
    </record>
    <record name="ChannelRequestClassPrivate" c:type="TpChannelRequestClassPrivate">
    </record>
    <record name="ChannelRequestPrivate" c:type="TpChannelRequestPrivate">
    </record>
    <enumeration name="ChannelTextMessageFlags" c:type="TpChannelTextMessageFlags">
      <member name="truncated" value="1" c:identifier="TP_CHANNEL_TEXT_MESSAGE_FLAG_TRUNCATED"/>
      <member name="non_text_content" value="2" c:identifier="TP_CHANNEL_TEXT_MESSAGE_FLAG_NON_TEXT_CONTENT"/>
      <member name="scrollback" value="4" c:identifier="TP_CHANNEL_TEXT_MESSAGE_FLAG_SCROLLBACK"/>
      <member name="rescued" value="8" c:identifier="TP_CHANNEL_TEXT_MESSAGE_FLAG_RESCUED"/>
    </enumeration>
    <enumeration name="ChannelTextMessageType" c:type="TpChannelTextMessageType">
      <member name="normal" value="0" c:identifier="TP_CHANNEL_TEXT_MESSAGE_TYPE_NORMAL"/>
      <member name="action" value="1" c:identifier="TP_CHANNEL_TEXT_MESSAGE_TYPE_ACTION"/>
      <member name="notice" value="2" c:identifier="TP_CHANNEL_TEXT_MESSAGE_TYPE_NOTICE"/>
      <member name="auto_reply" value="3" c:identifier="TP_CHANNEL_TEXT_MESSAGE_TYPE_AUTO_REPLY"/>
      <member name="delivery_report" value="4" c:identifier="TP_CHANNEL_TEXT_MESSAGE_TYPE_DELIVERY_REPORT"/>
    </enumeration>
    <enumeration name="ChannelTextSendError" c:type="TpChannelTextSendError">
      <member name="unknown" value="0" c:identifier="TP_CHANNEL_TEXT_SEND_ERROR_UNKNOWN"/>
      <member name="offline" value="1" c:identifier="TP_CHANNEL_TEXT_SEND_ERROR_OFFLINE"/>
      <member name="invalid_contact" value="2" c:identifier="TP_CHANNEL_TEXT_SEND_ERROR_INVALID_CONTACT"/>
      <member name="permission_denied" value="3" c:identifier="TP_CHANNEL_TEXT_SEND_ERROR_PERMISSION_DENIED"/>
      <member name="too_long" value="4" c:identifier="TP_CHANNEL_TEXT_SEND_ERROR_TOO_LONG"/>
      <member name="not_implemented" value="5" c:identifier="TP_CHANNEL_TEXT_SEND_ERROR_NOT_IMPLEMENTED"/>
    </enumeration>
    <callback name="ChannelWhenReadyCb" c:type="TpChannelWhenReadyCb">
      <doc xml:whitespace="preserve">Signature of a callback passed to tp_channel_call_when_ready(), which
will be called exactly once, when the channel becomes ready or
invalid (whichever happens first)</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="channel" transfer-ownership="none">
          <doc xml:whitespace="preserve">the channel (which may be in the middle of being disposed, if error is non-%NULL, error-&gt;domain is TP_DBUS_ERRORS and error-&gt;code is TP_DBUS_ERROR_PROXY_UNREFERENCED)</doc>
          <type name="Channel" c:type="TpChannel*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">%NULL if the channel is ready for use, or the error with which it was invalidated if it is now invalid</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">whatever was passed to tp_channel_call_when_ready()</doc>
          <type name="any" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="ConnMgrParamFlags" c:type="TpConnMgrParamFlags">
      <member name="required" value="1" c:identifier="TP_CONN_MGR_PARAM_FLAG_REQUIRED"/>
      <member name="register" value="2" c:identifier="TP_CONN_MGR_PARAM_FLAG_REGISTER"/>
      <member name="has_default" value="4" c:identifier="TP_CONN_MGR_PARAM_FLAG_HAS_DEFAULT"/>
      <member name="secret" value="8" c:identifier="TP_CONN_MGR_PARAM_FLAG_SECRET"/>
      <member name="dbus_property" value="16" c:identifier="TP_CONN_MGR_PARAM_FLAG_DBUS_PROPERTY"/>
    </enumeration>
    <class name="Connection" c:type="TpConnection" version="0.7.1" parent="Proxy" glib:type-name="TpConnection" glib:get-type="tp_connection_get_type" glib:type-struct="ConnectionClass">
      <doc xml:whitespace="preserve">A proxy object for a Telepathy connection. There are no interesting
public struct fields.
(Changed in 0.7.12: the layout of the structure is visible, allowing
subclassing.)</doc>
      <constructor name="new" c:identifier="tp_connection_new" version="0.7.1" throws="1">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;
fails or on invalid arguments</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new connection proxy, or %NULL if unique-name resolution</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </return-value>
        <parameters>
          <parameter name="dbus" transfer-ownership="none">
            <doc xml:whitespace="preserve">a D-Bus daemon; may not be %NULL</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
          <parameter name="bus_name" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">the well-known or unique name of the connection process; if well-known, this function will make a blocking call to the bus daemon to resolve the unique name. May be %NULL if @object_path is not, in which case a well-known name will be derived from @object_path.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">the object path of the connection process. May be %NULL if @bus_name is a well-known name, in which case the object path will be derived from @bus_name.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="init_known_interfaces" c:identifier="tp_connection_init_known_interfaces" version="0.7.6">
        <doc xml:whitespace="preserve">Ensure that the known interfaces for TpConnection have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_CONNECTION.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <function name="presence_type_cmp_availability" c:identifier="tp_connection_presence_type_cmp_availability" version="0.7.16">
        <doc xml:whitespace="preserve">Compares @p1 and @p2 like strcmp(). @p1 &gt; @p2 means @p1 is more available
than @p2.
unknown &gt; unset</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">-1, 0 or 1, if @p1 is &lt;, == or &gt; than @p2.</doc>
          <type name="int" c:type="gint"/>
        </return-value>
        <parameters>
          <parameter name="p1" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpConnectionPresenceType</doc>
            <type name="ConnectionPresenceType" c:type="TpConnectionPresenceType"/>
          </parameter>
          <parameter name="p2" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpConnectionPresenceType</doc>
            <type name="ConnectionPresenceType" c:type="TpConnectionPresenceType"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_feature_quark_core" c:identifier="tp_connection_get_feature_quark_core">
        <return-value transfer-ownership="full">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_connected" c:identifier="tp_connection_get_feature_quark_connected">
        <return-value transfer-ownership="full">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_capabilities" c:identifier="tp_connection_get_feature_quark_capabilities">
        <return-value transfer-ownership="full">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_contact_info" c:identifier="tp_connection_get_feature_quark_contact_info">
        <return-value transfer-ownership="full">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_avatar_requirements" c:identifier="tp_connection_get_feature_quark_avatar_requirements">
        <return-value transfer-ownership="full">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <method name="get_status" c:identifier="tp_connection_get_status" version="0.7.14">
        <doc xml:whitespace="preserve">If @reason is not %NULL it is set to the reason why "status" changed to its
current value, or %TP_CONNECTION_STATUS_REASON_NONE_SPECIFIED if unknown.
don't know yet.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">This connection's status, or %TP_UNKNOWN_CONNECTION_STATUS if we</doc>
          <type name="ConnectionStatus" c:type="TpConnectionStatus"/>
        </return-value>
        <parameters>
          <parameter name="reason" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:whitespace="preserve">a TpConnectionStatusReason, or %NULL</doc>
            <type name="ConnectionStatusReason" c:type="TpConnectionStatusReason*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_self_handle" c:identifier="tp_connection_get_self_handle" version="0.7.26">
        <doc xml:whitespace="preserve">Return the %TP_HANDLE_TYPE_CONTACT handle of the local user on this
connection, or 0 if the self-handle is not known yet or the connection
has become invalid (the TpProxy::invalidated signal).
The returned handle is not necessarily valid forever (the
notify::self-handle signal will be emitted if it changes, which can happen
on protocols such as IRC). Construct a #TpContact object if you want to
track the local user's identifier in the protocol, or other information
like their presence status, over time.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the value of the TpConnection:self-handle property</doc>
          <type name="Handle" c:type="TpHandle"/>
        </return-value>
      </method>
      <method name="get_capabilities" c:identifier="tp_connection_get_capabilities" version="0.11.3">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;
#TpConnection:capabilities property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same #TpCapabilities as the</doc>
          <type name="Capabilities" c:type="TpCapabilities*"/>
        </return-value>
      </method>
      <method name="get_contact_info_flags" c:identifier="tp_connection_get_contact_info_flags">
        <return-value transfer-ownership="full">
          <type name="ContactInfoFlags" c:type="TpContactInfoFlags"/>
        </return-value>
      </method>
      <method name="get_contact_info_supported_fields" c:identifier="tp_connection_get_contact_info_supported_fields" introspectable="0">
        <return-value transfer-ownership="full">
          <type name="GLib.List" c:type="GList*">
            <type name="any" c:type="gpointer"/>
          </type>
        </return-value>
      </method>
      <method name="set_contact_info_async" c:identifier="tp_connection_set_contact_info_async" introspectable="0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="info" transfer-ownership="none">
            <type name="GLib.List" c:type="GList*">
              <type name="any" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="async" closure="3">
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_contact_info_finish" c:identifier="tp_connection_set_contact_info_finish" throws="1">
        <return-value transfer-ownership="none">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_ready" c:identifier="tp_connection_is_ready" version="0.7.17" introspectable="0">
        <doc xml:whitespace="preserve">Returns the same thing as the #TpConnection:connection-ready property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if introspection has completed</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="run_until_ready" c:identifier="tp_connection_run_until_ready" version="0.7.1" introspectable="0" deprecated="Use tp_connection_call_when_ready," deprecated-version="0.11.0">
        <doc xml:whitespace="preserve">If @self is connected and ready for use, return immediately. Otherwise,
call Connect() (unless @connect is %FALSE) and re-enter the main loop
until the connection becomes invalid, the connection connects successfully
and is introspected, or the main loop stored via @loop is cancelled.
%FALSE if the connection has become invalid.
or restructure your program in such a way as to avoid re-entering the
main loop.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the connection is now connected and ready for use,</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="connect" transfer-ownership="none">
            <doc xml:whitespace="preserve">if %TRUE, call Connect() if it appears to be necessary; if %FALSE, rely on Connect() to be called by another client</doc>
            <type name="boolean" c:type="gboolean"/>
          </parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:whitespace="preserve">if not %NULL and %FALSE is returned, used to raise an error</doc>
            <type name="GLib.Error" c:type="GError**"/>
          </parameter>
          <parameter name="loop" transfer-ownership="none">
            <doc xml:whitespace="preserve">if not %NULL, a #GMainLoop is placed here while it is being run (so calling code can call g_main_loop_quit() to abort), and %NULL is placed here after the loop has been run</doc>
            <type name="GLib.MainLoop" c:type="GMainLoop**"/>
          </parameter>
        </parameters>
      </method>
      <method name="call_when_ready" c:identifier="tp_connection_call_when_ready" version="0.7.7" introspectable="0">
        <doc xml:whitespace="preserve">If @self is ready for use or has been invalidated, call @callback
immediately, then return. Otherwise, arrange
for @callback to be called when @self either becomes ready for use
or becomes invalid.
Note that if the connection is not in state CONNECTED, the callback will
not be called until the connection either goes to state CONNECTED
or is invalidated (e.g. by going to state DISCONNECTED or by becoming
unreferenced). In particular, this method does not call Connect().
Call tp_cli_connection_call_connect() too, if you want to do that.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback" transfer-ownership="none" scope="call" closure="2">
            <doc xml:whitespace="preserve">called when the connection becomes ready or invalidated, whichever happens first</doc>
            <type name="ConnectionWhenReadyCb" c:type="TpConnectionWhenReadyCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data passed to the callback</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_object_path" c:identifier="tp_connection_parse_object_path" version="0.7.27">
        <doc xml:whitespace="preserve">If the object path of @connection is in the correct form, set
return FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the object path was correctly parsed, FALSE otherwise.</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="protocol" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:whitespace="preserve">If not NULL, used to return the protocol of the connection</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="cm_name" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:whitespace="preserve">If not NULL, used to return the connection manager name of the connection</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_detailed_error" c:identifier="tp_connection_get_detailed_error" version="0.11.4">
        <doc xml:whitespace="preserve">If the connection has disconnected, return the D-Bus error name with which
it disconnected (in particular, this is %TP_ERROR_STR_CANCELLED if it was
disconnected by a user request).
Otherwise, return %NULL, without altering @details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a D-Bus error name, or %NULL.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="details" direction="out" caller-allocates="0" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">optionally used to return a map from string to #GValue, which must not be modified or destroyed by the caller</doc>
            <type name="GLib.HashTable" c:type="GHashTable**">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="hold_handles" c:identifier="tp_connection_hold_handles">
        <doc xml:whitespace="preserve">Hold (ensure a reference to) the given handles, if they are valid.
If they are valid, the callback will later be called with the given
handles; if not all of them are valid, the callback will be called with
an error.
This function, along with tp_connection_unref_handles(),
tp_connection_get_contact_attributes() and #TpContact, keeps a client-side
reference count of handles; you should not use the RequestHandles,
HoldHandles and GetContactAttributes D-Bus methods directly as well as these
functions.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="timeout_ms" transfer-ownership="none">
            <doc xml:whitespace="preserve">the timeout in milliseconds, or -1 to use the default</doc>
            <type name="int" c:type="gint"/>
          </parameter>
          <parameter name="handle_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the handle type</doc>
            <type name="HandleType" c:type="TpHandleType"/>
          </parameter>
          <parameter name="n_handles" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of handles in @handles (must be at least 1)</doc>
            <type name="uint" c:type="guint"/>
          </parameter>
          <parameter name="handles" transfer-ownership="none">
            <doc xml:whitespace="preserve">an array of handles</doc>
            <array length="3" c:type="TpHandle*">
              <type name="Handle"/>
            </array>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="notified" closure="6" destroy="7">
            <doc xml:whitespace="preserve">called on success or failure (unless @weak_object has become unreferenced)</doc>
            <type name="ConnectionHoldHandlesCb" c:type="TpConnectionHoldHandlesCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="call">
            <doc xml:whitespace="preserve">called to destroy @user_data after calling @callback, or when</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object" transfer-ownership="none">
            <doc xml:whitespace="preserve">if not %NULL, an object to be weakly referenced: if it is destroyed, @callback will not be called</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_handles" c:identifier="tp_connection_request_handles">
        <doc xml:whitespace="preserve">Request the handles corresponding to the given identifiers, and if they
are valid, hold (ensure a reference to) the corresponding handles.
If they are valid, the callback will later be called with the given
handles; if not all of them are valid, the callback will be called with
an error.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="timeout_ms" transfer-ownership="none">
            <doc xml:whitespace="preserve">the timeout in milliseconds, or -1 to use the default</doc>
            <type name="int" c:type="gint"/>
          </parameter>
          <parameter name="handle_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the handle type</doc>
            <type name="HandleType" c:type="TpHandleType"/>
          </parameter>
          <parameter name="ids" transfer-ownership="none">
            <doc xml:whitespace="preserve">an array of string identifiers for which handles are required, terminated by %NULL (must not be %NULL or empty)</doc>
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="notified" closure="5" destroy="6">
            <doc xml:whitespace="preserve">called on success or failure (unless @weak_object has become unreferenced)</doc>
            <type name="ConnectionRequestHandlesCb" c:type="TpConnectionRequestHandlesCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="call">
            <doc xml:whitespace="preserve">called to destroy @user_data after calling @callback, or when</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object" transfer-ownership="none">
            <doc xml:whitespace="preserve">if not %NULL, an object to be weakly referenced: if it is destroyed, @callback will not be called</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref_handles" c:identifier="tp_connection_unref_handles">
        <doc xml:whitespace="preserve">Release the reference to the handles in @handles that was obtained by
calling tp_connection_hold_handles() or tp_connection_request_handles().
This function might release any references held by calling
tp_cli_connection_call_request_handles(),
tp_cli_connection_run_request_handles(),
tp_cli_connection_call_hold_handles(),
tp_cli_connection_run_hold_handles(),
tp_cli_connection_interface_contacts_call_get_contact_attributes() or
tp_cli_connection_interface_contacts_run_get_contact_attributes() directly.
Those functions should be avoided in favour of using #TpContact,
tp_connection_hold_handles(), tp_connection_request_handles() and
tp_connection_get_contact_attributes(), which along with this function
perform client-side reference counting of handles.
If @self has already become invalid, this function does nothing.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="handle_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a handle type</doc>
            <type name="HandleType" c:type="TpHandleType"/>
          </parameter>
          <parameter name="n_handles" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of handles in @handles</doc>
            <type name="uint" c:type="guint"/>
          </parameter>
          <parameter name="handles" transfer-ownership="none">
            <doc xml:whitespace="preserve">an array of @n_handles handles</doc>
            <array length="2" c:type="TpHandle*">
              <type name="Handle"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="get_avatar_requirements" c:identifier="tp_connection_get_avatar_requirements">
        <return-value transfer-ownership="full">
          <type name="AvatarRequirements" c:type="TpAvatarRequirements*"/>
        </return-value>
      </method>
      <method name="get_contact_attributes" c:identifier="tp_connection_get_contact_attributes">
        <doc xml:whitespace="preserve">Return (via a callback) any number of attributes of the given handles, and
if they are valid and @hold is TRUE, hold a reference to them.
This is a thin wrapper around the GetContactAttributes D-Bus method, and
should be used in preference to
tp_cli_connection_interface_contacts_call_get_contact_attributes(); mixing this
function, tp_connection_hold_handles(), tp_connection_unref_handles(), and
#TpContact with direct use of the RequestHandles, HoldHandles and
GetContactAttributes D-Bus methods is unwise, as #TpConnection and
#TpContact perform client-side reference counting of handles.
The #TpContact API provides a higher-level abstraction which should
usually be used instead.
handles that were valid. Invalid handles are simply omitted from the
parameter to the callback.
If @hold is %TRUE, the @callback is given one reference to each handle
that appears as a key in the callback's @attributes parameter.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="timeout_ms" transfer-ownership="none">
            <doc xml:whitespace="preserve">the timeout in milliseconds, or -1 to use the default</doc>
            <type name="int" c:type="gint"/>
          </parameter>
          <parameter name="n_handles" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of handles in @handles (must be at least 1)</doc>
            <type name="uint" c:type="guint"/>
          </parameter>
          <parameter name="handles" transfer-ownership="none">
            <doc xml:whitespace="preserve">an array of handles</doc>
            <array length="2" c:type="TpHandle*">
              <type name="Handle"/>
            </array>
          </parameter>
          <parameter name="interfaces" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GStrv of interfaces</doc>
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="hold" transfer-ownership="none">
            <doc xml:whitespace="preserve">if %TRUE, the callback will hold one reference to each valid handle</doc>
            <type name="boolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none">
            <doc xml:whitespace="preserve">called on success or failure (unless @weak_object has become unreferenced)</doc>
            <type name="GObject.Callback" c:type="tp_cli_connection_interface_contacts_callback_for_get_contact_attributes"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="call">
            <doc xml:whitespace="preserve">called to destroy @user_data after calling @callback, or when</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object" transfer-ownership="none">
            <doc xml:whitespace="preserve">if not %NULL, an object to be weakly referenced: if it is destroyed, @callback will not be called</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="refresh_contact_info" c:identifier="tp_connection_refresh_contact_info" version="0.11.7">
        <doc xml:whitespace="preserve">Requests to refresh the #TpContact:contact-info property on each contact from
cached locally. "notify::contact-info" will be emitted when the contact's
information are updated.
If %TP_CONTACT_FEATURE_CONTACT_INFO is not yet set on a contact, it will be
set before its property gets updated.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="n_contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of contacts in @contacts (must be at least 1)</doc>
            <type name="uint" c:type="guint"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of #TpContact objects associated with @self</doc>
            <array length="1" c:type="TpContact**">
              <type name="Contact"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="get_contacts_by_handle" c:identifier="tp_connection_get_contacts_by_handle" version="0.7.18">
        <doc xml:whitespace="preserve">Create a number of #TpContact objects and make asynchronous method calls
to hold their handles and ensure that all the features specified in
It is not an error to put features in @features even if the connection
manager doesn't support them - users of this method should have a static
list of features they would like to use if possible, and use it for all
connection managers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="n_handles" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of handles in @handles (must be at least 1)</doc>
            <type name="uint" c:type="guint"/>
          </parameter>
          <parameter name="handles" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of handles of type %TP_HANDLE_TYPE_CONTACT representing the desired contacts</doc>
            <array length="1" c:type="TpHandle*">
              <type name="uint"/>
            </array>
          </parameter>
          <parameter name="n_features" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of features in @features (may be 0)</doc>
            <type name="uint" c:type="guint"/>
          </parameter>
          <parameter name="features" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">An array of features that must be ready for use (if supported) before the callback is called (may be %NULL if @n_features is 0)</doc>
            <array length="3" c:type="TpContactFeature*">
              <type name="uint"/>
            </array>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="notified" closure="6" destroy="7">
            <doc xml:whitespace="preserve">A user callback to call when the contacts are ready</doc>
            <type name="ConnectionContactsByHandleCb" c:type="TpConnectionContactsByHandleCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">Data to pass to the callback</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="call">
            <doc xml:whitespace="preserve">Called to destroy @user_data either after @callback has been called, or if the operation is cancelled</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">An object to pass to the callback, which will be weakly referenced; if this object is destroyed, the operation will be cancelled</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="upgrade_contacts" c:identifier="tp_connection_upgrade_contacts" version="0.7.18">
        <doc xml:whitespace="preserve">Given several #TpContact objects, make asynchronous method calls
ensure that all the features specified in @features are ready for use
(if they are supported at all).
It is not an error to put features in @features even if the connection
manager doesn't support them - users of this method should have a static
list of features they would like to use if possible, and use it for all
connection managers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="n_contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of contacts in @contacts (must be at least 1)</doc>
            <type name="uint" c:type="guint"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of #TpContact objects associated with @self</doc>
            <array length="1" c:type="TpContact**">
              <type name="Contact"/>
            </array>
          </parameter>
          <parameter name="n_features" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of features in @features (must be at least 1)</doc>
            <type name="uint" c:type="guint"/>
          </parameter>
          <parameter name="features" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of features that must be ready for use (if supported) before the callback is called</doc>
            <array length="3" c:type="TpContactFeature*">
              <type name="ContactFeature"/>
            </array>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="notified" closure="6" destroy="7">
            <doc xml:whitespace="preserve">A user callback to call when the contacts are ready</doc>
            <type name="ConnectionUpgradeContactsCb" c:type="TpConnectionUpgradeContactsCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">Data to pass to the callback</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="call">
            <doc xml:whitespace="preserve">Called to destroy @user_data either after @callback has been called, or if the operation is cancelled</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">An object to pass to the callback, which will be weakly referenced; if this object is destroyed, the operation will be cancelled</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_contacts_by_id" c:identifier="tp_connection_get_contacts_by_id" version="0.7.18">
        <doc xml:whitespace="preserve">Create a number of #TpContact objects and make asynchronous method calls
to obtain their handles and ensure that all the features specified in
It is not an error to put features in @features even if the connection
manager doesn't support them - users of this method should have a static
list of features they would like to use if possible, and use it for all
connection managers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="n_ids" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of IDs in @ids (must be at least 1)</doc>
            <type name="uint" c:type="guint"/>
          </parameter>
          <parameter name="ids" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of strings representing the desired contacts by their identifiers in the IM protocol (XMPP JIDs, SIP URIs, MSN Passports, AOL screen-names etc.)</doc>
            <array length="1" c:type="gchar**">
              <type name="int8"/>
            </array>
          </parameter>
          <parameter name="n_features" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of features in @features (may be 0)</doc>
            <type name="uint" c:type="guint"/>
          </parameter>
          <parameter name="features" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">An array of features that must be ready for use (if supported) before the callback is called (may be %NULL if @n_features is 0)</doc>
            <array length="3" c:type="TpContactFeature*">
              <type name="ContactFeature"/>
            </array>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="notified" closure="6" destroy="7">
            <doc xml:whitespace="preserve">A user callback to call when the contacts are ready</doc>
            <type name="ConnectionContactsByIdCb" c:type="TpConnectionContactsByIdCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">Data to pass to the callback</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="call">
            <doc xml:whitespace="preserve">Called to destroy @user_data either after @callback has been called, or if the operation is cancelled</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">An object to pass to the callback, which will be weakly referenced; if this object is destroyed, the operation will be cancelled</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <property name="capabilities" transfer-ownership="none">
        <doc xml:whitespace="preserve">The %TpCapabilities object representing the capabilities of this
connection, or NULL if we don't know yet.
To wait for valid capability information, call tp_proxy_prepare_async()
with the feature %TP_CONNECTION_FEATURE_CAPABILITIES.</doc>
        <type name="Capabilities" c:type="TpCapabilities"/>
      </property>
      <property name="connection-ready" transfer-ownership="none">
        <doc xml:whitespace="preserve">Initially %FALSE; changes to %TRUE when the connection has gone to
CONNECTED status, introspection has finished and it's ready for use.
By the time this property becomes %TRUE, any extra interfaces will
have been set up and the #TpProxy:interfaces property will have been
populated.
This is similar to %TP_CONNECTION_FEATURE_CONNECTED, except that once
it has changed to %TRUE, it remains %TRUE even if the connection has
been invalidated.</doc>
        <type name="boolean" c:type="gboolean"/>
      </property>
      <property name="self-handle" transfer-ownership="none">
        <doc xml:whitespace="preserve">The %TP_HANDLE_TYPE_CONTACT handle of the local user on this connection,
or 0 if we don't know yet or if the connection has become invalid.
To wait for a valid self-handle (and other properties), call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONNECTED.</doc>
        <type name="uint" c:type="guint"/>
      </property>
      <property name="status" transfer-ownership="none">
        <doc xml:whitespace="preserve">This connection's status, or %TP_UNKNOWN_CONNECTION_STATUS if we don't
know yet.
To wait for a valid status (and other properties), call
tp_proxy_prepare_async() with the feature %TP_CONNECTION_FEATURE_CORE.
Since version 0.11.3, the change to status
%TP_CONNECTION_STATUS_CONNECTED is delayed slightly, until introspection
of the connection has finished.</doc>
        <type name="uint" c:type="guint"/>
      </property>
      <property name="status-reason" transfer-ownership="none">
        <doc xml:whitespace="preserve">To wait for a valid status (and other properties), call
tp_proxy_prepare_async() with the feature %TP_CONNECTION_FEATURE_CORE.
The reason why #TpConnection:status changed to its current value,
or TP_CONNECTION_STATUS_REASON_NONE_SPECIFIED if unknown.
know yet.</doc>
        <type name="uint" c:type="guint"/>
      </property>
      <field name="parent">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="priv">
        <type name="ConnectionPrivate" c:type="TpConnectionPrivate*"/>
      </field>
    </class>
    <enumeration name="ConnectionAliasFlags" c:type="TpConnectionAliasFlags">
      <member name="connection_alias_flag_user_set" value="1" c:identifier="TP_CONNECTION_ALIAS_FLAG_USER_SET"/>
    </enumeration>
    <enumeration name="ConnectionCapabilityFlags" c:type="TpConnectionCapabilityFlags">
      <member name="create" value="1" c:identifier="TP_CONNECTION_CAPABILITY_FLAG_CREATE"/>
      <member name="invite" value="2" c:identifier="TP_CONNECTION_CAPABILITY_FLAG_INVITE"/>
    </enumeration>
    <record name="ConnectionClass" c:type="TpConnectionClass" glib:is-gtype-struct-for="Connection" version="0.7.1">
      <doc xml:whitespace="preserve">The class of a #TpConnection. In addition to @parent_class there are four
pointers reserved for possible future use.
(Changed in 0.7.12: the layout of the structure is visible, allowing
subclassing.)</doc>
      <field name="parent_class">
        <type name="ProxyClass" c:type="TpProxyClass"/>
      </field>
      <field name="_1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_2">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_3">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_4">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
    </record>
    <callback name="ConnectionContactsByHandleCb" c:type="TpConnectionContactsByHandleCb" version="0.7.18">
      <doc xml:whitespace="preserve">Signature of a callback used to receive the result of
tp_connection_get_contacts_by_handle().
If an unrecoverable error occurs (for instance, if @connection
becomes disconnected) the whole operation fails, and no contacts or
invalid handles are returned.
If some or even all of the @handles passed to
tp_connection_get_contacts_by_handle() were not valid, this is not
considered to be a failure. @error will be %NULL in this situation,
valid (possibly none of them), and @invalid will contain the handles
that were not valid.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">The connection</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="n_contacts" transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of TpContact objects successfully created (one per valid handle), or 0 on unrecoverable errors</doc>
          <type name="uint" c:type="guint"/>
        </parameter>
        <parameter name="contacts" transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of @n_contacts TpContact objects (this callback is not given a reference to any of these objects, and must call g_object_ref() on any that it will keep), or %NULL on unrecoverable errors</doc>
          <array length="1" c:type="TpContact**">
            <type name="Contact"/>
          </array>
        </parameter>
        <parameter name="n_failed" transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of invalid handles that were passed to tp_connection_get_contacts_by_handle() (or on unrecoverable errors, the total number of handles that were given)</doc>
          <type name="uint" c:type="guint"/>
        </parameter>
        <parameter name="failed" transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of @n_failed handles that were passed to tp_connection_get_contacts_by_handle() but turned out to be invalid (or on unrecoverable errors, all the handles that were given)</doc>
          <array length="3" c:type="TpHandle*">
            <type name="Handle"/>
          </array>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">%NULL on success, or an unrecoverable error that caused everything to fail</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="6">
          <doc xml:whitespace="preserve">the @user_data that was passed to tp_connection_get_contacts_by_handle()</doc>
          <type name="any" c:type="gpointer"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <doc xml:whitespace="preserve">the @weak_object that was passed to tp_connection_get_contacts_by_handle()</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ConnectionContactsByIdCb" c:type="TpConnectionContactsByIdCb" version="0.7.18">
      <doc xml:whitespace="preserve">Signature of a callback used to receive the result of
tp_connection_get_contacts_by_id().
The normalized form of requested_ids[i] is
tp_contact_get_identifier (contacts[i]).
If some or even all of the @ids passed to
tp_connection_get_contacts_by_id() were not valid, this is not
considered to be a fatal error. @error will be %NULL in this situation,
valid (it may be empty), and @failed_id_errors will map the IDs
that were not valid to a corresponding #GError (if the connection manager
complies with the Telepathy spec, it will have domain %TP_ERRORS and code
%TP_ERROR_INVALID_HANDLE).
If an unrecoverable error occurs (for instance, if @connection
becomes disconnected) the whole operation fails, and no contacts
or requested IDs are returned. @failed_id_errors will contain all the IDs
that were requested, mapped to a corresponding #GError (either one
indicating that the ID was invalid, if that was determined before the
fatal error occurred, or a copy of @error).</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">The connection</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="n_contacts" transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of TpContact objects successfully created (one per valid ID), or 0 on unrecoverable errors</doc>
          <type name="uint" c:type="guint"/>
        </parameter>
        <parameter name="contacts" transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of @n_contacts TpContact objects (this callback is not given a reference to any of these objects, and must call g_object_ref() on any that it will keep), or %NULL on unrecoverable errors</doc>
          <array length="1" c:type="TpContact**">
            <type name="Contact"/>
          </array>
        </parameter>
        <parameter name="requested_ids" transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of @n_contacts valid IDs (JIDs, SIP URIs etc.) that were passed to tp_connection_get_contacts_by_id(), in an order corresponding to @contacts, or %NULL on unrecoverable errors</doc>
          <array length="1" c:type="gchar**">
            <type name="int8"/>
          </array>
        </parameter>
        <parameter name="failed_id_errors" transfer-ownership="none">
          <doc xml:whitespace="preserve">A hash table in which the keys are IDs and the values are errors (#GError)</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GLib.Error"/>
          </type>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">%NULL on success, or an unrecoverable error that caused everything to fail</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="6">
          <doc xml:whitespace="preserve">the @user_data that was passed to tp_connection_get_contacts_by_id()</doc>
          <type name="any" c:type="gpointer"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <doc xml:whitespace="preserve">the @weak_object that was passed to tp_connection_get_contacts_by_id()</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ConnectionHoldHandlesCb" c:type="TpConnectionHoldHandlesCb">
      <doc xml:whitespace="preserve">Signature of the callback called when tp_connection_hold_handles() succeeds
or fails.
On success, the caller has one reference to each handle in @handles, which
may be released later with tp_connection_unref_handles(). If not
released, the handles will remain valid until @connection becomes invalid
(signalled by #TpProxy::invalidated).
For convenience, the handle type and handles requested by the caller are
passed through to this callback on success, so the caller does not have to
include them in @user_data.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">the connection</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="handle_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the handle type that was passed to tp_connection_hold_handles()</doc>
          <type name="HandleType" c:type="TpHandleType"/>
        </parameter>
        <parameter name="n_handles" transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of handles that were passed to tp_connection_hold_handles() on success, or 0 on failure</doc>
          <type name="uint" c:type="guint"/>
        </parameter>
        <parameter name="handles" transfer-ownership="none">
          <doc xml:whitespace="preserve">a copy of the array of @n_handles handles that was passed to tp_connection_hold_handles() on success, or %NULL on failure</doc>
          <type name="Handle" c:type="TpHandle*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">%NULL on success, or an error on failure</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="5">
          <doc xml:whitespace="preserve">the same arbitrary pointer that was passed to tp_connection_hold_handles()</doc>
          <type name="any" c:type="gpointer"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <doc xml:whitespace="preserve">the same object that was passed to tp_connection_hold_handles()</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <class name="ConnectionManager" c:type="TpConnectionManager" version="0.7.1" parent="Proxy" glib:type-name="TpConnectionManager" glib:get-type="tp_connection_manager_get_type" glib:type-struct="ConnectionManagerClass">
      <doc xml:whitespace="preserve">A proxy object for a Telepathy connection manager.
This might represent a connection manager which is currently running
(in which case it can be introspected) or not (in which case its
capabilities can be read from .manager files in the filesystem).
Accordingly, this object never emits #TpProxy::invalidated unless all
references to it are discarded.
Various fields and methods on this object do not work until
%TP_CONNECTION_MANAGER_FEATURE_CORE is prepared. Use
tp_proxy_prepare_async() to wait for this to happen.
Note that the @protocols may be freed and reallocated (based on new
information) whenever the main loop is entered. Since 0.11.3, each protocol
struct can be copied with tp_connection_manager_protocol_copy() if a
private copy is needed.</doc>
      <constructor name="new" c:identifier="tp_connection_manager_new" throws="1">
        <doc xml:whitespace="preserve">Convenience function to create a new connection manager proxy. If
its protocol and parameter information are required, you should call
tp_connection_manager_call_when_ready() on the result.
is set.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new reference to a connection manager proxy, or %NULL if @error</doc>
          <type name="ConnectionManager" c:type="TpConnectionManager*"/>
        </return-value>
        <parameters>
          <parameter name="dbus" transfer-ownership="none">
            <doc xml:whitespace="preserve">Proxy for the D-Bus daemon</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">The connection manager name (such as "gabble")</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="manager_filename" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">manager-file property, which may (and generally should) be %NULL.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="check_valid_name" c:identifier="tp_connection_manager_check_valid_name" version="0.7.1" throws="1">
        <doc xml:whitespace="preserve">Check that the given string is a valid connection manager name, i.e. that
it consists entirely of ASCII letters, digits and underscores, and starts
with a letter.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @name is valid</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a possible connection manager name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="check_valid_protocol_name" c:identifier="tp_connection_manager_check_valid_protocol_name" version="0.7.1" throws="1">
        <doc xml:whitespace="preserve">Check that the given string is a valid protocol name, i.e. that
it consists entirely of ASCII letters, digits and hyphen/minus, and starts
with a letter.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @name is valid</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a possible protocol name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="init_known_interfaces" c:identifier="tp_connection_manager_init_known_interfaces" version="0.7.32">
        <doc xml:whitespace="preserve">Ensure that the known interfaces for TpConnectionManager have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_CONNECTION_MANAGER.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <function name="get_feature_quark_core" c:identifier="tp_connection_manager_get_feature_quark_core">
        <return-value transfer-ownership="full">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <method name="activate" c:identifier="tp_connection_manager_activate" version="0.7.1" introspectable="0">
        <doc xml:whitespace="preserve">Attempt to run and introspect the connection manager, asynchronously.
Since 0.7.26 this function is not generally very useful, since
the connection manager will now be activated automatically if necessary.
If the CM was already running, do nothing and return %FALSE.
On success, emit #TpConnectionManager::activated when the CM appears
on the bus, and #TpConnectionManager::got-info when its capabilities
have been (re-)discovered.
On failure, emit #TpConnectionManager::exited without first emitting
activated.
if the connection manager was already running and no additional signals
will be emitted.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if activation was needed and is now in progress, %FALSE</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="call_when_ready" c:identifier="tp_connection_manager_call_when_ready" version="0.7.26" introspectable="0">
        <doc xml:whitespace="preserve">Call the @callback from the main loop when information about @cm's
supported protocols and parameters has been retrieved.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback" transfer-ownership="none" scope="notified" closure="2" destroy="3">
            <doc xml:whitespace="preserve">callback to call when information has been retrieved or on error</doc>
            <type name="ConnectionManagerWhenReadyCb" c:type="TpConnectionManagerWhenReadyCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary data to pass to the callback</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="call">
            <doc xml:whitespace="preserve">called to destroy @user_data</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object" transfer-ownership="none">
            <doc xml:whitespace="preserve">object to reference weakly; if it is destroyed, @callback will not be called, but @destroy will still be called</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_name" c:identifier="tp_connection_manager_get_name" version="0.7.26">
        <doc xml:whitespace="preserve">Return the internal name of this connection manager in the Telepathy
D-Bus API, e.g. "gabble" or "haze". This is often the name of the binary
without the "telepathy-" prefix.
The returned string is valid as long as @self is. Copy it with g_strdup()
if a longer lifetime is required.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #TpConnectionManager:connection-manager property</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="is_ready" c:identifier="tp_connection_manager_is_ready" version="0.7.26" introspectable="0">
        <doc xml:whitespace="preserve">If protocol and parameter information has been obtained from the connection
manager or the cache in the .manager file, return %TRUE. Otherwise,
return %FALSE.
This may change from %FALSE to %TRUE at any time that the main loop is
running; the #GObject::notify signal is emitted for the
#TpConnectionManager:info-source property.
%TP_CM_INFO_SOURCE_NONE</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE, unless the #TpConnectionManager:info-source property is</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_running" c:identifier="tp_connection_manager_is_running" version="0.7.26">
        <doc xml:whitespace="preserve">Return %TRUE if this connection manager currently appears to be running.
This may change at any time that the main loop is running; the
#TpConnectionManager::activated and #TpConnectionManager::exited signals
are emitted.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">whether the connection manager is currently running</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_info_source" c:identifier="tp_connection_manager_get_info_source" version="0.7.26">
        <doc xml:whitespace="preserve">If protocol and parameter information has been obtained from the connection
manager, return %TP_CM_INFO_SOURCE_LIVE; if it has been obtained from the
cache in the .manager file, return %TP_CM_INFO_SOURCE_FILE. If this
information has not yet been obtained, or obtaining it failed, return
%TP_CM_INFO_SOURCE_NONE.
This may increase at any time that the main loop is running; the
#GObject::notify signal is emitted.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the value of the #TpConnectionManager:info-source property</doc>
          <type name="CMInfoSource" c:type="TpCMInfoSource"/>
        </return-value>
      </method>
      <method name="dup_protocol_names" c:identifier="tp_connection_manager_dup_protocol_names" version="0.7.26">
        <doc xml:whitespace="preserve">Returns a list of protocol names supported by this connection manager.
These are the internal protocol names used by the Telepathy specification
(e.g. "jabber" and "msn"), rather than user-visible names in any particular
locale.
If this function is called before the connection manager information has
been obtained, the result is always %NULL. Use
tp_connection_manager_call_when_ready() to wait for this.
The result is copied and must be freed by the caller, but it is not
necessarily still true after the main loop is re-entered.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GStrv of protocol names</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="has_protocol" c:identifier="tp_connection_manager_has_protocol" version="0.7.26">
        <doc xml:whitespace="preserve">Return whether @protocol is supported by this connection manager.
If this function is called before the connection manager information has
been obtained, the result is always %FALSE. Use
tp_connection_manager_call_when_ready() to wait for this.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if this connection manager supports @protocol</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="protocol" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a protocol as defined in the Telepathy D-Bus API, e.g. "jabber" or "msn"</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_protocol" c:identifier="tp_connection_manager_get_protocol" version="0.7.26">
        <doc xml:whitespace="preserve">Returns a structure representing a protocol, or %NULL if this connection
manager does not support the specified protocol.
Since 0.11.11, you can get a #GObject version with more
functionality by calling tp_connection_manager_get_protocol_object().
If this function is called before the connection manager information has
been obtained, the result is always %NULL. Use
tp_connection_manager_call_when_ready() to wait for this.
The result is not necessarily valid after the main loop is re-entered.
Since 0.11.3, it can be copied with tp_connection_manager_protocol_copy()
if a permanently-valid copy is needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a structure representing the protocol</doc>
          <type name="ConnectionManagerProtocol" c:type="TpConnectionManagerProtocol*"/>
        </return-value>
        <parameters>
          <parameter name="protocol" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a protocol as defined in the Telepathy D-Bus API, e.g. "jabber" or "msn"</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_protocol_object" c:identifier="tp_connection_manager_get_protocol_object" version="0.11.11">
        <doc xml:whitespace="preserve">Returns an object representing a protocol, or %NULL if this connection
manager does not support the specified protocol.
If this function is called before the connection manager information has
been obtained, the result is always %NULL. Use tp_proxy_prepare_async()
to wait for this.
The result should be referenced with g_object_ref() if it will be kept.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">an object representing the protocol, or %NULL</doc>
          <type name="Protocol" c:type="TpProtocol*"/>
        </return-value>
        <parameters>
          <parameter name="protocol" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a protocol as defined in the Telepathy D-Bus API, e.g. "jabber" or "msn"</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <property name="always-introspect" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">If %TRUE, always introspect the connection manager as it comes online,
even if we already have its info from a .manager file. Default %FALSE.</doc>
        <type name="boolean" c:type="gboolean"/>
      </property>
      <property name="connection-manager" transfer-ownership="none">
        <doc xml:whitespace="preserve">The name of the connection manager, e.g. "gabble" (read-only).</doc>
        <type name="utf8" c:type="gchararray"/>
      </property>
      <property name="info-source" transfer-ownership="none">
        <doc xml:whitespace="preserve">Where we got the current information on supported protocols
(a #TpCMInfoSource).
Since 0.7.26, the #GObject::notify signal is emitted for this
property.
(Note that this is of type %G_TYPE_UINT, not %TP_TYPE_CM_INFO_SOURCE,
for historical reasons.)</doc>
        <type name="uint" c:type="guint"/>
      </property>
      <property name="manager-file" writable="1" construct="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The absolute path of the .manager file. If set to %NULL (the default),
the XDG data directories will be searched for a .manager file of the
correct name.
If set to the empty string, no .manager file will be read.</doc>
        <type name="utf8" c:type="gchararray"/>
      </property>
      <field name="parent">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="name">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="protocols">
        <type name="ConnectionManagerProtocol" c:type="TpConnectionManagerProtocol**"/>
      </field>
      <field name="running" bits="1">
        <type name="uint" c:type="unsigned"/>
      </field>
      <field name="always_introspect" bits="1">
        <type name="uint" c:type="unsigned"/>
      </field>
      <field name="info_source" bits="2">
        <type name="uint" c:type="unsigned"/>
      </field>
      <field name="reserved_flags" bits="28">
        <type name="uint" c:type="guint"/>
      </field>
      <field name="priv">
        <type name="ConnectionManagerPrivate" c:type="TpConnectionManagerPrivate*"/>
      </field>
      <glib:signal name="activated">
        <doc xml:whitespace="preserve">Emitted when the connection manager's well-known name appears on the bus.</doc>
        <return-value transfer-ownership="full">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="exited">
        <doc xml:whitespace="preserve">Emitted when the connection manager's well-known name disappears from
the bus or when activation fails.</doc>
        <return-value transfer-ownership="full">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="got-info">
        <doc xml:whitespace="preserve">Emitted when the connection manager's capabilities have been discovered.
This signal is not very helpful. Since 0.7.26, using
tp_connection_manager_call_when_ready() instead is recommended.</doc>
        <return-value transfer-ownership="full">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="source" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpCMInfoSource</doc>
            <type name="uint" c:type="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ConnectionManagerClass" c:type="TpConnectionManagerClass" glib:is-gtype-struct-for="ConnectionManager" version="0.7.1">
      <doc xml:whitespace="preserve">The class of a #TpConnectionManager.</doc>
      <field name="parent_class">
        <type name="ProxyClass" c:type="TpProxyClass"/>
      </field>
      <field name="priv">
        <type name="any" c:type="gpointer*"/>
      </field>
    </record>
    <callback name="ConnectionManagerListCb" c:type="TpConnectionManagerListCb" version="0.7.1">
      <doc xml:whitespace="preserve">Signature of the callback supplied to tp_list_connection_managers().
Since 0.11.3, tp_list_connection_managers() will
wait for %TP_CONNECTION_MANAGER_FEATURE_CORE to be prepared on each
connection manager passed to @callback, unless an error occurred while
launching that connection manager.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cms" transfer-ownership="none">
          <doc xml:whitespace="preserve">%NULL-terminated array of #TpConnectionManager (the objects will be unreferenced and the array will be freed after the callback returns, so the callback must reference any CMs it stores a pointer to), or %NULL on error</doc>
          <array c:type="TpConnectionManager**">
            <type name="ConnectionManager"/>
          </array>
        </parameter>
        <parameter name="n_cms" transfer-ownership="none">
          <doc xml:whitespace="preserve">number of connection managers in @cms (not including the final %NULL)</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">%NULL on success, or an error that occurred</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <doc xml:whitespace="preserve">user-supplied data</doc>
          <type name="any" c:type="gpointer"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <doc xml:whitespace="preserve">user-supplied weakly referenced object</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="ConnectionManagerParam" c:type="TpConnectionManagerParam" version="0.7.1" glib:type-name="TpConnectionManagerParam" glib:get-type="tp_connection_manager_param_get_type">
      <doc xml:whitespace="preserve">Structure representing a connection manager parameter.</doc>
      <field name="name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="dbus_signature" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="default_value" writable="1">
        <type name="GObject.Value" c:type="GValue"/>
      </field>
      <field name="flags" writable="1">
        <type name="uint" c:type="guint"/>
      </field>
      <field name="priv" writable="1">
        <type name="any" c:type="gpointer"/>
      </field>
      <method name="get_name" c:identifier="tp_connection_manager_param_get_name" version="0.7.26">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the parameter</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_dbus_signature" c:identifier="tp_connection_manager_param_get_dbus_signature" version="0.7.26">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the D-Bus signature of the parameter</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="is_required" c:identifier="tp_connection_manager_param_is_required" version="0.7.26">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the parameter is normally required</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_required_for_registration" c:identifier="tp_connection_manager_param_is_required_for_registration" version="0.7.26">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;
(by setting the special "register" parameter to %TRUE)</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the parameter is required when registering a new account</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_secret" c:identifier="tp_connection_manager_param_is_secret" version="0.7.26">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the parameter's value is a password or other secret</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_dbus_property" c:identifier="tp_connection_manager_param_is_dbus_property" version="0.7.26">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the parameter represents a D-Bus property of the same name</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_default" c:identifier="tp_connection_manager_param_get_default" version="0.7.26">
        <doc xml:whitespace="preserve">Get the default value for this parameter, if there is one. If %FALSE is
returned, @value is left uninitialized.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if there is a default value</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">pointer to an unset (all zeroes) #GValue into which the default's type and value are written</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="tp_connection_manager_param_copy" version="0.11.3">
        <doc xml:whitespace="preserve">&lt;!-- Returns: says it all --&gt;
tp_connection_manager_param_free()</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly (slice) allocated #TpConnectionManagerParam, free with</doc>
          <type name="ConnectionManagerParam" c:type="TpConnectionManagerParam*"/>
        </return-value>
      </method>
      <method name="free" c:identifier="tp_connection_manager_param_free" version="0.11.3">
        <doc xml:whitespace="preserve">Frees @param, which was copied with tp_connection_manager_param_copy().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <record name="ConnectionManagerPrivate" c:type="TpConnectionManagerPrivate">
    </record>
    <record name="ConnectionManagerProtocol" c:type="TpConnectionManagerProtocol" version="0.7.1" glib:type-name="TpConnectionManagerProtocol" glib:get-type="tp_connection_manager_protocol_get_type">
      <doc xml:whitespace="preserve">Structure representing a protocol supported by a connection manager.
Note that the size of this structure may change, so its size must not be
relied on.</doc>
      <field name="name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="params" writable="1">
        <type name="ConnectionManagerParam" c:type="TpConnectionManagerParam*"/>
      </field>
      <field name="priv" writable="1">
        <type name="any" c:type="gpointer"/>
      </field>
      <method name="dup_param_names" c:identifier="tp_connection_manager_protocol_dup_param_names" version="0.7.26">
        <doc xml:whitespace="preserve">Returns a list of parameter names supported by this connection manager
for this protocol.
The result is copied and must be freed by the caller with g_strfreev().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GStrv of protocol names</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="has_param" c:identifier="tp_connection_manager_protocol_has_param" version="0.7.26">
        <doc xml:whitespace="preserve">&lt;!-- no more to say --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @protocol supports the parameter @param.</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="param" transfer-ownership="none">
            <doc xml:whitespace="preserve">a parameter name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_param" c:identifier="tp_connection_manager_protocol_get_param" version="0.7.26">
        <doc xml:whitespace="preserve">&lt;!-- no more to say --&gt;
supported</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a structure representing the parameter @param, or %NULL if not</doc>
          <type name="ConnectionManagerParam" c:type="TpConnectionManagerParam*"/>
        </return-value>
        <parameters>
          <parameter name="param" transfer-ownership="none">
            <doc xml:whitespace="preserve">a parameter name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="can_register" c:identifier="tp_connection_manager_protocol_can_register" version="0.7.26">
        <doc xml:whitespace="preserve">Return whether a new account can be registered on this protocol, by setting
the special "register" parameter to %TRUE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @protocol supports the parameter "register"</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="copy" c:identifier="tp_connection_manager_protocol_copy" version="0.11.3">
        <doc xml:whitespace="preserve">&lt;!-- Returns: says it all --&gt;
tp_connection_manager_protocol_free()</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly (slice) allocated #TpConnectionManagerProtocol, free with</doc>
          <type name="ConnectionManagerProtocol" c:type="TpConnectionManagerProtocol*"/>
        </return-value>
      </method>
      <method name="free" c:identifier="tp_connection_manager_protocol_free" version="0.11.3">
        <doc xml:whitespace="preserve">Frees @proto, which was copied with tp_connection_manager_protocol_copy().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <callback name="ConnectionManagerWhenReadyCb" c:type="TpConnectionManagerWhenReadyCb">
      <doc xml:whitespace="preserve">Called as the result of tp_connection_manager_call_when_ready(). If the
connection manager's protocol and parameter information could be retrieved,
non-%NULL and @cm is not ready.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cm" transfer-ownership="none">
          <doc xml:whitespace="preserve">a connection manager</doc>
          <type name="ConnectionManager" c:type="TpConnectionManager*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">%NULL on success, or the reason why tp_connection_manager_is_ready() would return %FALSE</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">the @user_data passed to tp_connection_manager_call_when_ready()</doc>
          <type name="any" c:type="gpointer"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <doc xml:whitespace="preserve">the @weak_object passed to tp_connection_manager_call_when_ready()</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ConnectionNameListCb" c:type="TpConnectionNameListCb" version="0.7.1">
      <doc xml:whitespace="preserve">Signature of the callback supplied to tp_list_connection_names().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="names" transfer-ownership="none">
          <doc xml:whitespace="preserve">%NULL-terminated array of @n connection bus names, or %NULL on error</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:whitespace="preserve">number of names (not including the final %NULL), or 0 on error</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="cms" transfer-ownership="none">
          <doc xml:whitespace="preserve">%NULL-terminated array of @n connection manager names (e.g. "gabble") in the same order as @names, or %NULL on error</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </parameter>
        <parameter name="protocols" transfer-ownership="none">
          <doc xml:whitespace="preserve">%NULL-terminated array of same order as @names, or %NULL on error</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">%NULL on success, or an error that occurred</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="5">
          <doc xml:whitespace="preserve">user-supplied data</doc>
          <type name="any" c:type="gpointer"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <doc xml:whitespace="preserve">user-supplied weakly referenced object</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="ConnectionPresenceType" c:type="TpConnectionPresenceType">
      <member name="unset" value="0" c:identifier="TP_CONNECTION_PRESENCE_TYPE_UNSET"/>
      <member name="offline" value="1" c:identifier="TP_CONNECTION_PRESENCE_TYPE_OFFLINE"/>
      <member name="available" value="2" c:identifier="TP_CONNECTION_PRESENCE_TYPE_AVAILABLE"/>
      <member name="away" value="3" c:identifier="TP_CONNECTION_PRESENCE_TYPE_AWAY"/>
      <member name="extended_away" value="4" c:identifier="TP_CONNECTION_PRESENCE_TYPE_EXTENDED_AWAY"/>
      <member name="hidden" value="5" c:identifier="TP_CONNECTION_PRESENCE_TYPE_HIDDEN"/>
      <member name="busy" value="6" c:identifier="TP_CONNECTION_PRESENCE_TYPE_BUSY"/>
      <member name="unknown" value="7" c:identifier="TP_CONNECTION_PRESENCE_TYPE_UNKNOWN"/>
      <member name="error" value="8" c:identifier="TP_CONNECTION_PRESENCE_TYPE_ERROR"/>
    </enumeration>
    <record name="ConnectionPrivate" c:type="TpConnectionPrivate">
    </record>
    <callback name="ConnectionRequestHandlesCb" c:type="TpConnectionRequestHandlesCb">
      <doc xml:whitespace="preserve">Signature of the callback called when tp_connection_request_handles()
succeeds or fails.
On success, the caller has one reference to each handle in @handles, which
may be released later with tp_connection_unref_handles(). If not
released, the handles will remain valid until @connection becomes invalid
(signalled by TpProxy::invalidated).
For convenience, the handle type and IDs requested by the caller are
passed through to this callback, so the caller does not have to include
them in @user_data.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">the connection</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="handle_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the handle type that was passed to tp_connection_request_handles()</doc>
          <type name="HandleType" c:type="TpHandleType"/>
        </parameter>
        <parameter name="n_handles" transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of IDs that were passed to tp_connection_request_handles() on success, or 0 on failure</doc>
          <type name="uint" c:type="guint"/>
        </parameter>
        <parameter name="handles" transfer-ownership="none">
          <doc xml:whitespace="preserve">the @n_handles handles corresponding to @ids, in the same order, or %NULL on failure</doc>
          <array length="2" c:type="TpHandle*">
            <type name="uint"/>
          </array>
        </parameter>
        <parameter name="ids" transfer-ownership="none">
          <doc xml:whitespace="preserve">a copy of the array of @n_handles IDs that was passed to tp_connection_request_handles() on success, or %NULL on failure</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">%NULL on success, or an error on failure</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="6">
          <doc xml:whitespace="preserve">the same arbitrary pointer that was passed to tp_connection_request_handles()</doc>
          <type name="any" c:type="gpointer"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <doc xml:whitespace="preserve">the same object that was passed to tp_connection_request_handles()</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="ConnectionStatus" c:type="TpConnectionStatus">
      <member name="connected" value="0" c:identifier="TP_CONNECTION_STATUS_CONNECTED"/>
      <member name="connecting" value="1" c:identifier="TP_CONNECTION_STATUS_CONNECTING"/>
      <member name="disconnected" value="2" c:identifier="TP_CONNECTION_STATUS_DISCONNECTED"/>
    </enumeration>
    <enumeration name="ConnectionStatusReason" c:type="TpConnectionStatusReason">
      <member name="none_specified" value="0" c:identifier="TP_CONNECTION_STATUS_REASON_NONE_SPECIFIED"/>
      <member name="requested" value="1" c:identifier="TP_CONNECTION_STATUS_REASON_REQUESTED"/>
      <member name="network_error" value="2" c:identifier="TP_CONNECTION_STATUS_REASON_NETWORK_ERROR"/>
      <member name="authentication_failed" value="3" c:identifier="TP_CONNECTION_STATUS_REASON_AUTHENTICATION_FAILED"/>
      <member name="encryption_error" value="4" c:identifier="TP_CONNECTION_STATUS_REASON_ENCRYPTION_ERROR"/>
      <member name="name_in_use" value="5" c:identifier="TP_CONNECTION_STATUS_REASON_NAME_IN_USE"/>
      <member name="cert_not_provided" value="6" c:identifier="TP_CONNECTION_STATUS_REASON_CERT_NOT_PROVIDED"/>
      <member name="cert_untrusted" value="7" c:identifier="TP_CONNECTION_STATUS_REASON_CERT_UNTRUSTED"/>
      <member name="cert_expired" value="8" c:identifier="TP_CONNECTION_STATUS_REASON_CERT_EXPIRED"/>
      <member name="cert_not_activated" value="9" c:identifier="TP_CONNECTION_STATUS_REASON_CERT_NOT_ACTIVATED"/>
      <member name="cert_hostname_mismatch" value="10" c:identifier="TP_CONNECTION_STATUS_REASON_CERT_HOSTNAME_MISMATCH"/>
      <member name="cert_fingerprint_mismatch" value="11" c:identifier="TP_CONNECTION_STATUS_REASON_CERT_FINGERPRINT_MISMATCH"/>
      <member name="cert_self_signed" value="12" c:identifier="TP_CONNECTION_STATUS_REASON_CERT_SELF_SIGNED"/>
      <member name="cert_other_error" value="13" c:identifier="TP_CONNECTION_STATUS_REASON_CERT_OTHER_ERROR"/>
      <member name="cert_revoked" value="14" c:identifier="TP_CONNECTION_STATUS_REASON_CERT_REVOKED"/>
      <member name="cert_insecure" value="15" c:identifier="TP_CONNECTION_STATUS_REASON_CERT_INSECURE"/>
      <member name="cert_limit_exceeded" value="16" c:identifier="TP_CONNECTION_STATUS_REASON_CERT_LIMIT_EXCEEDED"/>
    </enumeration>
    <callback name="ConnectionUpgradeContactsCb" c:type="TpConnectionUpgradeContactsCb" version="0.7.18">
      <doc xml:whitespace="preserve">Signature of a callback used to receive the result of
tp_connection_upgrade_contacts().
If an unrecoverable error occurs (for instance, if @connection becomes
disconnected) it is indicated by @error, but the contacts in @contacts
are still provided.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">The connection</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="n_contacts" transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of TpContact objects for which an upgrade was requested</doc>
          <type name="uint" c:type="guint"/>
        </parameter>
        <parameter name="contacts" transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of @n_contacts TpContact objects (this callback is not given an extra reference to any of these objects, and must call g_object_ref() on any that it will keep)</doc>
          <type name="Contact" c:type="TpContact**"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">An unrecoverable error, or %NULL if the connection remains valid</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="4">
          <doc xml:whitespace="preserve">the @user_data that was passed to tp_connection_upgrade_contacts()</doc>
          <type name="any" c:type="gpointer"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <doc xml:whitespace="preserve">the @weak_object that was passed to tp_connection_upgrade_contacts()</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ConnectionWhenReadyCb" c:type="TpConnectionWhenReadyCb">
      <doc xml:whitespace="preserve">Signature of a callback passed to tp_connection_call_when_ready(), which
will be called exactly once, when the connection becomes ready or
invalid (whichever happens first)</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">the connection (which may be in the middle of being disposed, if error is non-%NULL, error-&gt;domain is TP_DBUS_ERRORS and error-&gt;code is TP_DBUS_ERROR_PROXY_UNREFERENCED)</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">%NULL if the connection is ready for use, or the error with which it was invalidated if it is now invalid</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">whatever was passed to tp_connection_call_when_ready()</doc>
          <type name="any" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="Contact" c:type="TpContact" version="0.7.18" parent="GObject.Object" glib:type-name="TpContact" glib:get-type="tp_contact_get_type" glib:type-struct="ContactClass">
      <doc xml:whitespace="preserve">An object representing a contact on a #TpConnection.
Contact objects support tracking a number of attributes of contacts, as
described by the #TpContactFeature flags. Features can be specified when
instantiating contact objects (with tp_connection_get_contacts_by_id() or
tp_connection_get_contacts_by_handle()), or added to an existing contact
object with tp_connection_upgrade_contacts(). For example, a client wishing
to keep track of a contact's alias would set #TP_CONTACT_FEATURE_ALIAS, and
then listen for the "notify::alias" signal, emitted whenever the
#TpContact:alias property changes.
Note that releasing a #TpContact object might release handle references
held by calling tp_cli_connection_call_request_handles(),
tp_cli_connection_run_request_handles(),
tp_cli_connection_call_hold_handles(),
tp_cli_connection_run_hold_handles(),
tp_cli_connection_interface_contacts_call_get_contact_attributes() or
tp_cli_connection_interface_contacts_run_get_contact_attributes() directly.
Those functions should be avoided in favour of using #TpContact,
tp_connection_hold_handles(), tp_connection_request_handles() and
tp_connection_get_contact_attributes().</doc>
      <function name="info_spec_list_copy" c:identifier="tp_contact_info_spec_list_copy" introspectable="0">
        <return-value transfer-ownership="full">
          <type name="GLib.List" c:type="GList*">
            <type name="any" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <type name="GLib.List" c:type="GList*">
              <type name="any" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="info_spec_list_free" c:identifier="tp_contact_info_spec_list_free" introspectable="0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <type name="GLib.List" c:type="GList*">
              <type name="any" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="info_list_copy" c:identifier="tp_contact_info_list_copy" introspectable="0">
        <return-value transfer-ownership="full">
          <type name="GLib.List" c:type="GList*">
            <type name="any" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <type name="GLib.List" c:type="GList*">
              <type name="any" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="info_list_free" c:identifier="tp_contact_info_list_free" introspectable="0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <type name="GLib.List" c:type="GList*">
              <type name="any" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <method name="get_connection" c:identifier="tp_contact_get_connection" version="0.7.18">
        <doc xml:whitespace="preserve">&lt;!-- nothing more to say --&gt;
(it must be referenced with g_object_ref if it must remain valid
longer than the contact)</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">connection</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </return-value>
      </method>
      <method name="get_handle" c:identifier="tp_contact_get_handle" version="0.7.18">
        <doc xml:whitespace="preserve">Return the contact's handle, which is of type %TP_HANDLE_TYPE_CONTACT,
or 0 if the #TpContact:connection has become invalid.
This handle is referenced using the Telepathy D-Bus API and remains
referenced for as long as @self exists and the
#TpContact:connection remains valid.
However, the caller of this function does not gain an additional reference
to the handle.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the same handle as the #TpContact:handle property</doc>
          <type name="Handle" c:type="TpHandle"/>
        </return-value>
      </method>
      <method name="get_identifier" c:identifier="tp_contact_get_identifier" version="0.7.18">
        <doc xml:whitespace="preserve">Return the contact's identifier. This remains valid for as long as @self
exists; if the caller requires a string that will persist for longer than
that, it must be copied with g_strdup().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same non-%NULL identifier as the #TpContact:identifier property</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="has_feature" c:identifier="tp_contact_has_feature" version="0.7.18">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @self has been set up to track the feature @feature</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:whitespace="preserve">a desired feature</doc>
            <type name="ContactFeature" c:type="TpContactFeature"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_alias" c:identifier="tp_contact_get_alias" version="0.7.18">
        <doc xml:whitespace="preserve">Return the contact's alias. This remains valid until the main loop
is re-entered; if the caller requires a string that will persist for
longer than that, it must be copied with g_strdup().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same non-%NULL alias as the #TpContact:alias</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_avatar_token" c:identifier="tp_contact_get_avatar_token" version="0.7.18">
        <doc xml:whitespace="preserve">Return the contact's avatar token. This remains valid until the main loop
is re-entered; if the caller requires a string that will persist for
longer than that, it must be copied with g_strdup().
(possibly %NULL)</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same token as the #TpContact:avatar-token property</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_presence_type" c:identifier="tp_contact_get_presence_type" version="0.7.18">
        <doc xml:whitespace="preserve">If this object has been set up to track %TP_CONTACT_FEATURE_PRESENCE
and the underlying connection supports either the Presence or
SimplePresence interfaces, return the type of the contact's presence.
Otherwise, return %TP_CONNECTION_PRESENCE_TYPE_UNSET.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the same presence type as the #TpContact:presence-type property</doc>
          <type name="ConnectionPresenceType" c:type="TpConnectionPresenceType"/>
        </return-value>
      </method>
      <method name="get_presence_status" c:identifier="tp_contact_get_presence_status" version="0.7.18">
        <doc xml:whitespace="preserve">Return the name of the contact's presence status, or an empty string.
This remains valid until the main loop is re-entered; if the caller
requires a string that will persist for longer than that, it must be
copied with g_strdup().
property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same non-%NULL status name as the #TpContact:presence-status</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_presence_message" c:identifier="tp_contact_get_presence_message" version="0.7.18">
        <doc xml:whitespace="preserve">Return the contact's user-defined status message, or an empty string.
This remains valid until the main loop is re-entered; if the caller
requires a string that will persist for longer than that, it must be
copied with g_strdup().
property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same non-%NULL message as the #TpContact:presence-message</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_location" c:identifier="tp_contact_get_location" version="0.11.1">
        <doc xml:whitespace="preserve">Return the contact's user-defined location or %NULL if the location is
unspecified.
This remains valid until the main loop is re-entered; if the caller
requires a hash table that will persist for longer than that, it must be
reffed with g_hash_table_ref().
#GHashTable (or %NULL) as the #TpContact:location property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </return-value>
      </method>
      <method name="get_capabilities" c:identifier="tp_contact_get_capabilities" version="0.11.3">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;
#TpContact:capabilities property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same #TpCapabilities (or %NULL) as the</doc>
          <type name="Capabilities" c:type="TpCapabilities*"/>
        </return-value>
      </method>
      <method name="get_avatar_file" c:identifier="tp_contact_get_avatar_file" version="0.11.6">
        <doc xml:whitespace="preserve">Return the contact's avatar file. This remains valid until the main loop
is re-entered; if the caller requires a #GFile that will persist for
longer than that, it must be reffed with g_object_ref().
(possibly %NULL)</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">avatar-file property</doc>
          <type name="Gio.File" c:type="GFile*"/>
        </return-value>
      </method>
      <method name="get_avatar_mime_type" c:identifier="tp_contact_get_avatar_mime_type" version="0.11.6">
        <doc xml:whitespace="preserve">Return the contact's avatar MIME type. This remains valid until the main loop
is re-entered; if the caller requires a string that will persist for
longer than that, it must be copied with g_strdup().
(possibly %NULL)</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same MIME type as the #TpContact:avatar-mime-type property</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_contact_info" c:identifier="tp_contact_get_contact_info" version="0.11.7">
        <doc xml:whitespace="preserve">Returns a newly allocated #GList of contact's vCard fields. The list must be
freed with g_list_free() after used.
Note that the #TpContactInfoField&lt;!-- --&gt;s in the returned #GList are not
dupped before returning from this function. One could copy every item in the
list using tp_contact_info_field_copy().
Same as the #TpContact:contact-info property.
a #GList of #TpContactInfoField, or %NULL if the feature is not yet
prepared.</doc>
        <return-value transfer-ownership="container">
          <type name="GLib.List" c:type="GList*">
            <type name="TelepathyGLib.ContactInfoField"/>
          </type>
        </return-value>
      </method>
      <method name="request_contact_info_async" c:identifier="tp_contact_request_contact_info_async" version="0.11.7">
        <doc xml:whitespace="preserve">Requests an asynchronous request of the contact info of @self. When
the operation is finished, @callback will be called. You can then call
tp_contact_request_contact_info_finish() to get the result of the operation.
If the operation is successful, the #TpContact:contact-info property will be
updated (emitting "notify::contact-info" signal) before @callback is called.
That means you can call tp_contact_get_contact_info() to get the new vCard
inside @callback.
Note that requesting the vCard from the network can take significant time, so
a bigger timeout is set on the underlying D-Bus call. @cancellable can be
cancelled to free resources used in the D-Bus call if the caller is no longer
interested in the vCard.
If %TP_CONTACT_FEATURE_CONTACT_INFO is not yet set on @self, it will be
set before its property gets updated and @callback is called.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cancellable" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="async" closure="3">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_contact_info_finish" c:identifier="tp_contact_request_contact_info_finish" version="0.11.7" throws="1">
        <doc xml:whitespace="preserve">Finishes an async request of @self info. If the operation was successful,
the contact's vCard can be accessed using tp_contact_get_contact_info().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the request call was successful, otherwise %FALSE</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="alias" transfer-ownership="none">
        <doc xml:whitespace="preserve">The contact's alias if available, falling back to their
#TpContact:identifier if no alias is available or if the #TpContact has
not been set up to track %TP_CONTACT_FEATURE_ALIAS.
This alias may have been supplied by the contact themselves, or by the
local user, so it does not necessarily unambiguously identify the contact.
However, it is suitable for use as a main "display name" for the contact.
This is never %NULL for contact objects that are visible to library-user
code.</doc>
        <type name="utf8" c:type="gchararray"/>
      </property>
      <property name="avatar-file" version="0.11.6" transfer-ownership="none">
        <doc xml:whitespace="preserve">#GFile to the latest cached avatar image, or %NULL if this contact has
no avatar, or if the avatar data is not yet retrieved.
When #TpContact:avatar-token changes, this property is not updated
immediately, but will be updated when the new avatar data is retrieved and
stored in cache. Until then, the file will keep its old value of the latest
cached avatar image.
This is set to %NULL if %TP_CONTACT_FEATURE_AVATAR_DATA is not set on this
contact. Note that setting %TP_CONTACT_FEATURE_AVATAR_DATA will also
implicitly set %TP_CONTACT_FEATURE_AVATAR_TOKEN.</doc>
        <type name="Gio.File" c:type="GFile"/>
      </property>
      <property name="avatar-mime-type" version="0.11.6" transfer-ownership="none">
        <doc xml:whitespace="preserve">MIME type of the latest cached avatar image, or %NULL if this contact has
no avatar, or if the avatar data is not yet retrieved.
This is always the MIME type of the image given by #TpContact:avatar-file.</doc>
        <type name="utf8" c:type="gchararray"/>
      </property>
      <property name="avatar-token" transfer-ownership="none">
        <doc xml:whitespace="preserve">An opaque string representing state of the contact's avatar (depending on
the protocol, this might be a hash, a timestamp or something else), or
an empty string if there is no avatar.
This may be %NULL if it is not known whether this contact has an avatar
or not (either for network protocol reasons, or because this #TpContact
has not been set up to track %TP_CONTACT_FEATURE_AVATAR_TOKEN).</doc>
        <type name="utf8" c:type="gchararray"/>
      </property>
      <property name="capabilities" version="0.11.3" transfer-ownership="none">
        <doc xml:whitespace="preserve">The capabilities supported by this contact. If the underlying Connection
doesn't support the ContactCapabilities interface, this property will
contain the capabilities supported by the connection.
Use tp_capabilities_is_specific_to_contact() to check if the capabilities
are specific to this #TpContact or not.
This may be %NULL if this #TpContact object has not been set up to track
%TP_CONTACT_FEATURE_CAPABILITIES.</doc>
        <type name="Capabilities" c:type="TpCapabilities"/>
      </property>
      <property name="connection" transfer-ownership="none">
        <doc xml:whitespace="preserve">The #TpConnection to which this contact belongs.</doc>
        <type name="Connection" c:type="TpConnection"/>
      </property>
      <property name="contact-info" version="0.11.7" transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GList of #TpContactInfoField representing the vCard of this contact.
This is set to %NULL if %TP_CONTACT_FEATURE_CONTACT_INFO is not set on this
contact.</doc>
        <type name="ContactInfoList" c:type="TpContactInfoList"/>
      </property>
      <property name="handle" transfer-ownership="none">
        <doc xml:whitespace="preserve">The contact's handle in the Telepathy D-Bus API, a handle of type
%TP_HANDLE_TYPE_CONTACT representing the string
given by #TpContact:identifier.
This handle is referenced using the Telepathy D-Bus API and remains
referenced for as long as the #TpContact exists and the
#TpContact:connection remains valid.
However, getting this property does not cause an additional reference
to the handle to be held.
If the #TpContact:connection becomes invalid, this property is no longer
meaningful and will be set to 0.</doc>
        <type name="uint" c:type="guint"/>
      </property>
      <property name="identifier" transfer-ownership="none">
        <doc xml:whitespace="preserve">The contact's identifier in the instant messaging protocol (e.g.
XMPP JID, SIP URI, AOL screenname or IRC nick - whatever the underlying
protocol uses to identify a user).
This is never %NULL for contact objects that are visible to library-user
code.</doc>
        <type name="utf8" c:type="gchararray"/>
      </property>
      <property name="presence-message" transfer-ownership="none">
        <doc xml:whitespace="preserve">If this contact has set a user-defined status message, that message;
if not, an empty string (which user interfaces may replace with a
localized form of the #TpContact:presence-status or
#TpContact:presence-type).
This may be an empty string even if the contact has set a message,
if this #TpContact object has not been set up to track
%TP_CONTACT_FEATURE_PRESENCE. It is never %NULL.</doc>
        <type name="utf8" c:type="gchararray"/>
      </property>
      <property name="presence-status" transfer-ownership="none">
        <doc xml:whitespace="preserve">A string representing the presence status of this contact. This may be
a well-known string from the Telepathy specification, like "available",
or a connection-manager-specific string, like "out-to-lunch".
This may be an empty string if this #TpContact object has not been set up
to track %TP_CONTACT_FEATURE_PRESENCE. It is never %NULL.</doc>
        <type name="utf8" c:type="gchararray"/>
      </property>
      <property name="presence-type" transfer-ownership="none">
        <doc xml:whitespace="preserve">The #TpConnectionPresenceType representing the type of presence status
for this contact.
This is provided so even unknown values for #TpContact:presence-status
can be classified into their fundamental types.
This may be %TP_CONNECTION_PRESENCE_TYPE_UNSET if this #TpContact
has not been set up to track %TP_CONTACT_FEATURE_PRESENCE.</doc>
        <type name="uint" c:type="guint"/>
      </property>
      <glib:signal name="presence-changed" version="0.11.7">
        <doc xml:whitespace="preserve">Emitted when this contact's presence changes.</doc>
        <return-value transfer-ownership="full">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">The new value of #TpContact:presence-type</doc>
            <type name="uint" c:type="guint"/>
          </parameter>
          <parameter name="status" transfer-ownership="none">
            <doc xml:whitespace="preserve">The new value of #TpContact:presence-status</doc>
            <type name="utf8" c:type="gchararray"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">The new value of #TpContact:presence-message</doc>
            <type name="utf8" c:type="gchararray"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ContactClass" c:type="TpContactClass" glib:is-gtype-struct-for="Contact">
    </record>
    <enumeration name="ContactFeature" version="0.7.18" c:type="TpContactFeature">
      <doc xml:whitespace="preserve">Enumeration representing the features a #TpContact can optionally support.
When requesting a #TpContact, library users specify the desired features;
the #TpContact code will only initialize state for those features, to
avoid unwanted D-Bus round-trips and signal connections.
Since 0.11.5, there is a corresponding #GEnumClass type,
%TP_TYPE_CONTACT_FEATURE.</doc>
      <member name="alias" value="0" c:identifier="TP_CONTACT_FEATURE_ALIAS"/>
      <member name="avatar_token" value="1" c:identifier="TP_CONTACT_FEATURE_AVATAR_TOKEN"/>
      <member name="presence" value="2" c:identifier="TP_CONTACT_FEATURE_PRESENCE"/>
      <member name="location" value="3" c:identifier="TP_CONTACT_FEATURE_LOCATION"/>
      <member name="capabilities" value="4" c:identifier="TP_CONTACT_FEATURE_CAPABILITIES"/>
      <member name="avatar_data" value="5" c:identifier="TP_CONTACT_FEATURE_AVATAR_DATA"/>
      <member name="contact_info" value="6" c:identifier="TP_CONTACT_FEATURE_CONTACT_INFO"/>
    </enumeration>
    <record name="ContactInfoField" c:type="TpContactInfoField" glib:type-name="TpContactInfoField" glib:get-type="tp_contact_info_field_get_type">
      <field name="field_name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="parameters" writable="1">
        <array c:type="GStrv">
          <type name="utf8"/>
        </array>
      </field>
      <field name="field_value" writable="1">
        <array c:type="GStrv">
          <type name="utf8"/>
        </array>
      </field>
      <field name="priv" writable="1">
        <type name="any" c:type="gpointer"/>
      </field>
      <constructor name="new" c:identifier="tp_contact_info_field_new">
        <return-value transfer-ownership="full">
          <type name="ContactInfoField" c:type="TpContactInfoField*"/>
        </return-value>
        <parameters>
          <parameter name="field_name" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="parameters" transfer-ownership="none">
            <array c:type="GStrv">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="field_value" transfer-ownership="none">
            <array c:type="GStrv">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy" c:identifier="tp_contact_info_field_copy">
        <return-value transfer-ownership="full">
          <type name="ContactInfoField" c:type="TpContactInfoField*"/>
        </return-value>
      </method>
      <method name="free" c:identifier="tp_contact_info_field_free">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <enumeration name="ContactInfoFieldFlags" c:type="TpContactInfoFieldFlags">
      <member name="contact_info_field_flag_parameters_exact" value="1" c:identifier="TP_CONTACT_INFO_FIELD_FLAG_PARAMETERS_EXACT"/>
    </enumeration>
    <record name="ContactInfoFieldSpec" c:type="TpContactInfoFieldSpec" glib:type-name="TpContactInfoFieldSpec" glib:get-type="tp_contact_info_field_spec_get_type">
      <field name="name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="parameters" writable="1">
        <array c:type="GStrv">
          <type name="utf8"/>
        </array>
      </field>
      <field name="flags" writable="1">
        <type name="ContactInfoFieldFlags" c:type="TpContactInfoFieldFlags"/>
      </field>
      <field name="max" writable="1">
        <type name="uint" c:type="guint"/>
      </field>
      <field name="priv" writable="1">
        <type name="any" c:type="gpointer"/>
      </field>
      <method name="copy" c:identifier="tp_contact_info_field_spec_copy">
        <return-value transfer-ownership="full">
          <type name="ContactInfoFieldSpec" c:type="TpContactInfoFieldSpec*"/>
        </return-value>
      </method>
      <method name="free" c:identifier="tp_contact_info_field_spec_free">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <enumeration name="ContactInfoFlags" c:type="TpContactInfoFlags">
      <member name="can_set" value="1" c:identifier="TP_CONTACT_INFO_FLAG_CAN_SET"/>
      <member name="push" value="2" c:identifier="TP_CONTACT_INFO_FLAG_PUSH"/>
    </enumeration>
    <glib:boxed c:type="TpContactInfoList" glib:name="ContactInfoList" glib:type-name="TpContactInfoList" glib:get-type="tp_contact_info_list_get_type">
    </glib:boxed>
    <glib:boxed c:type="TpContactInfoSpecList" glib:name="ContactInfoSpecList" glib:type-name="TpContactInfoSpecList" glib:get-type="tp_contact_info_spec_list_get_type">
    </glib:boxed>
    <record name="ContactPrivate" c:type="TpContactPrivate">
    </record>
    <record name="ContactsMixin" c:type="TpContactsMixin">
      <doc xml:whitespace="preserve">Structure to be included in the instance structure of objects that
use this mixin. Initialize it with tp_contacts_mixin_init().
There are no public fields.</doc>
      <field name="priv" writable="1">
        <type name="ContactsMixinPrivate" c:type="TpContactsMixinPrivate*"/>
      </field>
    </record>
    <record name="ContactsMixinClass" c:type="TpContactsMixinClass">
      <doc xml:whitespace="preserve">Structure to be included in the class structure of objects that
use this mixin. Initialize it with tp_contacts_mixin_class_init().
There are no public fields.</doc>
      <field name="priv" writable="1">
        <type name="ContactsMixinClassPrivate" c:type="TpContactsMixinClassPrivate*"/>
      </field>
    </record>
    <record name="ContactsMixinClassPrivate" c:type="TpContactsMixinClassPrivate">
    </record>
    <callback name="ContactsMixinFillContactAttributesFunc" c:type="TpContactsMixinFillContactAttributesFunc">
      <doc xml:whitespace="preserve">This function is called to supply contact attributes pertaining to
a particular interface, for a list of contacts.
All the handles in @contacts are guaranteed to be valid and
referenced.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the Contacts interface with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="contacts" transfer-ownership="none">
          <doc xml:whitespace="preserve">The contact handles for which attributes are requested</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="any" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="attributes_hash" transfer-ownership="none">
          <doc xml:whitespace="preserve">hash of handle =&gt; hash of attributes, containing all the contacts in the contacts array</doc>
          <type name="GLib.HashTable" c:type="GHashTable*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="ContactsMixinPrivate" c:type="TpContactsMixinPrivate">
    </record>
    <class name="DBusDaemon" c:type="TpDBusDaemon" version="0.7.1" parent="Proxy" glib:type-name="TpDBusDaemon" glib:get-type="tp_dbus_daemon_get_type" glib:type-struct="DBusDaemonClass">
      <doc xml:whitespace="preserve">A subclass of #TpProxy that represents the D-Bus daemon. It mainly provides
functionality to manage well-known names on the bus.</doc>
      <constructor name="new" c:identifier="tp_dbus_daemon_new" version="0.7.1" introspectable="0">
        <doc xml:whitespace="preserve">Returns a proxy for signals and method calls on a particular bus
connection.
Use tp_dbus_daemon_dup() instead if you just want a connection to the
starter or session bus (which is almost always the right thing for
Telepathy).
to which @connection is connected</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new proxy for signals and method calls on the bus daemon</doc>
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">a connection to D-Bus</doc>
            <type name="DBusGConnection" c:type="DBusGConnection*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="dup" c:identifier="tp_dbus_daemon_dup" version="0.7.26" throws="1">
        <doc xml:whitespace="preserve">Returns a proxy for signals and method calls on the D-Bus daemon on which
this process was activated (if it was launched by D-Bus service
activation), or the session bus (otherwise).
If it is not possible to connect to the appropriate bus, raise an error
and return %NULL.
The returned #TpDBusDaemon is cached; the same #TpDBusDaemon object will
be returned by this function repeatedly, as long as at least one reference
exists.
daemon, or %NULL</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a reference to a proxy for signals and method calls on the bus</doc>
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </return-value>
      </function>
      <function name="init_known_interfaces" c:identifier="tp_dbus_daemon_init_known_interfaces" version="0.7.32">
        <doc xml:whitespace="preserve">Ensure that the known interfaces for TpDBusDaemon have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_DBUS_DAEMON.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <method name="watch_name_owner" c:identifier="tp_dbus_daemon_watch_name_owner" version="0.7.1">
        <doc xml:whitespace="preserve">Arrange for @callback to be called with the owner of @name as soon as
possible (which might even be before this function returns!), then
again every time the ownership of @name changes.
If multiple watches are registered for the same @name, they will be called
in the order they were registered.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">The name whose ownership is to be watched</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="notified" closure="3" destroy="4">
            <doc xml:whitespace="preserve">Callback to call when the ownership is discovered or changes</doc>
            <type name="DBusDaemonNameOwnerChangedCb" c:type="TpDBusDaemonNameOwnerChangedCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">Arbitrary data to pass to @callback</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="call">
            <doc xml:whitespace="preserve">Called to destroy @user_data when the name owner watch is cancelled due to tp_dbus_daemon_cancel_name_owner_watch()</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="cancel_name_owner_watch" c:identifier="tp_dbus_daemon_cancel_name_owner_watch" version="0.7.1">
        <doc xml:whitespace="preserve">If there was a previous call to tp_dbus_daemon_watch_name_owner()
with exactly the given @name, @callback and @user_data, remove it.
If more than one watch matching the details provided was active, remove
only the most recently added one.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if there was such a watch, %FALSE otherwise</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name that was being watched</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="call" closure="3">
            <doc xml:whitespace="preserve">the callback that was called</doc>
            <type name="DBusDaemonNameOwnerChangedCb" c:type="TpDBusDaemonNameOwnerChangedCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the user data that was provided</doc>
            <type name="any" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_name" c:identifier="tp_dbus_daemon_request_name" version="0.7.30" throws="1">
        <doc xml:whitespace="preserve">Claim the given well-known name without queueing, allowing replacement
or replacing an existing name-owner. This makes a synchronous call to the
bus daemon.
an error occurred.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @well_known_name was claimed, or %FALSE and sets @error if</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="well_known_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a well-known name to acquire</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="idempotent" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether to consider it to be a success if this process already owns the name</doc>
            <type name="boolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="release_name" c:identifier="tp_dbus_daemon_release_name" version="0.7.30" throws="1">
        <doc xml:whitespace="preserve">Release the given well-known name. This makes a synchronous call to the bus
daemon.
if an error occurred.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @well_known_name was released, or %FALSE and sets @error</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="well_known_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a well-known name owned by this process to release</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_unique_name" c:identifier="tp_dbus_daemon_get_unique_name" version="0.7.35">
        <doc xml:whitespace="preserve">&lt;!-- Returns: is enough --&gt;
as long as this #TpDBusDaemon is</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the unique name of this connection to the bus, which is valid for</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="list_names" c:identifier="tp_dbus_daemon_list_names" version="0.7.35">
        <doc xml:whitespace="preserve">Call the ListNames method on the bus daemon, asynchronously. The @callback
will be called from the main loop with a list of all the names (either
unique or well-known) that exist on the bus.
In versions of telepathy-glib that have it, this should be preferred
instead of calling tp_cli_dbus_daemon_call_list_names(), since that
function will result in wakeups for every NameOwnerChanged signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="timeout_ms" transfer-ownership="none">
            <doc xml:whitespace="preserve">timeout for the call</doc>
            <type name="int" c:type="gint"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="notified" closure="3" destroy="4">
            <doc xml:whitespace="preserve">callback to be called on success or failure; must not be %NULL</doc>
            <type name="DBusDaemonListNamesCb" c:type="TpDBusDaemonListNamesCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">opaque user-supplied data to pass to the callback</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="call">
            <doc xml:whitespace="preserve">if not %NULL, called with @user_data as argument after the call has succeeded or failed, or after @weak_object has been destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object" transfer-ownership="none">
            <doc xml:whitespace="preserve">if not %NULL, a GObject which will be weakly referenced; if it is destroyed, @callback will not be called at all</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="list_activatable_names" c:identifier="tp_dbus_daemon_list_activatable_names" version="0.7.35">
        <doc xml:whitespace="preserve">Call the ListActivatableNames method on the bus daemon, asynchronously.
The @callback will be called from the main loop with a list of all the
well-known names that are available for service-activation on the bus.
In versions of telepathy-glib that have it, this should be preferred
instead of calling tp_cli_dbus_daemon_call_list_activatable_names(), since
that function will result in wakeups for every NameOwnerChanged signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="timeout_ms" transfer-ownership="none">
            <doc xml:whitespace="preserve">timeout for the call</doc>
            <type name="int" c:type="gint"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="notified" closure="3" destroy="4">
            <doc xml:whitespace="preserve">callback to be called on success or failure; must not be %NULL</doc>
            <type name="DBusDaemonListNamesCb" c:type="TpDBusDaemonListNamesCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">opaque user-supplied data to pass to the callback</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="call">
            <doc xml:whitespace="preserve">if not %NULL, called with @user_data as argument after the call has succeeded or failed, or after @weak_object has been destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object" transfer-ownership="none">
            <doc xml:whitespace="preserve">if not %NULL, a GObject which will be weakly referenced; if it is destroyed, @callback will not be called at all</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="register_object" c:identifier="tp_dbus_daemon_register_object" version="0.11.3">
        <doc xml:whitespace="preserve">Export @object at @object_path. This is a convenience wrapper around
dbus_g_connection_register_g_object(), and behaves similarly.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">an object path</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">an object to export</doc>
            <type name="GObject.Object" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="unregister_object" c:identifier="tp_dbus_daemon_unregister_object" version="0.11.3">
        <doc xml:whitespace="preserve">Stop exporting @object on D-Bus. This is a convenience wrapper around
dbus_g_connection_unregister_g_object(), and behaves similarly.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">an object previously exported with tp_dbus_daemon_register_object()</doc>
            <type name="GObject.Object" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <record name="DBusDaemonClass" c:type="TpDBusDaemonClass" glib:is-gtype-struct-for="DBusDaemon" version="0.7.1">
      <doc xml:whitespace="preserve">The class of #TpDBusDaemon.</doc>
    </record>
    <callback name="DBusDaemonListNamesCb" c:type="TpDBusDaemonListNamesCb" version="0.7.35">
      <doc xml:whitespace="preserve">Signature of a callback for functions that list bus names.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="bus_daemon" transfer-ownership="none">
          <doc xml:whitespace="preserve">object representing a connection to a bus</doc>
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </parameter>
        <parameter name="names" transfer-ownership="none">
          <doc xml:whitespace="preserve">constant %NULL-terminated array of constant strings representing bus names, or %NULL on error</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">the error that occurred, or %NULL on success</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <doc xml:whitespace="preserve">the same user data that was passed to tp_dbus_daemon_list_names or tp_dbus_daemon_list_activatable_names</doc>
          <type name="any" c:type="gpointer"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <doc xml:whitespace="preserve">the same object that was passed to tp_dbus_daemon_list_names or tp_dbus_daemon_list_activatable_names</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="DBusDaemonNameOwnerChangedCb" c:type="TpDBusDaemonNameOwnerChangedCb" version="0.7.1">
      <doc xml:whitespace="preserve">The signature of the callback called by tp_dbus_daemon_watch_name_owner().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="bus_daemon" transfer-ownership="none">
          <doc xml:whitespace="preserve">The D-Bus daemon</doc>
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">The name whose ownership has changed or been discovered</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="new_owner" transfer-ownership="none">
          <doc xml:whitespace="preserve">The unique name that now owns @name</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <doc xml:whitespace="preserve">Arbitrary user-supplied data as passed to tp_dbus_daemon_watch_name_owner()</doc>
          <type name="any" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="DBusDaemonPrivate" c:type="TpDBusDaemonPrivate">
    </record>
    <enumeration name="DBusError" version="0.7.1" c:type="TpDBusError">
      <doc xml:whitespace="preserve">#GError codes for use with the %TP_DBUS_ERRORS domain.
Since 0.11.5, there is a corresponding #GEnumClass type,
%TP_TYPE_DBUS_ERROR.</doc>
      <member name="unknown_remote_error" value="0" c:identifier="TP_DBUS_ERROR_UNKNOWN_REMOTE_ERROR"/>
      <member name="proxy_unreferenced" value="1" c:identifier="TP_DBUS_ERROR_PROXY_UNREFERENCED"/>
      <member name="no_interface" value="2" c:identifier="TP_DBUS_ERROR_NO_INTERFACE"/>
      <member name="name_owner_lost" value="3" c:identifier="TP_DBUS_ERROR_NAME_OWNER_LOST"/>
      <member name="invalid_bus_name" value="4" c:identifier="TP_DBUS_ERROR_INVALID_BUS_NAME"/>
      <member name="invalid_interface_name" value="5" c:identifier="TP_DBUS_ERROR_INVALID_INTERFACE_NAME"/>
      <member name="invalid_object_path" value="6" c:identifier="TP_DBUS_ERROR_INVALID_OBJECT_PATH"/>
      <member name="invalid_member_name" value="7" c:identifier="TP_DBUS_ERROR_INVALID_MEMBER_NAME"/>
      <member name="object_removed" value="8" c:identifier="TP_DBUS_ERROR_OBJECT_REMOVED"/>
      <member name="cancelled" value="9" c:identifier="TP_DBUS_ERROR_CANCELLED"/>
      <member name="inconsistent" value="10" c:identifier="TP_DBUS_ERROR_INCONSISTENT"/>
    </enumeration>
    <enumeration name="DBusNameType" version="0.7.1" c:type="TpDBusNameType">
      <doc xml:whitespace="preserve">A set of flags indicating which D-Bus bus names are acceptable.
They can be combined with the bitwise-or operator to accept multiple
types. %TP_DBUS_NAME_TYPE_NOT_BUS_DAEMON and %TP_DBUS_NAME_TYPE_ANY are
the bitwise-or of other appropriate types, for convenience.
Since 0.11.5, there is a corresponding #GFlagsClass type,
%TP_TYPE_DBUS_NAME_TYPE.</doc>
      <member name="unique" value="1" c:identifier="TP_DBUS_NAME_TYPE_UNIQUE"/>
      <member name="well_known" value="2" c:identifier="TP_DBUS_NAME_TYPE_WELL_KNOWN"/>
      <member name="bus_daemon" value="4" c:identifier="TP_DBUS_NAME_TYPE_BUS_DAEMON"/>
      <member name="not_bus_daemon" value="3" c:identifier="TP_DBUS_NAME_TYPE_NOT_BUS_DAEMON"/>
      <member name="any" value="7" c:identifier="TP_DBUS_NAME_TYPE_ANY"/>
    </enumeration>
    <record name="DBusPropertiesMixinClass" c:type="_TpDBusPropertiesMixinClass">
    </record>
    <enumeration name="DBusPropertiesMixinFlags" version="0.7.3" c:type="TpDBusPropertiesMixinFlags">
      <doc xml:whitespace="preserve">Bitfield representing allowed access to a property.
Since 0.11.5, there is a corresponding #GFlagsClass type,
%TP_TYPE_DBUS_PROPERTIES_MIXIN_FLAGS.</doc>
      <member name="read" value="1" c:identifier="TP_DBUS_PROPERTIES_MIXIN_FLAG_READ"/>
      <member name="write" value="2" c:identifier="TP_DBUS_PROPERTIES_MIXIN_FLAG_WRITE"/>
    </enumeration>
    <callback name="DBusPropertiesMixinGetter" c:type="TpDBusPropertiesMixinGetter">
      <doc xml:whitespace="preserve">Signature of a callback used to get the value of a property.
For simplicity, in this mixin we don't allow getting a property to fail;
implementations must always be prepared to return *something*.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">The exported object with the properties</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="iface" transfer-ownership="none">
          <doc xml:whitespace="preserve">A quark representing the D-Bus interface name</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">A quark representing the D-Bus property name</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GValue pre-initialized to the right type, into which to put the value</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="getter_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">The getter_data from the #TpDBusPropertiesMixinPropImpl</doc>
          <type name="any" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="DBusPropertiesMixinIfaceImpl" c:type="TpDBusPropertiesMixinIfaceImpl" version="0.7.3">
      <doc xml:whitespace="preserve">Structure representing an implementation of an interface's properties.
In addition to the documented fields, there are four pointers which must
be initialized to %NULL.
This structure must either be statically allocated, or duplicated and never
freed, so it always remains valid.</doc>
      <field name="name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="getter" writable="1">
        <type name="DBusPropertiesMixinGetter" c:type="TpDBusPropertiesMixinGetter"/>
      </field>
      <field name="setter" writable="1">
        <type name="DBusPropertiesMixinSetter" c:type="TpDBusPropertiesMixinSetter"/>
      </field>
      <field name="props" writable="1">
        <type name="DBusPropertiesMixinPropImpl" c:type="TpDBusPropertiesMixinPropImpl*"/>
      </field>
      <field name="_1" writable="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_2" writable="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="mixin_next" writable="1">
        <type name="any" c:type="gpointer"/>
      </field>
      <field name="mixin_priv" writable="1">
        <type name="any" c:type="gpointer"/>
      </field>
    </record>
    <record name="DBusPropertiesMixinIfaceInfo" c:type="TpDBusPropertiesMixinIfaceInfo" version="0.7.3">
      <doc xml:whitespace="preserve">Semi-abstract description of an interface. Each service GInterface that
has properties must have one of these attached to it via
tp_svc_interface_set_dbus_properties_info() in its base_init function;
service GInterfaces that do not have properties may have one of these
with no properties.
This structure must either be statically allocated, or duplicated and never
freed, so it always remains valid.
In addition to the documented members, there are two private pointers
for future expansion, which must always be initialized to %NULL.</doc>
      <field name="dbus_interface" writable="1">
        <type name="GLib.Quark" c:type="GQuark"/>
      </field>
      <field name="props" writable="1">
        <type name="DBusPropertiesMixinPropInfo" c:type="TpDBusPropertiesMixinPropInfo*"/>
      </field>
      <field name="_1" writable="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_2" writable="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
    </record>
    <record name="DBusPropertiesMixinPropImpl" c:type="TpDBusPropertiesMixinPropImpl" version="0.7.3">
      <doc xml:whitespace="preserve">Structure representing an implementation of a property.
In addition to the documented fields, there are three pointers which must
be initialized to %NULL.
This structure must either be statically allocated, or duplicated and never
freed, so it always remains valid.</doc>
      <field name="name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="getter_data" writable="1">
        <type name="any" c:type="gpointer"/>
      </field>
      <field name="setter_data" writable="1">
        <type name="any" c:type="gpointer"/>
      </field>
      <field name="_1" writable="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_2" writable="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="mixin_priv" writable="1">
        <type name="any" c:type="gpointer"/>
      </field>
    </record>
    <record name="DBusPropertiesMixinPropInfo" c:type="TpDBusPropertiesMixinPropInfo" version="0.7.3">
      <doc xml:whitespace="preserve">Semi-abstract description of a property, as attached to a service
GInterface. This structure must either be statically allocated, or
duplicated and never freed, so it always remains valid.
In addition to the documented members, there are two private pointers
for future expansion, which must always be initialized to %NULL.</doc>
      <field name="name" writable="1">
        <type name="GLib.Quark" c:type="GQuark"/>
      </field>
      <field name="flags" writable="1">
        <type name="DBusPropertiesMixinFlags" c:type="TpDBusPropertiesMixinFlags"/>
      </field>
      <field name="dbus_signature" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="type" writable="1">
        <type name="GType" c:type="GType"/>
      </field>
      <field name="_1" writable="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_2" writable="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
    </record>
    <callback name="DBusPropertiesMixinSetter" c:type="TpDBusPropertiesMixinSetter" throws="1">
      <doc xml:whitespace="preserve">Signature of a callback used to get the value of a property.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE on success, %FALSE (setting @error) on failure</doc>
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">The exported object with the properties</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="iface" transfer-ownership="none">
          <doc xml:whitespace="preserve">A quark representing the D-Bus interface name</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">A quark representing the D-Bus property name</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">The new value for the property</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="setter_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">The setter_data from the #TpDBusPropertiesMixinPropImpl</doc>
          <type name="any" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="DTMFEvent" c:type="TpDTMFEvent">
      <member name="digit_0" value="0" c:identifier="TP_DTMF_EVENT_DIGIT_0"/>
      <member name="digit_1" value="1" c:identifier="TP_DTMF_EVENT_DIGIT_1"/>
      <member name="digit_2" value="2" c:identifier="TP_DTMF_EVENT_DIGIT_2"/>
      <member name="digit_3" value="3" c:identifier="TP_DTMF_EVENT_DIGIT_3"/>
      <member name="digit_4" value="4" c:identifier="TP_DTMF_EVENT_DIGIT_4"/>
      <member name="digit_5" value="5" c:identifier="TP_DTMF_EVENT_DIGIT_5"/>
      <member name="digit_6" value="6" c:identifier="TP_DTMF_EVENT_DIGIT_6"/>
      <member name="digit_7" value="7" c:identifier="TP_DTMF_EVENT_DIGIT_7"/>
      <member name="digit_8" value="8" c:identifier="TP_DTMF_EVENT_DIGIT_8"/>
      <member name="digit_9" value="9" c:identifier="TP_DTMF_EVENT_DIGIT_9"/>
      <member name="asterisk" value="10" c:identifier="TP_DTMF_EVENT_ASTERISK"/>
      <member name="hash" value="11" c:identifier="TP_DTMF_EVENT_HASH"/>
      <member name="letter_a" value="12" c:identifier="TP_DTMF_EVENT_LETTER_A"/>
      <member name="letter_b" value="13" c:identifier="TP_DTMF_EVENT_LETTER_B"/>
      <member name="letter_c" value="14" c:identifier="TP_DTMF_EVENT_LETTER_C"/>
      <member name="letter_d" value="15" c:identifier="TP_DTMF_EVENT_LETTER_D"/>
    </enumeration>
    <enumeration name="DebugLevel" c:type="TpDebugLevel">
      <member name="error" value="0" c:identifier="TP_DEBUG_LEVEL_ERROR"/>
      <member name="critical" value="1" c:identifier="TP_DEBUG_LEVEL_CRITICAL"/>
      <member name="warning" value="2" c:identifier="TP_DEBUG_LEVEL_WARNING"/>
      <member name="message" value="3" c:identifier="TP_DEBUG_LEVEL_MESSAGE"/>
      <member name="info" value="4" c:identifier="TP_DEBUG_LEVEL_INFO"/>
      <member name="debug" value="5" c:identifier="TP_DEBUG_LEVEL_DEBUG"/>
    </enumeration>
    <enumeration name="DeliveryReportingSupportFlags" c:type="TpDeliveryReportingSupportFlags">
      <member name="failures" value="1" c:identifier="TP_DELIVERY_REPORTING_SUPPORT_FLAG_RECEIVE_FAILURES"/>
      <member name="successes" value="2" c:identifier="TP_DELIVERY_REPORTING_SUPPORT_FLAG_RECEIVE_SUCCESSES"/>
      <member name="read" value="4" c:identifier="TP_DELIVERY_REPORTING_SUPPORT_FLAG_RECEIVE_READ"/>
      <member name="deleted" value="8" c:identifier="TP_DELIVERY_REPORTING_SUPPORT_FLAG_RECEIVE_DELETED"/>
    </enumeration>
    <enumeration name="DeliveryStatus" c:type="TpDeliveryStatus">
      <member name="unknown" value="0" c:identifier="TP_DELIVERY_STATUS_UNKNOWN"/>
      <member name="delivered" value="1" c:identifier="TP_DELIVERY_STATUS_DELIVERED"/>
      <member name="temporarily_failed" value="2" c:identifier="TP_DELIVERY_STATUS_TEMPORARILY_FAILED"/>
      <member name="permanently_failed" value="3" c:identifier="TP_DELIVERY_STATUS_PERMANENTLY_FAILED"/>
      <member name="accepted" value="4" c:identifier="TP_DELIVERY_STATUS_ACCEPTED"/>
      <member name="read" value="5" c:identifier="TP_DELIVERY_STATUS_READ"/>
      <member name="deleted" value="6" c:identifier="TP_DELIVERY_STATUS_DELETED"/>
    </enumeration>
    <constant name="ERROR_PREFIX" value="org.freedesktop.Telepathy.Error">
      <type name="utf8"/>
    </constant>
    <enumeration name="Error" c:type="TpError" glib:error-quark="tp_error_quark">
      <doc xml:whitespace="preserve">Enumerated type representing the Telepathy D-Bus errors.</doc>
      <member name="network_error" value="0" c:identifier="TP_ERROR_NETWORK_ERROR"/>
      <member name="not_implemented" value="1" c:identifier="TP_ERROR_NOT_IMPLEMENTED"/>
      <member name="invalid_argument" value="2" c:identifier="TP_ERROR_INVALID_ARGUMENT"/>
      <member name="not_available" value="3" c:identifier="TP_ERROR_NOT_AVAILABLE"/>
      <member name="permission_denied" value="4" c:identifier="TP_ERROR_PERMISSION_DENIED"/>
      <member name="disconnected" value="5" c:identifier="TP_ERROR_DISCONNECTED"/>
      <member name="invalid_handle" value="6" c:identifier="TP_ERROR_INVALID_HANDLE"/>
      <member name="channel_banned" value="7" c:identifier="TP_ERROR_CHANNEL_BANNED"/>
      <member name="channel_full" value="8" c:identifier="TP_ERROR_CHANNEL_FULL"/>
      <member name="channel_invite_only" value="9" c:identifier="TP_ERROR_CHANNEL_INVITE_ONLY"/>
      <member name="not_yours" value="10" c:identifier="TP_ERROR_NOT_YOURS"/>
      <member name="cancelled" value="11" c:identifier="TP_ERROR_CANCELLED"/>
      <member name="authentication_failed" value="12" c:identifier="TP_ERROR_AUTHENTICATION_FAILED"/>
      <member name="encryption_not_available" value="13" c:identifier="TP_ERROR_ENCRYPTION_NOT_AVAILABLE"/>
      <member name="encryption_error" value="14" c:identifier="TP_ERROR_ENCRYPTION_ERROR"/>
      <member name="cert_not_provided" value="15" c:identifier="TP_ERROR_CERT_NOT_PROVIDED"/>
      <member name="cert_untrusted" value="16" c:identifier="TP_ERROR_CERT_UNTRUSTED"/>
      <member name="cert_expired" value="17" c:identifier="TP_ERROR_CERT_EXPIRED"/>
      <member name="cert_not_activated" value="18" c:identifier="TP_ERROR_CERT_NOT_ACTIVATED"/>
      <member name="cert_fingerprint_mismatch" value="19" c:identifier="TP_ERROR_CERT_FINGERPRINT_MISMATCH"/>
      <member name="cert_hostname_mismatch" value="20" c:identifier="TP_ERROR_CERT_HOSTNAME_MISMATCH"/>
      <member name="cert_self_signed" value="21" c:identifier="TP_ERROR_CERT_SELF_SIGNED"/>
      <member name="cert_invalid" value="22" c:identifier="TP_ERROR_CERT_INVALID"/>
      <member name="not_capable" value="23" c:identifier="TP_ERROR_NOT_CAPABLE"/>
      <member name="offline" value="24" c:identifier="TP_ERROR_OFFLINE"/>
      <member name="channel_kicked" value="25" c:identifier="TP_ERROR_CHANNEL_KICKED"/>
      <member name="busy" value="26" c:identifier="TP_ERROR_BUSY"/>
      <member name="no_answer" value="27" c:identifier="TP_ERROR_NO_ANSWER"/>
      <member name="does_not_exist" value="28" c:identifier="TP_ERROR_DOES_NOT_EXIST"/>
      <member name="terminated" value="29" c:identifier="TP_ERROR_TERMINATED"/>
      <member name="connection_refused" value="30" c:identifier="TP_ERROR_CONNECTION_REFUSED"/>
      <member name="connection_failed" value="31" c:identifier="TP_ERROR_CONNECTION_FAILED"/>
      <member name="connection_lost" value="32" c:identifier="TP_ERROR_CONNECTION_LOST"/>
      <member name="already_connected" value="33" c:identifier="TP_ERROR_ALREADY_CONNECTED"/>
      <member name="connection_replaced" value="34" c:identifier="TP_ERROR_CONNECTION_REPLACED"/>
      <member name="registration_exists" value="35" c:identifier="TP_ERROR_REGISTRATION_EXISTS"/>
      <member name="service_busy" value="36" c:identifier="TP_ERROR_SERVICE_BUSY"/>
      <member name="resource_unavailable" value="37" c:identifier="TP_ERROR_RESOURCE_UNAVAILABLE"/>
      <member name="would_break_anonymity" value="38" c:identifier="TP_ERROR_WOULD_BREAK_ANONYMITY"/>
      <member name="cert_revoked" value="39" c:identifier="TP_ERROR_CERT_REVOKED"/>
      <member name="cert_insecure" value="40" c:identifier="TP_ERROR_CERT_INSECURE"/>
      <member name="cert_limit_exceeded" value="41" c:identifier="TP_ERROR_CERT_LIMIT_EXCEEDED"/>
    </enumeration>
    <enumeration name="FileHashType" c:type="TpFileHashType">
      <member name="none" value="0" c:identifier="TP_FILE_HASH_TYPE_NONE"/>
      <member name="md5" value="1" c:identifier="TP_FILE_HASH_TYPE_MD5"/>
      <member name="sha1" value="2" c:identifier="TP_FILE_HASH_TYPE_SHA1"/>
      <member name="sha256" value="3" c:identifier="TP_FILE_HASH_TYPE_SHA256"/>
    </enumeration>
    <enumeration name="FileTransferState" c:type="TpFileTransferState">
      <member name="none" value="0" c:identifier="TP_FILE_TRANSFER_STATE_NONE"/>
      <member name="pending" value="1" c:identifier="TP_FILE_TRANSFER_STATE_PENDING"/>
      <member name="accepted" value="2" c:identifier="TP_FILE_TRANSFER_STATE_ACCEPTED"/>
      <member name="open" value="3" c:identifier="TP_FILE_TRANSFER_STATE_OPEN"/>
      <member name="completed" value="4" c:identifier="TP_FILE_TRANSFER_STATE_COMPLETED"/>
      <member name="cancelled" value="5" c:identifier="TP_FILE_TRANSFER_STATE_CANCELLED"/>
    </enumeration>
    <enumeration name="FileTransferStateChangeReason" c:type="TpFileTransferStateChangeReason">
      <member name="none" value="0" c:identifier="TP_FILE_TRANSFER_STATE_CHANGE_REASON_NONE"/>
      <member name="requested" value="1" c:identifier="TP_FILE_TRANSFER_STATE_CHANGE_REASON_REQUESTED"/>
      <member name="local_stopped" value="2" c:identifier="TP_FILE_TRANSFER_STATE_CHANGE_REASON_LOCAL_STOPPED"/>
      <member name="remote_stopped" value="3" c:identifier="TP_FILE_TRANSFER_STATE_CHANGE_REASON_REMOTE_STOPPED"/>
      <member name="local_error" value="4" c:identifier="TP_FILE_TRANSFER_STATE_CHANGE_REASON_LOCAL_ERROR"/>
      <member name="remote_error" value="5" c:identifier="TP_FILE_TRANSFER_STATE_CHANGE_REASON_REMOTE_ERROR"/>
    </enumeration>
    <record name="GroupMixin" c:type="TpGroupMixin">
      <doc xml:whitespace="preserve">Structure representing the group mixin as used in a particular class.
To be placed in the implementation's instance structure.
All fields should be considered read-only.</doc>
      <field name="handle_repo" writable="1">
        <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
      </field>
      <field name="self_handle" writable="1">
        <type name="Handle" c:type="TpHandle"/>
      </field>
      <field name="group_flags" writable="1">
        <type name="ChannelGroupFlags" c:type="TpChannelGroupFlags"/>
      </field>
      <field name="members" writable="1">
        <type name="HandleSet" c:type="TpHandleSet*"/>
      </field>
      <field name="local_pending" writable="1">
        <type name="HandleSet" c:type="TpHandleSet*"/>
      </field>
      <field name="remote_pending" writable="1">
        <type name="HandleSet" c:type="TpHandleSet*"/>
      </field>
      <field name="priv" writable="1">
        <type name="GroupMixinPrivate" c:type="TpGroupMixinPrivate*"/>
      </field>
    </record>
    <callback name="GroupMixinAddMemberFunc" c:type="TpGroupMixinAddMemberFunc" throws="1">
      <doc xml:whitespace="preserve">Signature of the callback used to add a member to the group.
This should perform the necessary operations in the underlying IM protocol
to cause the member to be added.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE on success, %FALSE with @error set on error</doc>
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">The handle of the contact to be added</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:whitespace="preserve">A message to be sent if the protocol supports it</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="GroupMixinClass" c:type="TpGroupMixinClass">
      <doc xml:whitespace="preserve">Structure representing the group mixin as used in a particular class.
To be placed in the implementation's class structure.
Initialize this with tp_group_mixin_class_init().
All fields should be considered read-only.</doc>
      <field name="add_member" writable="1">
        <type name="GroupMixinAddMemberFunc" c:type="TpGroupMixinAddMemberFunc"/>
      </field>
      <field name="remove_member" writable="1">
        <type name="GroupMixinRemMemberFunc" c:type="TpGroupMixinRemMemberFunc"/>
      </field>
      <field name="priv" writable="1">
        <type name="GroupMixinClassPrivate" c:type="TpGroupMixinClassPrivate*"/>
      </field>
    </record>
    <record name="GroupMixinClassPrivate" c:type="TpGroupMixinClassPrivate">
    </record>
    <record name="GroupMixinPrivate" c:type="TpGroupMixinPrivate">
    </record>
    <callback name="GroupMixinRemMemberFunc" c:type="TpGroupMixinRemMemberFunc" throws="1">
      <doc xml:whitespace="preserve">Signature of the callback used to remove a member from the group.
This should perform the necessary operations in the underlying IM protocol
to cause the member to be removed.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE on success, %FALSE with @error set on error</doc>
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">The handle of the contact to be removed</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:whitespace="preserve">A message to be sent if the protocol supports it</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="GroupMixinRemMemberWithReasonFunc" c:type="TpGroupMixinRemMemberWithReasonFunc" throws="1">
      <doc xml:whitespace="preserve">Signature of the callback used to remove a member from the group.
This should perform the necessary operations in the underlying IM protocol
to cause the member to be removed.
Set this with tp_group_mixin_class_set_remove_with_reason_func(), .</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE on success, %FALSE with @error set on error</doc>
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">The handle of the contact to be removed</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:whitespace="preserve">A message to be sent if the protocol supports it</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="reason" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #TpChannelGroupChangeReason indicating the reason</doc>
          <type name="uint" c:type="guint"/>
        </parameter>
      </parameters>
    </callback>
    <class name="HandleChannelsContext" c:type="TpHandleChannelsContext" version="0.11.6" parent="GObject.Object" glib:type-name="TpHandleChannelsContext" glib:get-type="tp_handle_channels_context_get_type" glib:type-struct="HandleChannelsContextClass">
      <doc xml:whitespace="preserve">Data structure representing the context of a Handler.HandleChannels()
call.</doc>
      <method name="accept" c:identifier="tp_handle_channels_context_accept" version="0.11.6">
        <doc xml:whitespace="preserve">Called by #TpBaseClientClassAddDispatchOperationImpl when it's done so
the D-Bus method can return.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="fail" c:identifier="tp_handle_channels_context_fail" version="0.11.6">
        <doc xml:whitespace="preserve">Called by #TpBaseClientClassAddDispatchOperationImpl to raise a D-Bus error.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="error" transfer-ownership="none">
            <doc xml:whitespace="preserve">the error to return from the method</doc>
            <type name="GLib.Error" c:type="GError*"/>
          </parameter>
        </parameters>
      </method>
      <method name="delay" c:identifier="tp_handle_channels_context_delay" version="0.11.6">
        <doc xml:whitespace="preserve">Called by #TpBaseClientClassAddDispatchOperationImpl to indicate that it
implements the method in an async way. The caller must take a reference
to the #TpHandleChannelsContext before calling this function, and
is responsible for calling either
tp_handle_channels_context_accept() or
tp_handle_channels_context_fail() later.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get_handler_info" c:identifier="tp_handle_channels_context_get_handler_info" version="0.11.14">
        <doc xml:whitespace="preserve">Return any extra information that accompanied this request to handle
channels (the Handler_Info argument from the HandleChannels D-Bus method).
Well-known keys for this map will be defined by the Telepathy D-Bus
Interface Specification; at the time of writing, none have been defined.
The returned hash table is only valid for as long as @self is.
extra handler information, in a form suitable for use with
tp_asv_get_string() etc.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">extensible</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </return-value>
      </method>
      <property name="account" version="0.11.6" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TpAccount object representing the Account of the DispatchOperation
that has been passed to HandleChannels.
Read-only except during construction.
This property can't be %NULL.</doc>
        <type name="Account" c:type="TpAccount"/>
      </property>
      <property name="channels" version="0.11.6" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GPtrArray containing #TpChannel objects representing the channels
that have been passed to HandleChannels.
Read-only except during construction.
This property can't be %NULL.</doc>
        <type name="GLib.PtrArray" c:type="GPtrArray"/>
      </property>
      <property name="connection" version="0.11.6" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TpConnection object representing the Connection of the DispatchOperation
that has been passed to HandleChannels.
Read-only except during construction.
This property can't be %NULL.</doc>
        <type name="Connection" c:type="TpConnection"/>
      </property>
      <property name="dbus-context" version="0.11.6" introspectable="0" readable="0" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The #DBusGMethodInvocation representing the D-Bus context of the
HandleChannels call.
Can only be written during construction.</doc>
        <type name="any" c:type="gpointer"/>
      </property>
      <property name="requests-satisfied" version="0.11.6" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GPtrArray containing #TpChannelRequest objects representing the
requests that have been passed to HandleChannels.
Read-only except during construction.
This property can't be %NULL.</doc>
        <type name="GLib.PtrArray" c:type="GPtrArray"/>
      </property>
      <property name="user-action-time" version="0.11.6" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The time at which user action occurred, or one of the
special values %TP_USER_ACTION_TIME_NOT_USER_ACTION or
%TP_USER_ACTION_TIME_CURRENT_TIME
(see #TpAccountChannelRequest:user-action-time for details)
Read-only except during construction.</doc>
        <type name="int64" c:type="gint64"/>
      </property>
      <glib:signal name="done" version="0.11.6">
        <doc xml:whitespace="preserve">Emitted when tp_handle_channels_context_accept has been called on @self.</doc>
        <return-value transfer-ownership="full">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="HandleChannelsContextClass" c:type="TpHandleChannelsContextClass" glib:is-gtype-struct-for="HandleChannelsContext" version="0.11.6">
      <doc xml:whitespace="preserve">The class of a #TpHandleChannelsContext.</doc>
    </record>
    <record name="HandleChannelsContextPrivate" c:type="TpHandleChannelsContextPrivate">
    </record>
    <interface name="HandleRepoIface" c:type="TpHandleRepoIface" glib:type-name="TpHandleRepoIface" glib:get-type="tp_handle_repo_iface_get_type" glib:type-struct="HandleRepoIfaceClass">
      <doc xml:whitespace="preserve">Dummy typedef representing any implementation of this interface.</doc>
      <property name="handle-type" writable="1" construct-only="1" transfer-ownership="none">
        <type name="uint" c:type="guint"/>
      </property>
    </interface>
    <record name="HandleRepoIfaceClass" c:type="TpHandleRepoIfaceClass" glib:is-gtype-struct-for="HandleRepoIface">
      <doc xml:whitespace="preserve">The class of a handle repository interface. The structure layout is
only available within telepathy-glib, for the handle repository
implementations' benefit.</doc>
    </record>
    <record name="HandleSet" c:type="TpHandleSet" glib:type-name="TpHandleSet" glib:get-type="tp_handle_set_get_type">
      <doc xml:whitespace="preserve">A set of handles. This is similar to a #TpIntSet (and implemented using
one), but adding a handle to the set also references it.</doc>
      <constructor name="new" c:identifier="tp_handle_set_new" introspectable="0">
        <doc xml:whitespace="preserve">Creates a new #TpHandleSet</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A new #TpHandleSet</doc>
          <type name="HandleSet" c:type="TpHandleSet*"/>
        </return-value>
        <parameters>
          <parameter name="repo" transfer-ownership="none">
            <doc xml:whitespace="preserve">#TpHandleRepoIface that holds the handles to be reffed by this set</doc>
            <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_array" c:identifier="tp_handle_set_new_from_array" version="0.11.7" introspectable="0">
        <doc xml:whitespace="preserve">Creates a new #TpHandleSet</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A new #TpHandleSet</doc>
          <type name="HandleSet" c:type="TpHandleSet*"/>
        </return-value>
        <parameters>
          <parameter name="repo" transfer-ownership="none">
            <doc xml:whitespace="preserve">#TpHandleRepoIface that holds the handles to be reffed by this set</doc>
            <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
          </parameter>
          <parameter name="array" transfer-ownership="none">
            <doc xml:whitespace="preserve">array of handles to be referenced by this set</doc>
            <array name="GLib.Array" c:type="GArray*">
              <type name="uint"/>
            </array>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy" c:identifier="tp_handle_set_copy" version="0.11.6" introspectable="0">
        <doc xml:whitespace="preserve">Creates a new #TpHandleSet with the same contents as @other.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new set</doc>
          <type name="HandleSet" c:type="TpHandleSet*"/>
        </return-value>
      </method>
      <method name="clear" c:identifier="tp_handle_set_clear" version="0.11.6" introspectable="0">
        <doc xml:whitespace="preserve">Remove every handle from @set, releasing the references it holds.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="destroy" c:identifier="tp_handle_set_destroy" introspectable="0">
        <doc xml:whitespace="preserve">Delete a #TpHandleSet and unreference any handles that it holds</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="peek" c:identifier="tp_handle_set_peek" introspectable="0">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all, this comment is just to keep gtkdoc happy--&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the underlying #TpIntSet used by this #TpHandleSet</doc>
          <type name="IntSet" c:type="TpIntSet*"/>
        </return-value>
      </method>
      <method name="add" c:identifier="tp_handle_set_add" introspectable="0">
        <doc xml:whitespace="preserve">Add a handle to a #TpHandleSet, and reference it in the attached
#TpHandleRepoIface</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:whitespace="preserve">handle to add</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove" c:identifier="tp_handle_set_remove" introspectable="0">
        <doc xml:whitespace="preserve">Remove a handle from a #TpHandleSet, and unreference it in the attached
#TpHandleRepoIface</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">FALSE if the handle was invalid, or was not in this set</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:whitespace="preserve">handle to remove</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_member" c:identifier="tp_handle_set_is_member" introspectable="0">
        <doc xml:whitespace="preserve">Check if the handle is in this set</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the handle is in this set</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:whitespace="preserve">handle to check</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </method>
      <method name="foreach" c:identifier="tp_handle_set_foreach" introspectable="0">
        <doc xml:whitespace="preserve">Call @func(@set, @handle, @userdata) for each handle in @set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="func" transfer-ownership="none" scope="call" closure="2">
            <doc xml:whitespace="preserve">A callback</doc>
            <type name="HandleSetMemberFunc" c:type="TpHandleSetMemberFunc"/>
          </parameter>
          <parameter name="userdata" transfer-ownership="none">
            <doc xml:whitespace="preserve">Arbitrary data to pass to @func</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_empty" c:identifier="tp_handle_set_is_empty" version="0.11.6" introspectable="0">
        <doc xml:whitespace="preserve">Return the same thing as &lt;code&gt;(tp_handle_set_size (set) == 0)&lt;/code&gt;,
but calculated more efficiently.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the set has no members</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="size" c:identifier="tp_handle_set_size" introspectable="0">
        <doc xml:whitespace="preserve">&lt;!--no further documentation needed--&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of handles in this set</doc>
          <type name="int" c:type="int"/>
        </return-value>
      </method>
      <method name="to_array" c:identifier="tp_handle_set_to_array" introspectable="0">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all, this comment is just to keep gtkdoc happy--&gt;
the handles in the set</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly-allocated GArray of guint representing</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="uint"/>
          </array>
        </return-value>
      </method>
      <method name="update" c:identifier="tp_handle_set_update" introspectable="0">
        <doc xml:whitespace="preserve">Add a set of handles to a handle set, referencing those which are not
already members. The TpIntSet returned must be freed with tp_intset_destroy.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the handles which were added (some subset of @add)</doc>
          <type name="IntSet" c:type="TpIntSet*"/>
        </return-value>
        <parameters>
          <parameter name="add" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpIntSet of handles to add</doc>
            <type name="IntSet" c:type="TpIntSet*"/>
          </parameter>
        </parameters>
      </method>
      <method name="difference_update" c:identifier="tp_handle_set_difference_update" introspectable="0">
        <doc xml:whitespace="preserve">Remove a set of handles from a handle set, dereferencing those which are
members. The TpIntSet returned must be freed with tp_intset_destroy.
If you want to be able to inspect the handles in the set returned,
you must ensure that this function does not cause their refcount to drop
to zero, for instance by temporarily taking a reference to all the
handles in @remove, calling this function, doing something with the
result and discarding the temporary references.
of @remove).</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the handles which were dereferenced and removed (some subset</doc>
          <type name="IntSet" c:type="TpIntSet*"/>
        </return-value>
        <parameters>
          <parameter name="remove" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpIntSet of handles to remove</doc>
            <type name="IntSet" c:type="TpIntSet*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <callback name="HandleSetMemberFunc" c:type="TpHandleSetMemberFunc" introspectable="0">
      <doc xml:whitespace="preserve">Signature of the callback used to iterate over the handle set in
tp_handle_set_foreach().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="set" transfer-ownership="none">
          <doc xml:whitespace="preserve">The set of handles on which tp_handle_set_foreach() was called</doc>
          <type name="HandleSet" c:type="TpHandleSet*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle in the set</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
        <parameter name="userdata" transfer-ownership="none">
          <doc xml:whitespace="preserve">Arbitrary user data as supplied to tp_handle_set_foreach()</doc>
          <type name="any" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="HandleType" c:type="TpHandleType">
      <member name="none" value="0" c:identifier="TP_HANDLE_TYPE_NONE"/>
      <member name="contact" value="1" c:identifier="TP_HANDLE_TYPE_CONTACT"/>
      <member name="room" value="2" c:identifier="TP_HANDLE_TYPE_ROOM"/>
      <member name="list" value="3" c:identifier="TP_HANDLE_TYPE_LIST"/>
      <member name="group" value="4" c:identifier="TP_HANDLE_TYPE_GROUP"/>
    </enumeration>
    <constant name="IFACE_ACCOUNT" value="org.freedesktop.Telepathy.Account">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_ACCOUNT_INTERFACE_AVATAR" value="org.freedesktop.Telepathy.Account.Interface.Avatar">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_ACCOUNT_INTERFACE_STORAGE" value="org.freedesktop.Telepathy.Account.Interface.Storage">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_ACCOUNT_MANAGER" value="org.freedesktop.Telepathy.AccountManager">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CHANNEL" value="org.freedesktop.Telepathy.Channel">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CHANNEL_DISPATCHER" value="org.freedesktop.Telepathy.ChannelDispatcher">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CHANNEL_DISPATCHER_INTERFACE_OPERATION_LIST" value="org.freedesktop.Telepathy.ChannelDispatcher.Interface.OperationList">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CHANNEL_DISPATCH_OPERATION" value="org.freedesktop.Telepathy.ChannelDispatchOperation">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_ANONYMITY" value="org.freedesktop.Telepathy.Channel.Interface.Anonymity">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_CALL_STATE" value="org.freedesktop.Telepathy.Channel.Interface.CallState">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_CHAT_STATE" value="org.freedesktop.Telepathy.Channel.Interface.ChatState">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_DESTROYABLE" value="org.freedesktop.Telepathy.Channel.Interface.Destroyable">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_DTMF" value="org.freedesktop.Telepathy.Channel.Interface.DTMF">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_GROUP" value="org.freedesktop.Telepathy.Channel.Interface.Group">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_HOLD" value="org.freedesktop.Telepathy.Channel.Interface.Hold">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_MEDIA_SIGNALLING" value="org.freedesktop.Telepathy.Channel.Interface.MediaSignalling">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_MESSAGES" value="org.freedesktop.Telepathy.Channel.Interface.Messages">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_PASSWORD" value="org.freedesktop.Telepathy.Channel.Interface.Password">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_SERVICE_POINT" value="org.freedesktop.Telepathy.Channel.Interface.ServicePoint">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_TUBE" value="org.freedesktop.Telepathy.Channel.Interface.Tube">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CHANNEL_REQUEST" value="org.freedesktop.Telepathy.ChannelRequest">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_CONTACT_LIST" value="org.freedesktop.Telepathy.Channel.Type.ContactList">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_CONTACT_SEARCH" value="org.freedesktop.Telepathy.Channel.Type.ContactSearch">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_DBUS_TUBE" value="org.freedesktop.Telepathy.Channel.Type.DBusTube">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_FILE_TRANSFER" value="org.freedesktop.Telepathy.Channel.Type.FileTransfer">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_ROOM_LIST" value="org.freedesktop.Telepathy.Channel.Type.RoomList">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_STREAMED_MEDIA" value="org.freedesktop.Telepathy.Channel.Type.StreamedMedia">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_STREAM_TUBE" value="org.freedesktop.Telepathy.Channel.Type.StreamTube">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_TEXT" value="org.freedesktop.Telepathy.Channel.Type.Text">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_TUBES" value="org.freedesktop.Telepathy.Channel.Type.Tubes">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CLIENT" value="org.freedesktop.Telepathy.Client">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CLIENT_APPROVER" value="org.freedesktop.Telepathy.Client.Approver">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CLIENT_HANDLER" value="org.freedesktop.Telepathy.Client.Handler">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CLIENT_INTERFACE_REQUESTS" value="org.freedesktop.Telepathy.Client.Interface.Requests">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CLIENT_OBSERVER" value="org.freedesktop.Telepathy.Client.Observer">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CONNECTION" value="org.freedesktop.Telepathy.Connection">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_ALIASING" value="org.freedesktop.Telepathy.Connection.Interface.Aliasing">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_ANONYMITY" value="org.freedesktop.Telepathy.Connection.Interface.Anonymity">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_AVATARS" value="org.freedesktop.Telepathy.Connection.Interface.Avatars">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_BALANCE" value="org.freedesktop.Telepathy.Connection.Interface.Balance">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_CAPABILITIES" value="org.freedesktop.Telepathy.Connection.Interface.Capabilities">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_CELLULAR" value="org.freedesktop.Telepathy.Connection.Interface.Cellular">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_CONTACTS" value="org.freedesktop.Telepathy.Connection.Interface.Contacts">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_CONTACT_CAPABILITIES" value="org.freedesktop.Telepathy.Connection.Interface.ContactCapabilities">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_CONTACT_INFO" value="org.freedesktop.Telepathy.Connection.Interface.ContactInfo">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_LOCATION" value="org.freedesktop.Telepathy.Connection.Interface.Location">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_PRESENCE" value="org.freedesktop.Telepathy.Connection.Interface.Presence">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_REQUESTS" value="org.freedesktop.Telepathy.Connection.Interface.Requests">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_SERVICE_POINT" value="org.freedesktop.Telepathy.Connection.Interface.ServicePoint">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_SIMPLE_PRESENCE" value="org.freedesktop.Telepathy.Connection.Interface.SimplePresence">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_CONNECTION_MANAGER" value="org.freedesktop.Telepathy.ConnectionManager">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_DBUS_DAEMON" value="org.freedesktop.DBus">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_DBUS_INTROSPECTABLE" value="org.freedesktop.DBus.Introspectable">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_DBUS_PEER" value="org.freedesktop.DBus.Peer">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_DBUS_PROPERTIES" value="org.freedesktop.DBus.Properties">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_DEBUG" value="org.freedesktop.Telepathy.Debug">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_MEDIA_SESSION_HANDLER" value="org.freedesktop.Telepathy.Media.SessionHandler">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_MEDIA_STREAM_HANDLER" value="org.freedesktop.Telepathy.Media.StreamHandler">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_PROPERTIES_INTERFACE" value="org.freedesktop.Telepathy.Properties">
      <type name="utf8"/>
    </constant>
    <constant name="IFACE_PROTOCOL" value="org.freedesktop.Telepathy.Protocol">
      <type name="utf8"/>
    </constant>
    <callback name="IntFunc" c:type="TpIntFunc">
      <doc xml:whitespace="preserve">A callback function acting on unsigned integers.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="i" transfer-ownership="none">
          <doc xml:whitespace="preserve">The relevant integer</doc>
          <type name="uint" c:type="guint"/>
        </parameter>
        <parameter name="userdata" transfer-ownership="none">
          <doc xml:whitespace="preserve">Opaque user data</doc>
          <type name="any" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="IntSet" c:type="TpIntSet" glib:type-name="TpIntSet" glib:get-type="tp_intset_get_type">
      <doc xml:whitespace="preserve">Opaque type representing a set of unsigned integers.</doc>
      <constructor name="new" c:identifier="tp_intset_new">
        <doc xml:whitespace="preserve">Allocate a new integer set.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new, empty integer set to be destroyed with tp_intset_destroy()</doc>
          <type name="IntSet" c:type="TpIntSet*"/>
        </return-value>
      </constructor>
      <constructor name="new_containing" c:identifier="tp_intset_new_containing">
        <doc xml:whitespace="preserve">Allocate a new integer set containing the given integer.
tp_intset_destroy()</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new integer set containing @element, to be destroyed with</doc>
          <type name="IntSet" c:type="TpIntSet*"/>
        </return-value>
        <parameters>
          <parameter name="element" transfer-ownership="none">
            <doc xml:whitespace="preserve">integer to add to a new set</doc>
            <type name="uint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="destroy" c:identifier="tp_intset_destroy">
        <doc xml:whitespace="preserve">Free all memory used by the set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="clear" c:identifier="tp_intset_clear">
        <doc xml:whitespace="preserve">Unset every integer in the set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="add" c:identifier="tp_intset_add">
        <doc xml:whitespace="preserve">Add an integer into a TpIntSet.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="element" transfer-ownership="none">
            <doc xml:whitespace="preserve">integer to add</doc>
            <type name="uint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove" c:identifier="tp_intset_remove">
        <doc xml:whitespace="preserve">Remove an integer from a TpIntSet</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @element was previously in @set</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="element" transfer-ownership="none">
            <doc xml:whitespace="preserve">integer to add</doc>
            <type name="uint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_member" c:identifier="tp_intset_is_member">
        <doc xml:whitespace="preserve">Tests if @element is a member of @set</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @element is in @set</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="element" transfer-ownership="none">
            <doc xml:whitespace="preserve">integer to test</doc>
            <type name="uint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="foreach" c:identifier="tp_intset_foreach">
        <doc xml:whitespace="preserve">Call @func(element, @userdata) for each element of @set, in order.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="func" transfer-ownership="none" scope="call" closure="2">
            <doc xml:whitespace="preserve">@TpIntFunc to use to iterate the set</doc>
            <type name="IntFunc" c:type="TpIntFunc"/>
          </parameter>
          <parameter name="userdata" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data to pass to each call of @func</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_array" c:identifier="tp_intset_to_array">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;
the same integers as @set.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a GArray of guint (which must be freed by the caller) containing</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="uint"/>
          </array>
        </return-value>
      </method>
      <method name="is_empty" c:identifier="tp_intset_is_empty" version="0.11.6">
        <doc xml:whitespace="preserve">Return the same thing as &lt;code&gt;(tp_intset_size (set) == 0)&lt;/code&gt;,
but calculated more efficiently.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @set is empty</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="size" c:identifier="tp_intset_size">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of integers in @set</doc>
          <type name="uint" c:type="guint"/>
        </return-value>
      </method>
      <method name="is_equal" c:identifier="tp_intset_is_equal">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @left and @right contain the same bits</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="right" transfer-ownership="none">
            <doc xml:whitespace="preserve">A set of integers</doc>
            <type name="IntSet" c:type="TpIntSet*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="tp_intset_copy">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;
tp_intset_destroy() by the caller</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A set containing the same integers as @orig, to be freed with</doc>
          <type name="IntSet" c:type="TpIntSet*"/>
        </return-value>
      </method>
      <method name="intersection" c:identifier="tp_intset_intersection">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;
(analogous to the bitwise operation left &amp; right), to be freed with
tp_intset_destroy() by the caller</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The set of those integers which are in both @left and @right</doc>
          <type name="IntSet" c:type="TpIntSet*"/>
        </return-value>
        <parameters>
          <parameter name="right" transfer-ownership="none">
            <doc xml:whitespace="preserve">The right operand</doc>
            <type name="IntSet" c:type="TpIntSet*"/>
          </parameter>
        </parameters>
      </method>
      <method name="union" c:identifier="tp_intset_union">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;
(analogous to the bitwise operation left | right), to be freed with
tp_intset_destroy() by the caller</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The set of those integers which are in either @left or @right</doc>
          <type name="IntSet" c:type="TpIntSet*"/>
        </return-value>
        <parameters>
          <parameter name="right" transfer-ownership="none">
            <doc xml:whitespace="preserve">The right operand</doc>
            <type name="IntSet" c:type="TpIntSet*"/>
          </parameter>
        </parameters>
      </method>
      <method name="difference" c:identifier="tp_intset_difference">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;
(analogous to the bitwise operation left &amp; (~right)), to be freed with
tp_intset_destroy() by the caller</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The set of those integers which are in @left and not in @right</doc>
          <type name="IntSet" c:type="TpIntSet*"/>
        </return-value>
        <parameters>
          <parameter name="right" transfer-ownership="none">
            <doc xml:whitespace="preserve">The right operand</doc>
            <type name="IntSet" c:type="TpIntSet*"/>
          </parameter>
        </parameters>
      </method>
      <method name="symmetric_difference" c:identifier="tp_intset_symmetric_difference">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;
but not both (analogous to the bitwise operation left ^ right), to be freed
with tp_intset_destroy() by the caller</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The set of those integers which are in either @left or @right</doc>
          <type name="IntSet" c:type="TpIntSet*"/>
        </return-value>
        <parameters>
          <parameter name="right" transfer-ownership="none">
            <doc xml:whitespace="preserve">The right operand</doc>
            <type name="IntSet" c:type="TpIntSet*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dump" c:identifier="tp_intset_dump">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;
numbers in @set in a human-readable format</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a string which the caller must free with g_free, listing the</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
    </record>
    <record name="IntSetFastIter" c:type="TpIntSetFastIter" version="0.11.6">
      <doc xml:whitespace="preserve">An opaque structure representing iteration in undefined order over a set of
integers. Must be initialized with tp_intset_fast_iter_init().
Usage is similar to #GHashTableIter:
&lt;informalexample&gt;&lt;programlisting&gt;
TpIntSetFastIter iter;
guint element;
tp_intset_fast_iter_init (&amp;amp;iter, intset);
while (tp_intset_fast_iter_next (&amp;amp;iter, &amp;amp;element))
{
printf ("%u is in the intset\n", element);
}
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
      <field name="_dummy" writable="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="16">
          <type name="any"/>
        </array>
      </field>
    </record>
    <record name="IntSetIter" c:type="TpIntSetIter">
      <doc xml:whitespace="preserve">A structure representing iteration over a set of integers. Must be
initialized with either TP_INTSET_ITER_INIT() or tp_intset_iter_init().
Since 0.11.6, consider using #TpIntSetFastIter if iteration in
numerical order is not required.</doc>
      <field name="set" writable="1">
        <type name="IntSet" c:type="TpIntSet*"/>
      </field>
      <field name="element" writable="1">
        <type name="uint" c:type="guint"/>
      </field>
    </record>
    <enumeration name="LocalHoldState" c:type="TpLocalHoldState">
      <member name="unheld" value="0" c:identifier="TP_LOCAL_HOLD_STATE_UNHELD"/>
      <member name="held" value="1" c:identifier="TP_LOCAL_HOLD_STATE_HELD"/>
      <member name="pending_hold" value="2" c:identifier="TP_LOCAL_HOLD_STATE_PENDING_HOLD"/>
      <member name="pending_unhold" value="3" c:identifier="TP_LOCAL_HOLD_STATE_PENDING_UNHOLD"/>
    </enumeration>
    <enumeration name="LocalHoldStateReason" c:type="TpLocalHoldStateReason">
      <member name="none" value="0" c:identifier="TP_LOCAL_HOLD_STATE_REASON_NONE"/>
      <member name="requested" value="1" c:identifier="TP_LOCAL_HOLD_STATE_REASON_REQUESTED"/>
      <member name="resource_not_available" value="2" c:identifier="TP_LOCAL_HOLD_STATE_REASON_RESOURCE_NOT_AVAILABLE"/>
    </enumeration>
    <enumeration name="LocationFeatures" c:type="TpLocationFeatures">
      <member name="location_feature_can_set" value="1" c:identifier="TP_LOCATION_FEATURE_CAN_SET"/>
    </enumeration>
    <constant name="MC5_BUS_NAME" value="org.freedesktop.Telepathy.MissionControl5">
      <type name="utf8"/>
    </constant>
    <enumeration name="MediaStreamBaseProto" c:type="TpMediaStreamBaseProto">
      <member name="udp" value="0" c:identifier="TP_MEDIA_STREAM_BASE_PROTO_UDP"/>
      <member name="tcp" value="1" c:identifier="TP_MEDIA_STREAM_BASE_PROTO_TCP"/>
    </enumeration>
    <enumeration name="MediaStreamDirection" c:type="TpMediaStreamDirection">
      <member name="none" value="0" c:identifier="TP_MEDIA_STREAM_DIRECTION_NONE"/>
      <member name="send" value="1" c:identifier="TP_MEDIA_STREAM_DIRECTION_SEND"/>
      <member name="receive" value="2" c:identifier="TP_MEDIA_STREAM_DIRECTION_RECEIVE"/>
      <member name="bidirectional" value="3" c:identifier="TP_MEDIA_STREAM_DIRECTION_BIDIRECTIONAL"/>
    </enumeration>
    <enumeration name="MediaStreamError" c:type="TpMediaStreamError">
      <member name="unknown" value="0" c:identifier="TP_MEDIA_STREAM_ERROR_UNKNOWN"/>
      <member name="eos" value="1" c:identifier="TP_MEDIA_STREAM_ERROR_EOS"/>
      <member name="codec_negotiation_failed" value="2" c:identifier="TP_MEDIA_STREAM_ERROR_CODEC_NEGOTIATION_FAILED"/>
      <member name="connection_failed" value="3" c:identifier="TP_MEDIA_STREAM_ERROR_CONNECTION_FAILED"/>
      <member name="network_error" value="4" c:identifier="TP_MEDIA_STREAM_ERROR_NETWORK_ERROR"/>
      <member name="no_codecs" value="5" c:identifier="TP_MEDIA_STREAM_ERROR_NO_CODECS"/>
      <member name="invalid_cm_behavior" value="6" c:identifier="TP_MEDIA_STREAM_ERROR_INVALID_CM_BEHAVIOR"/>
      <member name="media_error" value="7" c:identifier="TP_MEDIA_STREAM_ERROR_MEDIA_ERROR"/>
    </enumeration>
    <enumeration name="MediaStreamPendingSend" c:type="TpMediaStreamPendingSend">
      <member name="local_send" value="1" c:identifier="TP_MEDIA_STREAM_PENDING_LOCAL_SEND"/>
      <member name="remote_send" value="2" c:identifier="TP_MEDIA_STREAM_PENDING_REMOTE_SEND"/>
    </enumeration>
    <enumeration name="MediaStreamState" c:type="TpMediaStreamState">
      <member name="disconnected" value="0" c:identifier="TP_MEDIA_STREAM_STATE_DISCONNECTED"/>
      <member name="connecting" value="1" c:identifier="TP_MEDIA_STREAM_STATE_CONNECTING"/>
      <member name="connected" value="2" c:identifier="TP_MEDIA_STREAM_STATE_CONNECTED"/>
    </enumeration>
    <enumeration name="MediaStreamTransportType" c:type="TpMediaStreamTransportType">
      <member name="local" value="0" c:identifier="TP_MEDIA_STREAM_TRANSPORT_TYPE_LOCAL"/>
      <member name="derived" value="1" c:identifier="TP_MEDIA_STREAM_TRANSPORT_TYPE_DERIVED"/>
      <member name="relay" value="2" c:identifier="TP_MEDIA_STREAM_TRANSPORT_TYPE_RELAY"/>
    </enumeration>
    <enumeration name="MediaStreamType" c:type="TpMediaStreamType">
      <member name="audio" value="0" c:identifier="TP_MEDIA_STREAM_TYPE_AUDIO"/>
      <member name="video" value="1" c:identifier="TP_MEDIA_STREAM_TYPE_VIDEO"/>
    </enumeration>
    <enumeration name="MessagePartSupportFlags" c:type="TpMessagePartSupportFlags">
      <member name="one_attachment" value="1" c:identifier="TP_MESSAGE_PART_SUPPORT_FLAG_ONE_ATTACHMENT"/>
      <member name="multiple_attachments" value="2" c:identifier="TP_MESSAGE_PART_SUPPORT_FLAG_MULTIPLE_ATTACHMENTS"/>
    </enumeration>
    <enumeration name="MessageSendingFlags" c:type="TpMessageSendingFlags">
      <member name="delivery" value="1" c:identifier="TP_MESSAGE_SENDING_FLAG_REPORT_DELIVERY"/>
      <member name="read" value="2" c:identifier="TP_MESSAGE_SENDING_FLAG_REPORT_READ"/>
      <member name="deleted" value="4" c:identifier="TP_MESSAGE_SENDING_FLAG_REPORT_DELETED"/>
    </enumeration>
    <constant name="NUM_TP_CHANNEL_CHAT_STATES" value="5">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_CHANNEL_CONTACT_SEARCH_STATES" value="5">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_CHANNEL_GROUP_CHANGE_REASONS" value="12">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_CHANNEL_TEXT_MESSAGE_TYPES" value="5">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_CHANNEL_TEXT_SEND_ERRORS" value="6">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_CONNECTION_PRESENCE_TYPES" value="9">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_CONNECTION_STATUSES" value="3">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_CONNECTION_STATUS_REASONS" value="17">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_CONTACT_FEATURES" value="1">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_DBUS_ERRORS" value="1">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_DEBUG_LEVELS" value="6">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_DELIVERY_STATUSES" value="7">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_DTMF_EVENTS" value="16">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_FILE_HASH_TYPES" value="4">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_FILE_TRANSFER_STATES" value="6">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_FILE_TRANSFER_STATE_CHANGE_REASONS" value="6">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_HANDLE_TYPES" value="5">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_LOCAL_HOLD_STATES" value="4">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_LOCAL_HOLD_STATE_REASONS" value="3">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_MEDIA_STREAM_BASE_PROTOS" value="2">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_MEDIA_STREAM_DIRECTIONS" value="4">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_MEDIA_STREAM_ERRORS" value="8">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_MEDIA_STREAM_STATES" value="3">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_MEDIA_STREAM_TRANSPORT_TYPES" value="3">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_MEDIA_STREAM_TYPES" value="2">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_RICH_PRESENCE_ACCESS_CONTROL_TYPES" value="4">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_SERVICE_POINT_TYPES" value="3">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_SOCKET_ACCESS_CONTROLS" value="4">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_SOCKET_ADDRESS_TYPES" value="4">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_TUBE_CHANNEL_STATES" value="4">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_TUBE_STATES" value="3">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_TUBE_TYPES" value="2">
      <type name="int"/>
    </constant>
    <class name="ObserveChannelsContext" c:type="TpObserveChannelsContext" version="0.11.5" parent="GObject.Object" glib:type-name="TpObserveChannelsContext" glib:get-type="tp_observe_channels_context_get_type" glib:type-struct="ObserveChannelsContextClass">
      <doc xml:whitespace="preserve">Data structure representing the context of a Observer.ObserveChannels()
call.</doc>
      <method name="accept" c:identifier="tp_observe_channels_context_accept" version="0.11.5">
        <doc xml:whitespace="preserve">Called by #TpBaseClientClassObserveChannelsImpl when it's done so the D-Bus
method can return.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="fail" c:identifier="tp_observe_channels_context_fail" version="0.11.5">
        <doc xml:whitespace="preserve">Called by #TpBaseClientClassObserveChannelsImpl to raise a D-Bus error.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="error" transfer-ownership="none">
            <doc xml:whitespace="preserve">the error to return from the method</doc>
            <type name="GLib.Error" c:type="GError*"/>
          </parameter>
        </parameters>
      </method>
      <method name="delay" c:identifier="tp_observe_channels_context_delay" version="0.11.5">
        <doc xml:whitespace="preserve">Called by #TpBaseClientClassObserveChannelsImpl to indicate that it
implements the method in an async way. The caller must take a reference
to the #TpObserveChannelsContext before calling this function, and
is responsible for calling either tp_observe_channels_context_accept() or
tp_observe_channels_context_fail() later.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="is_recovering" c:identifier="tp_observe_channels_context_is_recovering" version="0.11.5">
        <doc xml:whitespace="preserve">If this call to ObserveChannels is for channels that already
existed before this observer started (because the observer used
tp_base_client_set_observer_recover()), return %TRUE.
In most cases, the result is %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE for pre-existing channels, %FALSE for new channels</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
      </method>
      <property name="account" version="0.11.5" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TpAccount object representing the Account that has been passed to
ObserveChannels.
Read-only except during construction.
This property can't be %NULL.</doc>
        <type name="Account" c:type="TpAccount"/>
      </property>
      <property name="channels" version="0.11.5" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GPtrArray containing #TpChannel objects representing the channels
that have been passed to ObserveChannels.
Read-only except during construction.
This property can't be %NULL.</doc>
        <type name="GLib.PtrArray" c:type="GPtrArray"/>
      </property>
      <property name="connection" version="0.11.5" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TpConnection object representing the Connection that has been passed
to ObserveChannels.
Read-only except during construction.
This property can't be %NULL.</doc>
        <type name="Connection" c:type="TpConnection"/>
      </property>
      <property name="dbus-context" version="0.11.5" introspectable="0" readable="0" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The #DBusGMethodInvocation representing the D-Bus context of the
ObserveChannels call.
Can only be written during construction.</doc>
        <type name="any" c:type="gpointer"/>
      </property>
      <property name="dispatch-operation" version="0.11.5" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TpChannelDispatchOperation object representing the
ChannelDispatchOperation that has been passed to ObserveChannels,
or %NULL if none has been passed.
Read-only except during construction.</doc>
        <type name="ChannelDispatchOperation" c:type="TpChannelDispatchOperation"/>
      </property>
      <property name="requests" version="0.11.5" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GPtrArray containing #TpChannelRequest objects representing the
requests that have been passed to ObserveChannels.
Read-only except during construction.
This property can't be %NULL.</doc>
        <type name="GLib.PtrArray" c:type="GPtrArray"/>
      </property>
    </class>
    <record name="ObserveChannelsContextClass" c:type="TpObserveChannelsContextClass" glib:is-gtype-struct-for="ObserveChannelsContext" version="0.11.5">
      <doc xml:whitespace="preserve">The class of a #TpObserveChannelsContext.</doc>
    </record>
    <record name="ObserveChannelsContextPrivate" c:type="TpObserveChannelsContextPrivate">
    </record>
    <constant name="PROP_ACCOUNT_AUTOMATIC_PRESENCE" value="org.freedesktop.Telepathy.Account.AutomaticPresence">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_ACCOUNT_CHANGING_PRESENCE" value="org.freedesktop.Telepathy.Account.ChangingPresence">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_ACCOUNT_CONNECTION" value="org.freedesktop.Telepathy.Account.Connection">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_ACCOUNT_CONNECTION_ERROR" value="org.freedesktop.Telepathy.Account.ConnectionError">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_ACCOUNT_CONNECTION_ERROR_DETAILS" value="org.freedesktop.Telepathy.Account.ConnectionErrorDetails">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_ACCOUNT_CONNECTION_STATUS" value="org.freedesktop.Telepathy.Account.ConnectionStatus">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_ACCOUNT_CONNECTION_STATUS_REASON" value="org.freedesktop.Telepathy.Account.ConnectionStatusReason">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_ACCOUNT_CONNECT_AUTOMATICALLY" value="org.freedesktop.Telepathy.Account.ConnectAutomatically">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_ACCOUNT_CURRENT_PRESENCE" value="org.freedesktop.Telepathy.Account.CurrentPresence">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_ACCOUNT_DISPLAY_NAME" value="org.freedesktop.Telepathy.Account.DisplayName">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_ACCOUNT_ENABLED" value="org.freedesktop.Telepathy.Account.Enabled">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_ACCOUNT_HAS_BEEN_ONLINE" value="org.freedesktop.Telepathy.Account.HasBeenOnline">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_ACCOUNT_ICON" value="org.freedesktop.Telepathy.Account.Icon">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_ACCOUNT_INTERFACES" value="org.freedesktop.Telepathy.Account.Interfaces">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_ACCOUNT_INTERFACE_AVATAR_AVATAR" value="org.freedesktop.Telepathy.Account.Interface.Avatar.Avatar">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_ACCOUNT_INTERFACE_STORAGE_STORAGE_IDENTIFIER" value="org.freedesktop.Telepathy.Account.Interface.Storage.StorageIdentifier">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_ACCOUNT_INTERFACE_STORAGE_STORAGE_PROVIDER" value="org.freedesktop.Telepathy.Account.Interface.Storage.StorageProvider">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_ACCOUNT_INTERFACE_STORAGE_STORAGE_RESTRICTIONS" value="org.freedesktop.Telepathy.Account.Interface.Storage.StorageRestrictions">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_ACCOUNT_INTERFACE_STORAGE_STORAGE_SPECIFIC_INFORMATION" value="org.freedesktop.Telepathy.Account.Interface.Storage.StorageSpecificInformation">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_ACCOUNT_MANAGER_INTERFACES" value="org.freedesktop.Telepathy.AccountManager.Interfaces">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_ACCOUNT_MANAGER_INVALID_ACCOUNTS" value="org.freedesktop.Telepathy.AccountManager.InvalidAccounts">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_ACCOUNT_MANAGER_SUPPORTED_ACCOUNT_PROPERTIES" value="org.freedesktop.Telepathy.AccountManager.SupportedAccountProperties">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_ACCOUNT_MANAGER_VALID_ACCOUNTS" value="org.freedesktop.Telepathy.AccountManager.ValidAccounts">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_ACCOUNT_NICKNAME" value="org.freedesktop.Telepathy.Account.Nickname">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_ACCOUNT_NORMALIZED_NAME" value="org.freedesktop.Telepathy.Account.NormalizedName">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_ACCOUNT_PARAMETERS" value="org.freedesktop.Telepathy.Account.Parameters">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_ACCOUNT_REQUESTED_PRESENCE" value="org.freedesktop.Telepathy.Account.RequestedPresence">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_ACCOUNT_SERVICE" value="org.freedesktop.Telepathy.Account.Service">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_ACCOUNT_VALID" value="org.freedesktop.Telepathy.Account.Valid">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_CHANNEL_TYPE" value="org.freedesktop.Telepathy.Channel.ChannelType">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_DISPATCHER_INTERFACES" value="org.freedesktop.Telepathy.ChannelDispatcher.Interfaces">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_DISPATCHER_INTERFACE_OPERATION_LIST_DISPATCH_OPERATIONS" value="org.freedesktop.Telepathy.ChannelDispatcher.Interface.OperationList.DispatchOperations">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_DISPATCH_OPERATION_ACCOUNT" value="org.freedesktop.Telepathy.ChannelDispatchOperation.Account">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_DISPATCH_OPERATION_CHANNELS" value="org.freedesktop.Telepathy.ChannelDispatchOperation.Channels">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_DISPATCH_OPERATION_CONNECTION" value="org.freedesktop.Telepathy.ChannelDispatchOperation.Connection">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_DISPATCH_OPERATION_INTERFACES" value="org.freedesktop.Telepathy.ChannelDispatchOperation.Interfaces">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_DISPATCH_OPERATION_POSSIBLE_HANDLERS" value="org.freedesktop.Telepathy.ChannelDispatchOperation.PossibleHandlers">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_INITIATOR_HANDLE" value="org.freedesktop.Telepathy.Channel.InitiatorHandle">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_INITIATOR_ID" value="org.freedesktop.Telepathy.Channel.InitiatorID">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACES" value="org.freedesktop.Telepathy.Channel.Interfaces">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ANONYMITY_ANONYMITY_MANDATORY" value="org.freedesktop.Telepathy.Channel.Interface.Anonymity.AnonymityMandatory">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ANONYMITY_ANONYMITY_MODES" value="org.freedesktop.Telepathy.Channel.Interface.Anonymity.AnonymityModes">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ANONYMITY_ANONYMOUS_ID" value="org.freedesktop.Telepathy.Channel.Interface.Anonymity.AnonymousID">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_CHAT_STATE_CHAT_STATES" value="org.freedesktop.Telepathy.Channel.Interface.ChatState.ChatStates">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_DTMF_CURRENTLY_SENDING_TONES" value="org.freedesktop.Telepathy.Channel.Interface.DTMF.CurrentlySendingTones">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_DTMF_INITIAL_TONES" value="org.freedesktop.Telepathy.Channel.Interface.DTMF.InitialTones">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_GROUP_GROUP_FLAGS" value="org.freedesktop.Telepathy.Channel.Interface.Group.GroupFlags">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_GROUP_HANDLE_OWNERS" value="org.freedesktop.Telepathy.Channel.Interface.Group.HandleOwners">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_GROUP_LOCAL_PENDING_MEMBERS" value="org.freedesktop.Telepathy.Channel.Interface.Group.LocalPendingMembers">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_GROUP_MEMBERS" value="org.freedesktop.Telepathy.Channel.Interface.Group.Members">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_GROUP_REMOTE_PENDING_MEMBERS" value="org.freedesktop.Telepathy.Channel.Interface.Group.RemotePendingMembers">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_GROUP_SELF_HANDLE" value="org.freedesktop.Telepathy.Channel.Interface.Group.SelfHandle">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_MESSAGES_DELIVERY_REPORTING_SUPPORT" value="org.freedesktop.Telepathy.Channel.Interface.Messages.DeliveryReportingSupport">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_MESSAGES_MESSAGE_PART_SUPPORT_FLAGS" value="org.freedesktop.Telepathy.Channel.Interface.Messages.MessagePartSupportFlags">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_MESSAGES_PENDING_MESSAGES" value="org.freedesktop.Telepathy.Channel.Interface.Messages.PendingMessages">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_MESSAGES_SUPPORTED_CONTENT_TYPES" value="org.freedesktop.Telepathy.Channel.Interface.Messages.SupportedContentTypes">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SERVICE_POINT_CURRENT_SERVICE_POINT" value="org.freedesktop.Telepathy.Channel.Interface.ServicePoint.CurrentServicePoint">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SERVICE_POINT_INITIAL_SERVICE_POINT" value="org.freedesktop.Telepathy.Channel.Interface.ServicePoint.InitialServicePoint">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_TUBE_PARAMETERS" value="org.freedesktop.Telepathy.Channel.Interface.Tube.Parameters">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_TUBE_STATE" value="org.freedesktop.Telepathy.Channel.Interface.Tube.State">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_REQUESTED" value="org.freedesktop.Telepathy.Channel.Requested">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_REQUEST_ACCOUNT" value="org.freedesktop.Telepathy.ChannelRequest.Account">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_REQUEST_INTERFACES" value="org.freedesktop.Telepathy.ChannelRequest.Interfaces">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_REQUEST_PREFERRED_HANDLER" value="org.freedesktop.Telepathy.ChannelRequest.PreferredHandler">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_REQUEST_REQUESTS" value="org.freedesktop.Telepathy.ChannelRequest.Requests">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_REQUEST_USER_ACTION_TIME" value="org.freedesktop.Telepathy.ChannelRequest.UserActionTime">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_TARGET_HANDLE" value="org.freedesktop.Telepathy.Channel.TargetHandle">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_TARGET_HANDLE_TYPE" value="org.freedesktop.Telepathy.Channel.TargetHandleType">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_TARGET_ID" value="org.freedesktop.Telepathy.Channel.TargetID">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CONTACT_SEARCH_AVAILABLE_SEARCH_KEYS" value="org.freedesktop.Telepathy.Channel.Type.ContactSearch.AvailableSearchKeys">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CONTACT_SEARCH_LIMIT" value="org.freedesktop.Telepathy.Channel.Type.ContactSearch.Limit">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CONTACT_SEARCH_SEARCH_STATE" value="org.freedesktop.Telepathy.Channel.Type.ContactSearch.SearchState">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CONTACT_SEARCH_SERVER" value="org.freedesktop.Telepathy.Channel.Type.ContactSearch.Server">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_DBUS_TUBE_DBUS_NAMES" value="org.freedesktop.Telepathy.Channel.Type.DBusTube.DBusNames">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_DBUS_TUBE_SERVICE_NAME" value="org.freedesktop.Telepathy.Channel.Type.DBusTube.ServiceName">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_DBUS_TUBE_SUPPORTED_ACCESS_CONTROLS" value="org.freedesktop.Telepathy.Channel.Type.DBusTube.SupportedAccessControls">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_AVAILABLE_SOCKET_TYPES" value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.AvailableSocketTypes">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_CONTENT_HASH" value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.ContentHash">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_CONTENT_HASH_TYPE" value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.ContentHashType">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_CONTENT_TYPE" value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.ContentType">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_DATE" value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.Date">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_DESCRIPTION" value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.Description">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_FILENAME" value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.Filename">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_INITIAL_OFFSET" value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.InitialOffset">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_SIZE" value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.Size">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_STATE" value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.State">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_TRANSFERRED_BYTES" value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.TransferredBytes">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_ROOM_LIST_SERVER" value="org.freedesktop.Telepathy.Channel.Type.RoomList.Server">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_STREAMED_MEDIA_IMMUTABLE_STREAMS" value="org.freedesktop.Telepathy.Channel.Type.StreamedMedia.ImmutableStreams">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_STREAMED_MEDIA_INITIAL_AUDIO" value="org.freedesktop.Telepathy.Channel.Type.StreamedMedia.InitialAudio">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_STREAMED_MEDIA_INITIAL_VIDEO" value="org.freedesktop.Telepathy.Channel.Type.StreamedMedia.InitialVideo">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_STREAM_TUBE_SERVICE" value="org.freedesktop.Telepathy.Channel.Type.StreamTube.Service">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_STREAM_TUBE_SUPPORTED_SOCKET_TYPES" value="org.freedesktop.Telepathy.Channel.Type.StreamTube.SupportedSocketTypes">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CLIENT_APPROVER_APPROVER_CHANNEL_FILTER" value="org.freedesktop.Telepathy.Client.Approver.ApproverChannelFilter">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CLIENT_HANDLER_BYPASS_APPROVAL" value="org.freedesktop.Telepathy.Client.Handler.BypassApproval">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CLIENT_HANDLER_CAPABILITIES" value="org.freedesktop.Telepathy.Client.Handler.Capabilities">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CLIENT_HANDLER_HANDLED_CHANNELS" value="org.freedesktop.Telepathy.Client.Handler.HandledChannels">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CLIENT_HANDLER_HANDLER_CHANNEL_FILTER" value="org.freedesktop.Telepathy.Client.Handler.HandlerChannelFilter">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CLIENT_INTERFACES" value="org.freedesktop.Telepathy.Client.Interfaces">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CLIENT_OBSERVER_OBSERVER_CHANNEL_FILTER" value="org.freedesktop.Telepathy.Client.Observer.ObserverChannelFilter">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CLIENT_OBSERVER_RECOVER" value="org.freedesktop.Telepathy.Client.Observer.Recover">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACES" value="org.freedesktop.Telepathy.Connection.Interfaces">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_ANONYMITY_ANONYMITY_MANDATORY" value="org.freedesktop.Telepathy.Connection.Interface.Anonymity.AnonymityMandatory">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_ANONYMITY_ANONYMITY_MODES" value="org.freedesktop.Telepathy.Connection.Interface.Anonymity.AnonymityModes">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_ANONYMITY_SUPPORTED_ANONYMITY_MODES" value="org.freedesktop.Telepathy.Connection.Interface.Anonymity.SupportedAnonymityModes">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_AVATARS_MAXIMUM_AVATAR_BYTES" value="org.freedesktop.Telepathy.Connection.Interface.Avatars.MaximumAvatarBytes">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_AVATARS_MAXIMUM_AVATAR_HEIGHT" value="org.freedesktop.Telepathy.Connection.Interface.Avatars.MaximumAvatarHeight">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_AVATARS_MAXIMUM_AVATAR_WIDTH" value="org.freedesktop.Telepathy.Connection.Interface.Avatars.MaximumAvatarWidth">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_AVATARS_MINIMUM_AVATAR_HEIGHT" value="org.freedesktop.Telepathy.Connection.Interface.Avatars.MinimumAvatarHeight">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_AVATARS_MINIMUM_AVATAR_WIDTH" value="org.freedesktop.Telepathy.Connection.Interface.Avatars.MinimumAvatarWidth">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_AVATARS_RECOMMENDED_AVATAR_HEIGHT" value="org.freedesktop.Telepathy.Connection.Interface.Avatars.RecommendedAvatarHeight">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_AVATARS_RECOMMENDED_AVATAR_WIDTH" value="org.freedesktop.Telepathy.Connection.Interface.Avatars.RecommendedAvatarWidth">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_AVATARS_SUPPORTED_AVATAR_MIME_TYPES" value="org.freedesktop.Telepathy.Connection.Interface.Avatars.SupportedAvatarMIMETypes">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_BALANCE_ACCOUNT_BALANCE" value="org.freedesktop.Telepathy.Connection.Interface.Balance.AccountBalance">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CELLULAR_IMSI" value="org.freedesktop.Telepathy.Connection.Interface.Cellular.IMSI">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CELLULAR_MESSAGE_REDUCED_CHARACTER_SET" value="org.freedesktop.Telepathy.Connection.Interface.Cellular.MessageReducedCharacterSet">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CELLULAR_MESSAGE_SERVICE_CENTRE" value="org.freedesktop.Telepathy.Connection.Interface.Cellular.MessageServiceCentre">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CELLULAR_MESSAGE_VALIDITY_PERIOD" value="org.freedesktop.Telepathy.Connection.Interface.Cellular.MessageValidityPeriod">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CONTACTS_CONTACT_ATTRIBUTE_INTERFACES" value="org.freedesktop.Telepathy.Connection.Interface.Contacts.ContactAttributeInterfaces">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CONTACT_INFO_CONTACT_INFO_FLAGS" value="org.freedesktop.Telepathy.Connection.Interface.ContactInfo.ContactInfoFlags">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CONTACT_INFO_SUPPORTED_FIELDS" value="org.freedesktop.Telepathy.Connection.Interface.ContactInfo.SupportedFields">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_LOCATION_LOCATION_ACCESS_CONTROL" value="org.freedesktop.Telepathy.Connection.Interface.Location.LocationAccessControl">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_LOCATION_LOCATION_ACCESS_CONTROL_TYPES" value="org.freedesktop.Telepathy.Connection.Interface.Location.LocationAccessControlTypes">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_LOCATION_SUPPORTED_LOCATION_FEATURES" value="org.freedesktop.Telepathy.Connection.Interface.Location.SupportedLocationFeatures">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_REQUESTS_CHANNELS" value="org.freedesktop.Telepathy.Connection.Interface.Requests.Channels">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_REQUESTS_REQUESTABLE_CHANNEL_CLASSES" value="org.freedesktop.Telepathy.Connection.Interface.Requests.RequestableChannelClasses">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_SERVICE_POINT_KNOWN_SERVICE_POINTS" value="org.freedesktop.Telepathy.Connection.Interface.ServicePoint.KnownServicePoints">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_SIMPLE_PRESENCE_STATUSES" value="org.freedesktop.Telepathy.Connection.Interface.SimplePresence.Statuses">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CONNECTION_MANAGER_INTERFACES" value="org.freedesktop.Telepathy.ConnectionManager.Interfaces">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CONNECTION_MANAGER_PROTOCOLS" value="org.freedesktop.Telepathy.ConnectionManager.Protocols">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CONNECTION_SELF_HANDLE" value="org.freedesktop.Telepathy.Connection.SelfHandle">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_CONNECTION_STATUS" value="org.freedesktop.Telepathy.Connection.Status">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_DEBUG_ENABLED" value="org.freedesktop.Telepathy.Debug.Enabled">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_MEDIA_STREAM_HANDLER_CREATED_LOCALLY" value="org.freedesktop.Telepathy.Media.StreamHandler.CreatedLocally">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_MEDIA_STREAM_HANDLER_NAT_TRAVERSAL" value="org.freedesktop.Telepathy.Media.StreamHandler.NATTraversal">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_MEDIA_STREAM_HANDLER_RELAY_INFO" value="org.freedesktop.Telepathy.Media.StreamHandler.RelayInfo">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_MEDIA_STREAM_HANDLER_STUN_SERVERS" value="org.freedesktop.Telepathy.Media.StreamHandler.STUNServers">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_PROTOCOL_CONNECTION_INTERFACES" value="org.freedesktop.Telepathy.Protocol.ConnectionInterfaces">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_PROTOCOL_ENGLISH_NAME" value="org.freedesktop.Telepathy.Protocol.EnglishName">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_PROTOCOL_ICON" value="org.freedesktop.Telepathy.Protocol.Icon">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_PROTOCOL_INTERFACES" value="org.freedesktop.Telepathy.Protocol.Interfaces">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_PROTOCOL_PARAMETERS" value="org.freedesktop.Telepathy.Protocol.Parameters">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_PROTOCOL_REQUESTABLE_CHANNEL_CLASSES" value="org.freedesktop.Telepathy.Protocol.RequestableChannelClasses">
      <type name="utf8"/>
    </constant>
    <constant name="PROP_PROTOCOL_VCARD_FIELD" value="org.freedesktop.Telepathy.Protocol.VCardField">
      <type name="utf8"/>
    </constant>
    <constant name="PROTOCOL_PREFIX_LEN" value="9">
      <type name="int"/>
    </constant>
    <record name="PresenceMixin" c:type="TpPresenceMixin">
      <doc xml:whitespace="preserve">Structure to be included in the instance structure of objects that
use this mixin. Initialize it with tp_presence_mixin_init().
There are no public fields.</doc>
      <field name="priv" writable="1">
        <type name="PresenceMixinPrivate" c:type="TpPresenceMixinPrivate*"/>
      </field>
    </record>
    <record name="PresenceMixinClass" c:type="TpPresenceMixinClass">
      <doc xml:whitespace="preserve">Structure to be included in the class structure of objects that
use this mixin. Initialize it with tp_presence_mixin_class_init().
All fields should be considered read-only.</doc>
      <field name="status_available" writable="1">
        <type name="PresenceMixinStatusAvailableFunc" c:type="TpPresenceMixinStatusAvailableFunc"/>
      </field>
      <field name="get_contact_statuses" writable="1">
        <type name="PresenceMixinGetContactStatusesFunc" c:type="TpPresenceMixinGetContactStatusesFunc"/>
      </field>
      <field name="set_own_status" writable="1">
        <type name="PresenceMixinSetOwnStatusFunc" c:type="TpPresenceMixinSetOwnStatusFunc"/>
      </field>
      <field name="statuses" writable="1">
        <type name="PresenceStatusSpec" c:type="TpPresenceStatusSpec*"/>
      </field>
      <field name="priv" writable="1">
        <type name="PresenceMixinClassPrivate" c:type="TpPresenceMixinClassPrivate*"/>
      </field>
      <field name="_future1" writable="1">
        <type name="any" c:type="gpointer"/>
      </field>
      <field name="_future2" writable="1">
        <type name="any" c:type="gpointer"/>
      </field>
      <field name="_future3" writable="1">
        <type name="any" c:type="gpointer"/>
      </field>
      <field name="_future4" writable="1">
        <type name="any" c:type="gpointer"/>
      </field>
    </record>
    <record name="PresenceMixinClassPrivate" c:type="TpPresenceMixinClassPrivate">
    </record>
    <callback name="PresenceMixinGetContactStatusesFunc" c:type="TpPresenceMixinGetContactStatusesFunc" throws="1">
      <doc xml:whitespace="preserve">Signature of the callback used to get the stored presence status of
contacts. The returned hash table should have contact handles mapped to
their respective presence statuses in #TpPresenceStatus structs.
The returned hash table will be freed with g_hash_table_destroy. The
callback is responsible for ensuring that this does any cleanup that
may be necessary.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">The contact presence on success, %NULL with error set on error</doc>
        <type name="GLib.HashTable" c:type="GHashTable*"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object with this mixin.</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="contacts" transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of #TpHandle for the contacts to get presence status for</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="any" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </callback>
    <record name="PresenceMixinPrivate" c:type="TpPresenceMixinPrivate">
    </record>
    <callback name="PresenceMixinSetOwnStatusFunc" c:type="TpPresenceMixinSetOwnStatusFunc" throws="1">
      <doc xml:whitespace="preserve">Signature of the callback used to commit changes to the user's own presence
status in SetStatuses. It is also used in ClearStatus and RemoveStatus to
reset the user's own status back to the "default" one with a %NULL status
argument.
The optional_arguments hash table in @status, if not NULL, will have been
filtered so it only contains recognised parameters, so the callback
need not (and cannot) check for unrecognised parameters. However, the
types of the parameters are not currently checked, so the callback is
responsible for doing so.
The callback is responsible for emitting PresenceUpdate, if appropriate,
by calling tp_presence_mixin_emit_presence_update().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the operation was successful, %FALSE if not.</doc>
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object with this mixin.</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="status" transfer-ownership="none">
          <doc xml:whitespace="preserve">The status to set, or NULL for whatever the protocol defines as a "default" status</doc>
          <type name="PresenceStatus" c:type="TpPresenceStatus*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="PresenceMixinStatusAvailableFunc" c:type="TpPresenceMixinStatusAvailableFunc">
      <doc xml:whitespace="preserve">Signature of the callback used to determine if a given status is currently
available to be set on the connection.
When implementing the
org.freedesktop.Telepathy.Connection.Interface.SimplePresence interface
this can be called while DISCONNECTED to determine which statuses can be set
in that state.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the status is available, %FALSE if not.</doc>
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the presence interface with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="which" transfer-ownership="none">
          <doc xml:whitespace="preserve">The index of the presence status in the provided supported presence statuses array</doc>
          <type name="uint" c:type="guint"/>
        </parameter>
      </parameters>
    </callback>
    <record name="PresenceStatus" c:type="TpPresenceStatus">
      <doc xml:whitespace="preserve">Structure representing a presence status.
In addition to the fields documented here, there are two gpointer fields
which must currently be %NULL. A meaning may be defined for these in a
future version of telepathy-glib.</doc>
      <field name="index" writable="1">
        <type name="uint" c:type="guint"/>
      </field>
      <field name="optional_arguments" writable="1">
        <type name="GLib.HashTable" c:type="GHashTable*"/>
      </field>
      <field name="_future1" writable="1">
        <type name="any" c:type="gpointer"/>
      </field>
      <field name="_future2" writable="1">
        <type name="any" c:type="gpointer"/>
      </field>
      <constructor name="new" c:identifier="tp_presence_status_new" introspectable="0">
        <doc xml:whitespace="preserve">Construct a presence status structure. You should free the returned
structure with #tp_presence_status_free.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A pointer to the newly allocated presence status structure.</doc>
          <type name="PresenceStatus" c:type="TpPresenceStatus*"/>
        </return-value>
        <parameters>
          <parameter name="which" transfer-ownership="none">
            <doc xml:whitespace="preserve">Index of the presence status in the provided supported presence statuses array</doc>
            <type name="uint" c:type="guint"/>
          </parameter>
          <parameter name="optional_arguments" transfer-ownership="none">
            <doc xml:whitespace="preserve">Optional arguments for the presence statuses. Can be NULL if there are no optional arguments. The presence status object makes a copy of the hashtable, so you should free the original.</doc>
            <type name="GLib.HashTable" c:type="GHashTable*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="free" c:identifier="tp_presence_status_free" introspectable="0">
        <doc xml:whitespace="preserve">Deallocate all resources associated with a presence status structure.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <record name="PresenceStatusOptionalArgumentSpec" c:type="TpPresenceStatusOptionalArgumentSpec">
      <field name="name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="dtype" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="_future1" writable="1">
        <type name="any" c:type="gpointer"/>
      </field>
      <field name="_future2" writable="1">
        <type name="any" c:type="gpointer"/>
      </field>
    </record>
    <record name="PresenceStatusSpec" c:type="TpPresenceStatusSpec">
      <field name="name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="presence_type" writable="1">
        <type name="ConnectionPresenceType" c:type="TpConnectionPresenceType"/>
      </field>
      <field name="self" writable="1">
        <type name="boolean" c:type="gboolean"/>
      </field>
      <field name="optional_arguments" writable="1">
        <type name="PresenceStatusOptionalArgumentSpec" c:type="TpPresenceStatusOptionalArgumentSpec*"/>
      </field>
      <field name="_future1" writable="1">
        <type name="any" c:type="gpointer"/>
      </field>
      <field name="_future2" writable="1">
        <type name="any" c:type="gpointer"/>
      </field>
    </record>
    <enumeration name="PropertyFlags" c:type="TpPropertyFlags">
      <member name="read" value="1" c:identifier="TP_PROPERTY_FLAG_READ"/>
      <member name="write" value="2" c:identifier="TP_PROPERTY_FLAG_WRITE"/>
    </enumeration>
    <class name="Protocol" c:type="TpProtocol" version="0.11.11" parent="Proxy" glib:type-name="TpProtocol" glib:get-type="tp_protocol_get_type" glib:type-struct="ProtocolClass">
      <doc xml:whitespace="preserve">A base class for connection managers' protocols.</doc>
      <constructor name="new" c:identifier="tp_protocol_new" version="0.11.11" throws="1">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new protocol proxy, or %NULL on invalid arguments</doc>
          <type name="Protocol" c:type="TpProtocol*"/>
        </return-value>
        <parameters>
          <parameter name="dbus" transfer-ownership="none">
            <doc xml:whitespace="preserve">proxy for the D-Bus daemon; may not be %NULL</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
          <parameter name="cm_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the connection manager name (such as "gabble")</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="protocol_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the protocol name (such as "jabber")</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <doc xml:whitespace="preserve">the immutable D-Bus properties for this protocol</doc>
            <type name="GLib.HashTable" c:type="GHashTable*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="init_known_interfaces" c:identifier="tp_protocol_init_known_interfaces" version="0.11.11">
        <doc xml:whitespace="preserve">Ensure that the known interfaces for TpProtocol have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_PROTOCOL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <function name="get_feature_quark_parameters" c:identifier="tp_protocol_get_feature_quark_parameters">
        <return-value transfer-ownership="full">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_core" c:identifier="tp_protocol_get_feature_quark_core">
        <return-value transfer-ownership="full">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <method name="get_name" c:identifier="tp_protocol_get_name" version="0.11.11">
        <doc xml:whitespace="preserve">Return the same thing as the protocol-name property, for convenient use
in C code. The returned string is valid for as long as @self exists.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of the #TpProtocol:protocol-name property</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_param" c:identifier="tp_protocol_get_param" version="0.11.11">
        <doc xml:whitespace="preserve">&lt;!-- no more to say --&gt;
supported</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a structure representing the parameter @param, or %NULL if not</doc>
          <type name="ConnectionManagerParam" c:type="TpConnectionManagerParam*"/>
        </return-value>
        <parameters>
          <parameter name="param" transfer-ownership="none">
            <doc xml:whitespace="preserve">a parameter name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_param" c:identifier="tp_protocol_has_param" version="0.11.11">
        <doc xml:whitespace="preserve">&lt;!-- no more to say --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @self supports the parameter @param.</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="param" transfer-ownership="none">
            <doc xml:whitespace="preserve">a parameter name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="can_register" c:identifier="tp_protocol_can_register" version="0.11.11">
        <doc xml:whitespace="preserve">Return whether a new account can be registered on this protocol, by setting
the special "register" parameter to %TRUE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @protocol supports the parameter "register"</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="dup_param_names" c:identifier="tp_protocol_dup_param_names" version="0.11.11">
        <doc xml:whitespace="preserve">Returns a list of parameter names supported by this connection manager
for this protocol.
The result is copied and must be freed by the caller with g_strfreev().
#TpProtocol:param-names</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a copy of</doc>
          <array c:type="GStrv">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="get_vcard_field" c:identifier="tp_protocol_get_vcard_field" version="0.11.11">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpProtocol:vcard-field</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_english_name" c:identifier="tp_protocol_get_english_name" version="0.11.11">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the non-%NULL, non-empty value of #TpProtocol:english-name</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_icon_name" c:identifier="tp_protocol_get_icon_name" version="0.11.11">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the non-%NULL, non-empty value of #TpProtocol:icon-name</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_capabilities" c:identifier="tp_protocol_get_capabilities" version="0.11.11">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;
(if non-%NULL) if it will be kept</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">capabilities, which must be referenced</doc>
          <type name="Capabilities" c:type="TpCapabilities*"/>
        </return-value>
      </method>
      <property name="capabilities" version="0.11.11" transfer-ownership="none">
        <doc xml:whitespace="preserve">The classes of channel that can be requested from connections to this
protocol, or %NULL if this is unknown or the %TP_PROTOCOL_FEATURE_CORE
feature has not been prepared.</doc>
        <type name="Capabilities" c:type="TpCapabilities"/>
      </property>
      <property name="english-name" version="0.11.11" transfer-ownership="none">
        <doc xml:whitespace="preserve">The name of the protocol in a form suitable for display to users,
such as "AIM" or "Yahoo!", or a string based on #TpProtocol:protocol-name
(currently constructed by putting the first character in title case,
but this is not guaranteed) if no better name is available or the
%TP_PROTOCOL_FEATURE_CORE feature has not been prepared.
This is effectively in the C locale (international English); user
interfaces requiring a localized protocol name should look one up in their
own message catalog based on either #TpProtocol:protocol-name or
#TpProtocol:english-name, but should use this English version as a
fallback if no translated version can be found.</doc>
        <type name="utf8" c:type="gchararray"/>
      </property>
      <property name="icon-name" version="0.11.11" transfer-ownership="none">
        <doc xml:whitespace="preserve">The name of an icon in the system's icon theme. If none was supplied
by the Protocol, or the %TP_PROTOCOL_FEATURE_CORE feature has not been
prepared, a default is used; currently, this is "im-" plus
#TpProtocol:name.</doc>
        <type name="utf8" c:type="gchararray"/>
      </property>
      <property name="param-names" version="0.11.11" transfer-ownership="none">
        <doc xml:whitespace="preserve">A list of parameter names supported by this connection manager
for this protocol, or %NULL if %TP_PROTOCOL_FEATURE_PARAMETERS has not
been prepared.</doc>
        <type name="GObject.Strv" c:type="GStrv"/>
      </property>
      <property name="protocol-name" version="0.11.11" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The machine-readable name of the protocol, taken from the Telepathy
D-Bus Interface Specification, such as "jabber" or "local-xmpp".</doc>
        <type name="utf8" c:type="gchararray"/>
      </property>
      <property name="vcard-field" version="0.11.11" transfer-ownership="none">
        <doc xml:whitespace="preserve">The most common vCard field used for this protocol's contact
identifiers, normalized to lower case, or %NULL if there is no such field
or the %TP_PROTOCOL_FEATURE_CORE feature has not been prepared.</doc>
        <type name="utf8" c:type="gchararray"/>
      </property>
      <field name="parent">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="priv">
        <type name="ProtocolPrivate" c:type="TpProtocolPrivate*"/>
      </field>
    </class>
    <record name="ProtocolClass" c:type="TpProtocolClass" glib:is-gtype-struct-for="Protocol" version="0.11.11">
      <doc xml:whitespace="preserve">The class of a #TpProtocol.</doc>
    </record>
    <record name="ProtocolClassPrivate" c:type="TpProtocolClassPrivate">
    </record>
    <record name="ProtocolPrivate" c:type="TpProtocolPrivate">
    </record>
    <class name="Proxy" c:type="TpProxy" version="0.7.1" parent="GObject.Object" glib:type-name="TpProxy" glib:get-type="tp_proxy_get_type" glib:type-struct="ProxyClass">
      <doc xml:whitespace="preserve">Structure representing a Telepathy client-side proxy.</doc>
      <method name="has_interface_by_id" c:identifier="tp_proxy_has_interface_by_id" version="0.7.1">
        <doc xml:whitespace="preserve">Return whether this proxy is known to have a particular interface, by its
quark ID. This is equivalent to using g_quark_to_string() followed by
tp_proxy_has_interface(), but more efficient.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if this proxy implements the given interface.</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="iface" transfer-ownership="none">
            <doc xml:whitespace="preserve">quark representing the D-Bus interface required</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_interface" c:identifier="tp_proxy_has_interface" version="0.7.1">
        <doc xml:whitespace="preserve">Return whether this proxy is known to have a particular interface. In
versions older than 0.11.11, this was a macro wrapper around
tp_proxy_has_interface_by_id().
For objects that discover their interfaces at runtime, this method will
indicate that interfaces are missing until they are known to be present.
In subclasses that define features for use with tp_proxy_prepare_async(),
successfully preparing the "core" feature for that subclass (such as
%TP_CHANNEL_FEATURE_CORE or %TP_CONNECTION_FEATURE_CORE) implies that the
interfaces are known.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if this proxy implements the given interface.</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="iface" transfer-ownership="none">
            <doc xml:whitespace="preserve">the D-Bus interface required, as a string</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_dbus_daemon" c:identifier="tp_proxy_get_dbus_daemon" version="0.7.17">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;
this object, if any; always %NULL if this object is itself a
#TpDBusDaemon. The caller must reference the returned object with
g_object_ref() if it will be kept.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a borrowed reference to the #TpDBusDaemon for</doc>
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </return-value>
      </method>
      <method name="get_dbus_connection" c:identifier="tp_proxy_get_dbus_connection" version="0.7.17" introspectable="0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;
The caller must reference the returned pointer with
dbus_g_connection_ref() if it will be kept.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a borrowed reference to the D-Bus connection used by this object.</doc>
          <type name="DBusGConnection" c:type="DBusGConnection*"/>
        </return-value>
      </method>
      <method name="get_bus_name" c:identifier="tp_proxy_get_bus_name" version="0.7.17">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;
must copy the string with g_strdup() if it will be kept.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the bus name of the application exporting the object. The caller</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_object_path" c:identifier="tp_proxy_get_object_path" version="0.7.17">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;
string with g_strdup() if it will be kept.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the object path of the remote object. The caller must copy the</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_invalidated" c:identifier="tp_proxy_get_invalidated" version="0.7.17">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;
invalidated. The caller must copy the error, for instance with
g_error_copy(), if it will be kept.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the reason this proxy was invalidated, or %NULL if has not been</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </return-value>
      </method>
      <method name="dbus_error_to_gerror" c:identifier="tp_proxy_dbus_error_to_gerror" version="0.7.24" throws="1">
        <doc xml:whitespace="preserve">Convert a D-Bus error name into a GError as if it was returned by a method
on this proxy. This method is useful when D-Bus error names are emitted in
signals, such as Connection.ConnectionError and
Group.MembersChangedDetailed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="dbus_error" transfer-ownership="none">
            <doc xml:whitespace="preserve">a D-Bus error name, for instance from the callback for tp_cli_connection_connect_to_connection_error()</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="debug_message" transfer-ownership="none">
            <doc xml:whitespace="preserve">a debug message that accompanied the error name, or %NULL</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_prepared" c:identifier="tp_proxy_is_prepared" version="0.11.3">
        <doc xml:whitespace="preserve">Return %TRUE if @feature has been prepared successfully, or %FALSE if
available on this object at all.
(For instance, if @feature is %TP_CHANNEL_FEATURE_CHAT_STATES and @self
is a #TpChannel in a protocol that doesn't actually implement chat states,
or is not a #TpChannel at all, then this method will return %FALSE.)
To prepare features, call tp_proxy_prepare_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @feature has been prepared successfully</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:whitespace="preserve">a feature that is supported by @self's class</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepare_async" c:identifier="tp_proxy_prepare_async" version="0.11.3">
        <doc xml:whitespace="preserve">#TpProxy itself does not support any features, but subclasses like
#TpChannel can support features, which can either be core functionality like
%TP_CHANNEL_FEATURE_CORE, or extended functionality like
%TP_CHANNEL_FEATURE_CHAT_STATES.
Proxy instances start with no features prepared. When features are
requested via tp_proxy_prepare_async(), the proxy starts to do the
necessary setup to use those features.
tp_proxy_prepare_async() always waits for core functionality of the proxy's
instance, because %TP_CHANNEL_FEATURE_CORE is core functionality of a
#TpChannel,
|[
TpChannel *channel = ...;
tp_proxy_prepare_async (channel, NULL, NULL, callback, user_data);
]|
is equivalent to
|[
TpChannel *channel = ...;
GQuark features[] = { TP_CHANNEL_FEATURE_CORE, 0 };
tp_proxy_prepare_async (channel, features, callback, user_data);
]|
If a feature represents core functionality (like %TP_CHANNEL_FEATURE_CORE),
failure to prepare it will result in tp_proxy_prepare_async() finishing
is no longer useful, it will also emit #TpProxy::invalidated.
If a feature represents non-essential functionality
(like %TP_CHANNEL_FEATURE_CHAT_STATES), or is not supported by the object
at all, then failure to prepare it is not fatal:
tp_proxy_prepare_async() will complete successfully, but
tp_proxy_is_prepared() will still return %FALSE for the feature, and
accessor methods for the feature will typically return a dummy value.
Some #TpProxy subclasses automatically start to prepare their core
features when instantiated, and features will sometimes become prepared as
a side-effect of other actions, but to ensure that a feature is present you
must generally call tp_proxy_prepare_async() and wait for the result.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="features" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">an array of desired features, ending with 0; %NULL is equivalent to an array containing only 0</doc>
            <array c:type="GQuark*">
              <type name="GLib.Quark"/>
            </array>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="async" closure="3">
            <doc xml:whitespace="preserve">if not %NULL, called exactly once, when the features have all been prepared or failed to prepare, or after the proxy is invalidated</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data for @callback</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepare_finish" c:identifier="tp_proxy_prepare_finish" version="0.11.3" throws="1">
        <doc xml:whitespace="preserve">Check for error in a call to tp_proxy_prepare_async(). An error here
generally indicates that either the asynchronous call was cancelled,
or @self has emitted #TpProxy::invalidated.
or was cancelled</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%FALSE (setting @error) if tp_proxy_prepare_async() failed</doc>
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">the result passed to the callback of tp_proxy_prepare_async()</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="bus-name" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The D-Bus bus name for this object. Read-only except during construction.</doc>
        <type name="utf8" c:type="gchararray"/>
      </property>
      <property name="dbus-daemon" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The D-Bus daemon for this object (this object itself, if it is a
TpDBusDaemon). Read-only except during construction.</doc>
        <type name="DBusDaemon" c:type="TpDBusDaemon"/>
      </property>
      <property name="interfaces" transfer-ownership="none">
        <doc xml:whitespace="preserve">Known D-Bus interface names for this object.</doc>
        <type name="GObject.Strv" c:type="GStrv"/>
      </property>
      <property name="object-path" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The D-Bus object path for this object. Read-only except during
construction.</doc>
        <type name="utf8" c:type="gchararray"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="dbus_daemon">
        <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
      </field>
      
      <field name="bus_name">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="object_path">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="invalidated">
        <type name="GLib.Error" c:type="GError*"/>
      </field>
      <field name="priv">
        <type name="ProxyPrivate" c:type="TpProxyPrivate*"/>
      </field>
      <glib:signal name="interface-added" introspectable="0">
        <doc xml:whitespace="preserve">Emitted when this proxy has gained an interface. It is not guaranteed
to be emitted immediately, but will be emitted before the interface is
tp_proxy_borrow_interface_by_id(), any signal is connected, or any
method is called).
The intended use is to call dbus_g_proxy_add_signals(). This signal
should only be used by TpProy implementations</doc>
        <return-value transfer-ownership="full">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <doc xml:whitespace="preserve">the GQuark representing the interface</doc>
            <type name="uint" c:type="guint"/>
          </parameter>
          <parameter name="proxy" transfer-ownership="none">
            <doc xml:whitespace="preserve">the dbus-glib proxy representing the interface</doc>
            <type name="DBusGProxy" c:type="DBusGProxy"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="invalidated">
        <doc xml:whitespace="preserve">Emitted when this proxy has been become invalid for
whatever reason. Any more specific signal should be emitted first.</doc>
        <return-value transfer-ownership="full">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:whitespace="preserve">domain of a GError indicating why this proxy was invalidated</doc>
            <type name="uint" c:type="guint"/>
          </parameter>
          <parameter name="code" transfer-ownership="none">
            <doc xml:whitespace="preserve">error code of a GError indicating why this proxy was invalidated</doc>
            <type name="int" c:type="gint"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">a message associated with the error</doc>
            <type name="utf8" c:type="gchararray"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ProxyClass" c:type="TpProxyClass" glib:is-gtype-struct-for="Proxy" version="0.7.1">
      <doc xml:whitespace="preserve">The class of a #TpProxy. The struct fields not documented here are reserved.</doc>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="interface">
        <type name="GLib.Quark" c:type="GQuark"/>
      </field>
      <field name="must_have_unique_name" bits="1">
        <type name="uint" c:type="unsigned"/>
      </field>
      <field name="_reserved_flags" bits="31">
        <type name="uint" c:type="guint"/>
      </field>
      <field name="_internal_list_features">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_reserved">
        <array zero-terminated="0" c:type="GCallback" fixed-size="3">
          <type name="GObject.Callback"/>
        </array>
      </field>
      <field name="priv">
        <type name="any" c:type="gpointer"/>
      </field>
    </record>
    <record name="ProxyFeature" c:type="TpProxyFeature" version="0.11.3">
      <doc xml:whitespace="preserve">Structure representing a feature. This is currently opaque to code outside
telepathy-glib itself.</doc>
    </record>
    <record name="ProxyPendingCall" c:type="TpProxyPendingCall">
      <method name="cancel" c:identifier="tp_proxy_pending_call_cancel">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <record name="ProxyPrivate" c:type="TpProxyPrivate">
    </record>
    <record name="ProxySignalConnection" c:type="TpProxySignalConnection">
      <method name="disconnect" c:identifier="tp_proxy_signal_connection_disconnect">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <enumeration name="RichPresenceAccessControlType" c:type="TpRichPresenceAccessControlType">
      <member name="whitelist" value="0" c:identifier="TP_RICH_PRESENCE_ACCESS_CONTROL_TYPE_WHITELIST"/>
      <member name="publish_list" value="1" c:identifier="TP_RICH_PRESENCE_ACCESS_CONTROL_TYPE_PUBLISH_LIST"/>
      <member name="group" value="2" c:identifier="TP_RICH_PRESENCE_ACCESS_CONTROL_TYPE_GROUP"/>
      <member name="open" value="3" c:identifier="TP_RICH_PRESENCE_ACCESS_CONTROL_TYPE_OPEN"/>
    </enumeration>
    <enumeration name="ServicePointType" c:type="TpServicePointType">
      <member name="none" value="0" c:identifier="TP_SERVICE_POINT_TYPE_NONE"/>
      <member name="emergency" value="1" c:identifier="TP_SERVICE_POINT_TYPE_EMERGENCY"/>
      <member name="counseling" value="2" c:identifier="TP_SERVICE_POINT_TYPE_COUNSELING"/>
    </enumeration>
    <class name="SimpleApprover" c:type="TpSimpleApprover" version="0.11.5" parent="BaseClient" glib:type-name="TpSimpleApprover" glib:get-type="tp_simple_approver_get_type" glib:type-struct="SimpleApproverClass">
      <doc xml:whitespace="preserve">Data structure representing a simple Approver implementation.</doc>
      <constructor name="new" c:identifier="tp_simple_approver_new" version="0.11.5">
        <doc xml:whitespace="preserve">Convenient function to create a new #TpSimpleApprover instance.
If @dbus is not the result of tp_dbus_daemon_dup(), you should call
tp_simple_approver_new_with_am() instead, so that #TpAccount,
#TpConnection and #TpContact instances can be shared between modules.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #TpSimpleApprover</doc>
          <type name="TelepathyGLib.SimpleApprover" c:type="TpBaseClient*"/>
        </return-value>
        <parameters>
          <parameter name="dbus" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpDBusDaemon object, may not be %NULL</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the Approver (see #TpBaseClient:name: for details)</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="unique" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the TpBaseClient:uniquify-name: property</doc>
            <type name="boolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="notified" closure="4" destroy="5">
            <doc xml:whitespace="preserve">the function called when ApproverChannels is called</doc>
            <type name="SimpleApproverAddDispatchOperationImpl" c:type="TpSimpleApproverAddDispatchOperationImpl"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data passed to @callback</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="call">
            <doc xml:whitespace="preserve">called with the user_data as argument, when the #TpSimpleApprover is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_am" c:identifier="tp_simple_approver_new_with_am" version="0.11.14">
        <doc xml:whitespace="preserve">Convenient function to create a new #TpSimpleApprover instance with a
specified #TpAccountManager.
It is not necessary to prepare any features on @account_manager before
calling this function.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #TpSimpleApprover</doc>
          <type name="TelepathyGLib.SimpleApprover" c:type="TpBaseClient*"/>
        </return-value>
        <parameters>
          <parameter name="account_manager" transfer-ownership="none">
            <doc xml:whitespace="preserve">an account manager, which may not be %NULL</doc>
            <type name="AccountManager" c:type="TpAccountManager*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the Approver (see #TpBaseClient:name: for details)</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="unique" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the TpBaseClient:uniquify-name: property</doc>
            <type name="boolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="notified" closure="4" destroy="5">
            <doc xml:whitespace="preserve">the function called when ApproverChannels is called</doc>
            <type name="SimpleApproverAddDispatchOperationImpl" c:type="TpSimpleApproverAddDispatchOperationImpl"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data passed to @callback</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="call">
            <doc xml:whitespace="preserve">called with the user_data as argument, when the #TpSimpleApprover is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <property name="callback" version="0.11.5" readable="0" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The TpSimpleApproverAddDispatchOperationImpl callback implementing the
ApproverChannels D-Bus method.
This property can't be %NULL.</doc>
        <type name="any" c:type="gpointer"/>
      </property>
      <property name="destroy" version="0.11.5" readable="0" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The #GDestroyNotify function called to free the user-data pointer when
the #TpSimpleApprover is destroyed.</doc>
        <type name="any" c:type="gpointer"/>
      </property>
      <property name="user-data" version="0.11.5" readable="0" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The user-data pointer passed to the callback implementing the
ApproverChannels D-Bus method.</doc>
        <type name="any" c:type="gpointer"/>
      </property>
      <field name="parent">
        <type name="BaseClient" c:type="TpBaseClient"/>
      </field>
      <field name="priv">
        <type name="SimpleApproverPrivate" c:type="TpSimpleApproverPrivate*"/>
      </field>
    </class>
    <callback name="SimpleApproverAddDispatchOperationImpl" c:type="TpSimpleApproverAddDispatchOperationImpl" version="0.11.5">
      <doc xml:whitespace="preserve">Signature of the implementation of the AddDispatchOperation method.
This function must call either tp_add_dispatch_operation_context_accept(),
tp_add_dispatch_operation_context_delay() or
tp_add_dispatch_operation_context_fail() on @context before it returns.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpSimpleApprover instance</doc>
          <type name="SimpleApprover" c:type="TpSimpleApprover*"/>
        </parameter>
        <parameter name="account" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpAccount having %TP_ACCOUNT_FEATURE_CORE prepared if possible</doc>
          <type name="Account" c:type="TpAccount*"/>
        </parameter>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpConnection having %TP_CONNECTION_FEATURE_CORE prepared if possible</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GList of #TpChannel, all having %TP_CHANNEL_FEATURE_CORE prepared</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="TelepathyGLib.Channel"/>
          </type>
        </parameter>
        <parameter name="dispatch_operation" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">a #TpChannelDispatchOperation or %NULL; the dispatch_operation is not guaranteed to be prepared</doc>
          <type name="ChannelDispatchOperation" c:type="TpChannelDispatchOperation*"/>
        </parameter>
        <parameter name="context" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpAddDispatchOperationContext representing the context of this D-Bus call</doc>
          <type name="AddDispatchOperationContext" c:type="TpAddDispatchOperationContext*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="6">
          <doc xml:whitespace="preserve">arbitrary user-supplied data passed to tp_simple_approver_new()</doc>
          <type name="any" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="SimpleApproverClass" c:type="TpSimpleApproverClass" glib:is-gtype-struct-for="SimpleApprover" version="0.11.5">
      <doc xml:whitespace="preserve">The class of a #TpSimpleApprover.</doc>
      <field name="parent_class">
        <type name="BaseClientClass" c:type="TpBaseClientClass"/>
      </field>
      <field name="_padding">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback"/>
        </array>
      </field>
    </record>
    <record name="SimpleApproverPrivate" c:type="TpSimpleApproverPrivate">
    </record>
    <class name="SimpleHandler" c:type="TpSimpleHandler" version="0.11.6" parent="BaseClient" glib:type-name="TpSimpleHandler" glib:get-type="tp_simple_handler_get_type" glib:type-struct="SimpleHandlerClass">
      <doc xml:whitespace="preserve">Data structure representing a simple Handler implementation.</doc>
      <constructor name="new" c:identifier="tp_simple_handler_new" version="0.11.6">
        <doc xml:whitespace="preserve">Convenient function to create a new #TpSimpleHandler instance.
If @dbus is not the result of tp_dbus_daemon_dup(), you should call
tp_simple_handler_new_with_am() instead, so that #TpAccount,
#TpConnection and #TpContact instances can be shared between modules.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #TpSimpleHandler</doc>
          <type name="TelepathyGLib.SimpleHandler" c:type="TpBaseClient*"/>
        </return-value>
        <parameters>
          <parameter name="dbus" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpDBusDaemon object, may not be %NULL</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
          <parameter name="bypass_approval" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the Handler.BypassApproval D-Bus property (see tp_base_client_set_handler_bypass_approval() for details)</doc>
            <type name="boolean" c:type="gboolean"/>
          </parameter>
          <parameter name="requests" transfer-ownership="none">
            <doc xml:whitespace="preserve">if this handler implement Requests (see tp_base_client_set_handler_request_notification() for details)</doc>
            <type name="boolean" c:type="gboolean"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the Handler (see #TpBaseClient:name: for details)</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="unique" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the TpBaseClient:uniquify-name: property</doc>
            <type name="boolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="notified" closure="6" destroy="7">
            <doc xml:whitespace="preserve">the function called when HandleChannels is called</doc>
            <type name="SimpleHandlerHandleChannelsImpl" c:type="TpSimpleHandlerHandleChannelsImpl"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data passed to @callback</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="call">
            <doc xml:whitespace="preserve">called with the user_data as argument, when the #TpSimpleHandler is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_am" c:identifier="tp_simple_handler_new_with_am" version="0.11.14">
        <doc xml:whitespace="preserve">Convenient function to create a new #TpSimpleHandler instance with a
specified #TpAccountManager.
It is not necessary to prepare any features on @account_manager before
calling this function.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #TpSimpleHandler</doc>
          <type name="TelepathyGLib.SimpleHandler" c:type="TpBaseClient*"/>
        </return-value>
        <parameters>
          <parameter name="account_manager" transfer-ownership="none">
            <doc xml:whitespace="preserve">an account manager, which may not be %NULL</doc>
            <type name="AccountManager" c:type="TpAccountManager*"/>
          </parameter>
          <parameter name="bypass_approval" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the Handler.BypassApproval D-Bus property (see tp_base_client_set_handler_bypass_approval() for details)</doc>
            <type name="boolean" c:type="gboolean"/>
          </parameter>
          <parameter name="requests" transfer-ownership="none">
            <doc xml:whitespace="preserve">if this handler implement Requests (see tp_base_client_set_handler_request_notification() for details)</doc>
            <type name="boolean" c:type="gboolean"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the Handler (see #TpBaseClient:name: for details)</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="unique" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the TpBaseClient:uniquify-name: property</doc>
            <type name="boolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="notified" closure="6" destroy="7">
            <doc xml:whitespace="preserve">the function called when HandleChannels is called</doc>
            <type name="SimpleHandlerHandleChannelsImpl" c:type="TpSimpleHandlerHandleChannelsImpl"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data passed to @callback</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="call">
            <doc xml:whitespace="preserve">called with the user_data as argument, when the #TpSimpleHandler is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <property name="bypass-approval" version="0.11.6" readable="0" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The value of the Handler.BypassApproval D-Bus property.</doc>
        <type name="boolean" c:type="gboolean"/>
      </property>
      <property name="callback" version="0.11.6" readable="0" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The TpSimpleHandlerHandleChannelsImpl callback implementing the
HandleChannels D-Bus method.
This property can't be %NULL.</doc>
        <type name="any" c:type="gpointer"/>
      </property>
      <property name="destroy" version="0.11.6" readable="0" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The #GDestroyNotify function called to free the user-data pointer when
the #TpSimpleHandler is destroyed.</doc>
        <type name="any" c:type="gpointer"/>
      </property>
      <property name="requests" version="0.11.6" readable="0" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">If %TRUE, the Handler will implement the Requests interface</doc>
        <type name="boolean" c:type="gboolean"/>
      </property>
      <property name="user-data" version="0.11.6" readable="0" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The user-data pointer passed to the callback implementing the
HandleChannels D-Bus method.</doc>
        <type name="any" c:type="gpointer"/>
      </property>
      <field name="parent">
        <type name="BaseClient" c:type="TpBaseClient"/>
      </field>
      <field name="priv">
        <type name="SimpleHandlerPrivate" c:type="TpSimpleHandlerPrivate*"/>
      </field>
    </class>
    <record name="SimpleHandlerClass" c:type="TpSimpleHandlerClass" glib:is-gtype-struct-for="SimpleHandler" version="0.11.6">
      <doc xml:whitespace="preserve">The class of a #TpSimpleHandler.</doc>
      <field name="parent_class">
        <type name="BaseClientClass" c:type="TpBaseClientClass"/>
      </field>
      <field name="_padding">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback"/>
        </array>
      </field>
    </record>
    <callback name="SimpleHandlerHandleChannelsImpl" c:type="TpSimpleHandlerHandleChannelsImpl" version="0.11.6">
      <doc xml:whitespace="preserve">Signature of the implementation of the HandleChannels method.
This function must call either tp_handle_channels_context_accept(),
tp_handle_channels_context_delay() or tp_handle_channels_context_fail()
on @context before it returns.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpSimpleHandler instance</doc>
          <type name="SimpleHandler" c:type="TpSimpleHandler*"/>
        </parameter>
        <parameter name="account" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpAccount having %TP_ACCOUNT_FEATURE_CORE prepared if possible</doc>
          <type name="Account" c:type="TpAccount*"/>
        </parameter>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpConnection having %TP_CONNECTION_FEATURE_CORE prepared if possible</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GList of #TpChannel, all having %TP_CHANNEL_FEATURE_CORE prepared if possible</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="TelepathyGLib.Channel"/>
          </type>
        </parameter>
        <parameter name="requests_satisfied" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GList of #TpChannelRequest having their object-path defined but are not guaranteed to be prepared.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="TelepathyGLib.ChannelRequest"/>
          </type>
        </parameter>
        <parameter name="user_action_time" transfer-ownership="none">
          <doc xml:whitespace="preserve">the time at which user action occurred, or one of the special values %TP_USER_ACTION_TIME_NOT_USER_ACTION or %TP_USER_ACTION_TIME_CURRENT_TIME (see #TpAccountChannelRequest:user-action-time for details)</doc>
          <type name="int64" c:type="gint64"/>
        </parameter>
        <parameter name="context" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpHandleChannelsContext representing the context of this D-Bus call</doc>
          <type name="HandleChannelsContext" c:type="TpHandleChannelsContext*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="7">
          <doc xml:whitespace="preserve">arbitrary user-supplied data passed to tp_simple_handler_new()</doc>
          <type name="any" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="SimpleHandlerPrivate" c:type="TpSimpleHandlerPrivate">
    </record>
    <class name="SimpleObserver" c:type="TpSimpleObserver" version="0.11.5" parent="BaseClient" glib:type-name="TpSimpleObserver" glib:get-type="tp_simple_observer_get_type" glib:type-struct="SimpleObserverClass">
      <doc xml:whitespace="preserve">Data structure representing a simple Observer implementation.</doc>
      <constructor name="new" c:identifier="tp_simple_observer_new" version="0.11.5">
        <doc xml:whitespace="preserve">Convenient function to create a new #TpSimpleObserver instance.
If @dbus is not the result of tp_dbus_daemon_dup(), you should call
tp_simple_observer_new_with_am() instead, so that #TpAccount,
#TpConnection and #TpContact instances can be shared between modules.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #TpSimpleObserver</doc>
          <type name="TelepathyGLib.SimpleObserver" c:type="TpBaseClient*"/>
        </return-value>
        <parameters>
          <parameter name="dbus" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpDBusDaemon object, may not be %NULL</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
          <parameter name="recover" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the Observer.Recover D-Bus property</doc>
            <type name="boolean" c:type="gboolean"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the Observer (see #TpBaseClient:name: for details)</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="unique" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the TpBaseClient:uniquify-name: property</doc>
            <type name="boolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="notified" closure="5" destroy="6">
            <doc xml:whitespace="preserve">the function called when ObserverChannels is called</doc>
            <type name="SimpleObserverObserveChannelsImpl" c:type="TpSimpleObserverObserveChannelsImpl"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data passed to @callback</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="call">
            <doc xml:whitespace="preserve">called with the user_data as argument, when the #TpSimpleObserver is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_am" c:identifier="tp_simple_observer_new_with_am" version="0.11.14">
        <doc xml:whitespace="preserve">Convenient function to create a new #TpSimpleObserver instance with a
specified #TpAccountManager.
It is not necessary to prepare any features on @account_manager before
calling this function.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #TpSimpleObserver</doc>
          <type name="TelepathyGLib.SimpleObserver" c:type="TpBaseClient*"/>
        </return-value>
        <parameters>
          <parameter name="account_manager" transfer-ownership="none">
            <doc xml:whitespace="preserve">an account manager, which may not be %NULL</doc>
            <type name="AccountManager" c:type="TpAccountManager*"/>
          </parameter>
          <parameter name="recover" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the Observer.Recover D-Bus property</doc>
            <type name="boolean" c:type="gboolean"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the Observer (see #TpBaseClient:name: for details)</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="unique" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the TpBaseClient:uniquify-name: property</doc>
            <type name="boolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="notified" closure="5" destroy="6">
            <doc xml:whitespace="preserve">the function called when ObserverChannels is called</doc>
            <type name="SimpleObserverObserveChannelsImpl" c:type="TpSimpleObserverObserveChannelsImpl"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data passed to @callback</doc>
            <type name="any" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="call">
            <doc xml:whitespace="preserve">called with the user_data as argument, when the #TpSimpleObserver is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <property name="callback" version="0.11.5" readable="0" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The TpSimpleObserverObserveChannelsImpl callback implementing the
ObserverChannels D-Bus method.
This property can't be %NULL.</doc>
        <type name="any" c:type="gpointer"/>
      </property>
      <property name="destroy" version="0.11.5" readable="0" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The #GDestroyNotify function called to free the user-data pointer when
the #TpSimpleObserver is destroyed.</doc>
        <type name="any" c:type="gpointer"/>
      </property>
      <property name="recover" version="0.11.5" readable="0" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The value of the Observer.Recover D-Bus property.</doc>
        <type name="boolean" c:type="gboolean"/>
      </property>
      <property name="user-data" version="0.11.5" readable="0" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The user-data pointer passed to the callback implementing the
ObserverChannels D-Bus method.</doc>
        <type name="any" c:type="gpointer"/>
      </property>
      <field name="parent">
        <type name="BaseClient" c:type="TpBaseClient"/>
      </field>
      <field name="priv">
        <type name="SimpleObserverPrivate" c:type="TpSimpleObserverPrivate*"/>
      </field>
    </class>
    <record name="SimpleObserverClass" c:type="TpSimpleObserverClass" glib:is-gtype-struct-for="SimpleObserver" version="0.11.5">
      <doc xml:whitespace="preserve">The class of a #TpSimpleObserver.</doc>
      <field name="parent_class">
        <type name="BaseClientClass" c:type="TpBaseClientClass"/>
      </field>
      <field name="_padding">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback"/>
        </array>
      </field>
    </record>
    <callback name="SimpleObserverObserveChannelsImpl" c:type="TpSimpleObserverObserveChannelsImpl" version="0.11.5">
      <doc xml:whitespace="preserve">Signature of the implementation of the ObserveChannels method.
This function must call either tp_observe_channels_context_accept(),
tp_observe_channels_context_delay() or tp_observe_channels_context_fail()
on @context before it returns.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpSimpleObserver instance</doc>
          <type name="SimpleObserver" c:type="TpSimpleObserver*"/>
        </parameter>
        <parameter name="account" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpAccount having %TP_ACCOUNT_FEATURE_CORE prepared if possible</doc>
          <type name="Account" c:type="TpAccount*"/>
        </parameter>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpConnection having %TP_CONNECTION_FEATURE_CORE prepared if possible</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GList of #TpChannel, all having %TP_CHANNEL_FEATURE_CORE prepared if possible</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="TelepathyGLib.Channel"/>
          </type>
        </parameter>
        <parameter name="dispatch_operation" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">a #TpChannelDispatchOperation or %NULL; the dispatch_operation is not guaranteed to be prepared</doc>
          <type name="ChannelDispatchOperation" c:type="TpChannelDispatchOperation*"/>
        </parameter>
        <parameter name="requests" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GList of #TpChannelRequest, all having their object-path defined but are not guaranteed to be prepared.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="TelepathyGLib.ChannelRequest"/>
          </type>
        </parameter>
        <parameter name="context" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpObserveChannelsContext representing the context of this D-Bus call</doc>
          <type name="ObserveChannelsContext" c:type="TpObserveChannelsContext*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="7">
          <doc xml:whitespace="preserve">arbitrary user-supplied data passed to tp_simple_observer_new()</doc>
          <type name="any" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="SimpleObserverPrivate" c:type="TpSimpleObserverPrivate">
    </record>
    <enumeration name="SocketAccessControl" c:type="TpSocketAccessControl">
      <member name="localhost" value="0" c:identifier="TP_SOCKET_ACCESS_CONTROL_LOCALHOST"/>
      <member name="port" value="1" c:identifier="TP_SOCKET_ACCESS_CONTROL_PORT"/>
      <member name="netmask" value="2" c:identifier="TP_SOCKET_ACCESS_CONTROL_NETMASK"/>
      <member name="credentials" value="3" c:identifier="TP_SOCKET_ACCESS_CONTROL_CREDENTIALS"/>
    </enumeration>
    <enumeration name="SocketAddressType" c:type="TpSocketAddressType">
      <member name="unix" value="0" c:identifier="TP_SOCKET_ADDRESS_TYPE_UNIX"/>
      <member name="abstract_unix" value="1" c:identifier="TP_SOCKET_ADDRESS_TYPE_ABSTRACT_UNIX"/>
      <member name="ipv4" value="2" c:identifier="TP_SOCKET_ADDRESS_TYPE_IPV4"/>
      <member name="ipv6" value="3" c:identifier="TP_SOCKET_ADDRESS_TYPE_IPV6"/>
    </enumeration>
    <enumeration name="StorageRestrictionFlags" c:type="TpStorageRestrictionFlags">
      <member name="parameters" value="1" c:identifier="TP_STORAGE_RESTRICTION_FLAG_CANNOT_SET_PARAMETERS"/>
      <member name="enabled" value="2" c:identifier="TP_STORAGE_RESTRICTION_FLAG_CANNOT_SET_ENABLED"/>
      <member name="presence" value="4" c:identifier="TP_STORAGE_RESTRICTION_FLAG_CANNOT_SET_PRESENCE"/>
      <member name="service" value="8" c:identifier="TP_STORAGE_RESTRICTION_FLAG_CANNOT_SET_SERVICE"/>
    </enumeration>
    <constant name="TOKEN_CHANNEL_INTERFACE_MEDIA_SIGNALLING_GTALK_P2P" value="org.freedesktop.Telepathy.Channel.Interface.MediaSignalling/gtalk-p2p">
      <type name="utf8"/>
    </constant>
    <constant name="TOKEN_CHANNEL_INTERFACE_MEDIA_SIGNALLING_ICE_UDP" value="org.freedesktop.Telepathy.Channel.Interface.MediaSignalling/ice-udp">
      <type name="utf8"/>
    </constant>
    <constant name="TOKEN_CHANNEL_INTERFACE_MEDIA_SIGNALLING_WLM_2009" value="org.freedesktop.Telepathy.Channel.Interface.MediaSignalling/wlm-2009">
      <type name="utf8"/>
    </constant>
    <constant name="TOKEN_CHANNEL_INTERFACE_MEDIA_SIGNALLING_WLM_8_5" value="org.freedesktop.Telepathy.Channel.Interface.MediaSignalling/wlm-8.5">
      <type name="utf8"/>
    </constant>
    <constant name="TOKEN_CONNECTION_CONTACT_ID" value="org.freedesktop.Telepathy.Connection/contact-id">
      <type name="utf8"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_ALIASING_ALIAS" value="org.freedesktop.Telepathy.Connection.Interface.Aliasing/alias">
      <type name="utf8"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_AVATARS_TOKEN" value="org.freedesktop.Telepathy.Connection.Interface.Avatars/token">
      <type name="utf8"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_CAPABILITIES_CAPS" value="org.freedesktop.Telepathy.Connection.Interface.Capabilities/caps">
      <type name="utf8"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_CONTACT_CAPABILITIES_CAPABILITIES" value="org.freedesktop.Telepathy.Connection.Interface.ContactCapabilities/capabilities">
      <type name="utf8"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_CONTACT_INFO_INFO" value="org.freedesktop.Telepathy.Connection.Interface.ContactInfo/info">
      <type name="utf8"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_LOCATION_LOCATION" value="org.freedesktop.Telepathy.Connection.Interface.Location/location">
      <type name="utf8"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_SIMPLE_PRESENCE_PRESENCE" value="org.freedesktop.Telepathy.Connection.Interface.SimplePresence/presence">
      <type name="utf8"/>
    </constant>
    <enumeration name="TubeChannelState" c:type="TpTubeChannelState">
      <member name="local_pending" value="0" c:identifier="TP_TUBE_CHANNEL_STATE_LOCAL_PENDING"/>
      <member name="remote_pending" value="1" c:identifier="TP_TUBE_CHANNEL_STATE_REMOTE_PENDING"/>
      <member name="open" value="2" c:identifier="TP_TUBE_CHANNEL_STATE_OPEN"/>
      <member name="not_offered" value="3" c:identifier="TP_TUBE_CHANNEL_STATE_NOT_OFFERED"/>
    </enumeration>
    <enumeration name="TubeState" c:type="TpTubeState">
      <member name="local_pending" value="0" c:identifier="TP_TUBE_STATE_LOCAL_PENDING"/>
      <member name="remote_pending" value="1" c:identifier="TP_TUBE_STATE_REMOTE_PENDING"/>
      <member name="open" value="2" c:identifier="TP_TUBE_STATE_OPEN"/>
    </enumeration>
    <enumeration name="TubeType" c:type="TpTubeType">
      <member name="dbus" value="0" c:identifier="TP_TUBE_TYPE_DBUS"/>
      <member name="stream" value="1" c:identifier="TP_TUBE_TYPE_STREAM"/>
    </enumeration>
    <constant name="UNKNOWN_CONNECTION_STATUS" value="-1">
      <type name="int"/>
    </constant>
    <function name="asv_dump" c:identifier="tp_asv_dump" introspectable="0">
      <doc xml:whitespace="preserve">Dumps the a{sv} map to the debugging console.
The purpose of this function is give the programmer the ability to easily
inspect the contents of an a{sv} map for debugging purposes.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_boolean" c:identifier="tp_asv_get_boolean" version="0.7.9">
      <doc xml:whitespace="preserve">If a value for @key in @asv is present and boolean, return it,
and set *@valid to %TRUE if @valid is not %NULL.
Otherwise return %FALSE, and set *@valid to %FALSE if @valid is not %NULL.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">a boolean value for @key</doc>
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GHashTable where the keys are strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">The key to look up</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="valid" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:whitespace="preserve">Either %NULL, or a location to store %TRUE if the key actually exists and has a boolean value</doc>
          <type name="boolean" c:type="gboolean*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_boxed" c:identifier="tp_asv_get_boxed" version="0.7.9">
      <doc xml:whitespace="preserve">If a value for @key in @asv is present and is of the desired type,
return it.
Otherwise return %NULL.
The returned value is not copied, and is only valid as long as the value
for @key in @asv is not removed or altered. Copy it, for instance with
g_boxed_copy(), if you need to keep it for longer.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the value of @key, or %NULL</doc>
        <type name="any" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GHashTable where the keys are strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">The key to look up</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">The type that the key's value should have, which must be derived from %G_TYPE_BOXED</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_bytes" c:identifier="tp_asv_get_bytes" version="0.7.9">
      <doc xml:whitespace="preserve">If a value for @key in @asv is present and is an array of bytes
(its GType is %DBUS_TYPE_G_UCHAR_ARRAY), return it.
Otherwise return %NULL.
The returned value is not copied, and is only valid as long as the value
for @key in @asv is not removed or altered. Copy it with
g_boxed_copy (DBUS_TYPE_G_UCHAR_ARRAY, ...) if you need to keep
it for longer.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the string value of @key, or %NULL</doc>
        <array name="GLib.Array" c:type="GArray*">
          <type name="any" c:type="gpointer"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GHashTable where the keys are strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">The key to look up</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_double" c:identifier="tp_asv_get_double" version="0.7.9">
      <doc xml:whitespace="preserve">If a value for @key in @asv is present and has any numeric type used by
dbus-glib (guchar, gint, guint, gint64, guint64 or gdouble),
return it as a double, and if @valid is not %NULL, set *@valid to %TRUE.
Otherwise, return 0.0, and if @valid is not %NULL, set *@valid to %FALSE.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the double precision floating-point value of @key, or 0.0</doc>
        <type name="double" c:type="gdouble"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GHashTable where the keys are strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">The key to look up</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="valid" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:whitespace="preserve">Either %NULL, or a location in which to store %TRUE on success or %FALSE on failure</doc>
          <type name="boolean" c:type="gboolean*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_int32" c:identifier="tp_asv_get_int32" version="0.7.9">
      <doc xml:whitespace="preserve">If a value for @key in @asv is present, has an integer type used by
dbus-glib (guchar, gint, guint, gint64 or guint64) and fits in the
range of a gint32, return it, and if @valid is not %NULL, set *@valid to
%TRUE.
Otherwise, return 0, and if @valid is not %NULL, set *@valid to %FALSE.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the 32-bit signed integer value of @key, or 0</doc>
        <type name="int32" c:type="gint32"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GHashTable where the keys are strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">The key to look up</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="valid" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:whitespace="preserve">Either %NULL, or a location in which to store %TRUE on success or %FALSE on failure</doc>
          <type name="boolean" c:type="gboolean*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_int64" c:identifier="tp_asv_get_int64" version="0.7.9">
      <doc xml:whitespace="preserve">If a value for @key in @asv is present, has an integer type used by
dbus-glib (guchar, gint, guint, gint64 or guint64) and fits in the
range of a gint64, return it, and if @valid is not %NULL, set *@valid to
%TRUE.
Otherwise, return 0, and if @valid is not %NULL, set *@valid to %FALSE.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the 64-bit signed integer value of @key, or 0</doc>
        <type name="int64" c:type="gint64"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GHashTable where the keys are strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">The key to look up</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="valid" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:whitespace="preserve">Either %NULL, or a location in which to store %TRUE on success or %FALSE on failure</doc>
          <type name="boolean" c:type="gboolean*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_object_path" c:identifier="tp_asv_get_object_path" version="0.7.9">
      <doc xml:whitespace="preserve">If a value for @key in @asv is present and is an object path, return it.
Otherwise return %NULL.
The returned value is not copied, and is only valid as long as the value
for @key in @asv is not removed or altered. Copy it with g_strdup() if you
need to keep it for longer.
%NULL</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the object-path value of @key, or</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GHashTable where the keys are strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">The key to look up</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_string" c:identifier="tp_asv_get_string" version="0.7.9">
      <doc xml:whitespace="preserve">If a value for @key in @asv is present and is a string, return it.
Otherwise return %NULL.
The returned value is not copied, and is only valid as long as the value
for @key in @asv is not removed or altered. Copy it with g_strdup() if you
need to keep it for longer.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the string value of @key, or %NULL</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GHashTable where the keys are strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">The key to look up</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_strv" c:identifier="tp_asv_get_strv" version="0.7.9">
      <doc xml:whitespace="preserve">If a value for @key in @asv is present and is an array of strings (strv),
return it.
Otherwise return %NULL.
The returned value is not copied, and is only valid as long as the value
for @key in @asv is not removed or altered. Copy it with g_strdupv() if you
need to keep it for longer.
value of @key, or %NULL</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the %NULL-terminated string-array</doc>
        <array c:type="gchar**">
          <type name="utf8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GHashTable where the keys are strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">The key to look up</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_uint32" c:identifier="tp_asv_get_uint32" version="0.7.9">
      <doc xml:whitespace="preserve">If a value for @key in @asv is present, has an integer type used by
dbus-glib (guchar, gint, guint, gint64 or guint64) and fits in the
range of a guint32, return it, and if @valid is not %NULL, set *@valid to
%TRUE.
Otherwise, return 0, and if @valid is not %NULL, set *@valid to %FALSE.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the 32-bit unsigned integer value of @key, or 0</doc>
        <type name="uint32" c:type="guint32"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GHashTable where the keys are strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">The key to look up</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="valid" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:whitespace="preserve">Either %NULL, or a location in which to store %TRUE on success or %FALSE on failure</doc>
          <type name="boolean" c:type="gboolean*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_uint64" c:identifier="tp_asv_get_uint64" version="0.7.9">
      <doc xml:whitespace="preserve">If a value for @key in @asv is present, has an integer type used by
dbus-glib (guchar, gint, guint, gint64 or guint64) and is non-negative,
return it, and if @valid is not %NULL, set *@valid to %TRUE.
Otherwise, return 0, and if @valid is not %NULL, set *@valid to %FALSE.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the 64-bit unsigned integer value of @key, or 0</doc>
        <type name="uint64" c:type="guint64"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GHashTable where the keys are strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">The key to look up</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="valid" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:whitespace="preserve">Either %NULL, or a location in which to store %TRUE on success or %FALSE on failure</doc>
          <type name="boolean" c:type="gboolean*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_lookup" c:identifier="tp_asv_lookup" version="0.7.9" introspectable="0">
      <doc xml:whitespace="preserve">If a value for @key in @asv is present, return it. Otherwise return %NULL.
The returned value is not copied, and is only valid as long as the value
for @key in @asv is not removed or altered. Copy it with (for instance)
g_value_copy() if you need to keep it for longer.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the value of @key, or %NULL</doc>
        <type name="GObject.Value" c:type="GValue*"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GHashTable where the keys are strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="GHashTable*"/>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">The key to look up</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_new" c:identifier="tp_asv_new" version="0.7.29" introspectable="0">
      <doc xml:whitespace="preserve">Creates a new #GHashTable for use with a{sv} maps, containing the values
passed in as parameters.
The #GHashTable is synonymous with:
&lt;informalexample&gt;&lt;programlisting&gt;
GHashTable *asv = g_hash_table_new_full (g_str_hash, g_str_equal,
NULL, (GDestroyNotify) tp_g_value_slice_free);
&lt;/programlisting&gt;&lt;/informalexample&gt;
Followed by manual insertion of each of the parameters.
Parameters are stored in slice-allocated GValues and should be set using
tp_asv_set_*() and retrieved using tp_asv_get_*().
tp_g_value_slice_new() and tp_g_value_slice_dup() may also be used to insert
into the map if required.
&lt;informalexample&gt;&lt;programlisting&gt;
g_hash_table_insert (parameters, "account",
tp_g_value_slice_new_string ("bob@mcbadgers.com"));
&lt;/programlisting&gt;&lt;/informalexample&gt;
&lt;example&gt;
&lt;title&gt;Using tp_asv_new()&lt;/title&gt;
&lt;programlisting&gt;
GHashTable *parameters = tp_asv_new (
"answer", G_TYPE_INT, 42,
"question", G_TYPE_STRING, "We just don't know",
NULL);&lt;/programlisting&gt;
&lt;/example&gt;
Allocated values will be automatically free'd when overwritten, removed or
the hash table destroyed with g_hash_table_destroy().
g_hash_table_destroy().</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a newly created #GHashTable for storing a{sv} maps, free with</doc>
        <type name="GLib.HashTable" c:type="GHashTable*"/>
      </return-value>
      <parameters>
        <parameter name="first_key" transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the first key (or NULL)</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_boolean" c:identifier="tp_asv_set_boolean" version="0.7.29" introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.
The value is stored as a slice-allocated GValue.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*"/>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value</doc>
          <type name="boolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_boxed" c:identifier="tp_asv_set_boxed" version="0.7.29" introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.
The value is stored as a slice-allocated GValue.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*"/>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the type of the key's value, which must be derived from %G_TYPE_BOXED</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value</doc>
          <type name="any" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_bytes" c:identifier="tp_asv_set_bytes" version="0.7.29" introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.
The value is stored as a slice-allocated GValue.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*"/>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of bytes to copy</doc>
          <type name="uint" c:type="guint"/>
        </parameter>
        <parameter name="bytes" transfer-ownership="none">
          <doc xml:whitespace="preserve">location of an array of bytes to be copied (this may be %NULL if and only if length is 0)</doc>
          <type name="any" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_double" c:identifier="tp_asv_set_double" version="0.7.29" introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.
The value is stored as a slice-allocated GValue.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*"/>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value</doc>
          <type name="double" c:type="gdouble"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_int32" c:identifier="tp_asv_set_int32" version="0.7.29" introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.
The value is stored as a slice-allocated GValue.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*"/>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value</doc>
          <type name="int32" c:type="gint32"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_int64" c:identifier="tp_asv_set_int64" version="0.7.29" introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.
The value is stored as a slice-allocated GValue.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*"/>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value</doc>
          <type name="int64" c:type="gint64"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_object_path" c:identifier="tp_asv_set_object_path" version="0.7.29" introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.
The value is stored as a slice-allocated GValue.
tp_g_value_slice_new_object_path()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*"/>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_static_boxed" c:identifier="tp_asv_set_static_boxed" version="0.7.29" introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.
The value is stored as a slice-allocated GValue.
tp_g_value_slice_new_static_boxed()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*"/>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the type of the key's value, which must be derived from %G_TYPE_BOXED</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value</doc>
          <type name="any" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_static_object_path" c:identifier="tp_asv_set_static_object_path" version="0.7.29" introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.
The value is stored as a slice-allocated GValue.
tp_g_value_slice_new_static_object_path()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*"/>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_static_string" c:identifier="tp_asv_set_static_string" version="0.7.29" introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.
The value is stored as a slice-allocated GValue.
tp_g_value_slice_new_static_string()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*"/>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_string" c:identifier="tp_asv_set_string" version="0.7.29" introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.
The value is stored as a slice-allocated GValue.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*"/>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_strv" c:identifier="tp_asv_set_strv" version="0.7.29" introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.
The value is stored as a slice-allocated GValue.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*"/>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a %NULL-terminated string array</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_uint32" c:identifier="tp_asv_set_uint32" version="0.7.29" introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.
The value is stored as a slice-allocated GValue.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*"/>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value</doc>
          <type name="uint32" c:type="guint32"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_uint64" c:identifier="tp_asv_set_uint64" version="0.7.29" introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.
The value is stored as a slice-allocated GValue.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*"/>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value</doc>
          <type name="uint64" c:type="guint64"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_take_boxed" c:identifier="tp_asv_take_boxed" version="0.7.29" introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.
The value is stored as a slice-allocated GValue.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*"/>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the type of the key's value, which must be derived from %G_TYPE_BOXED</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value</doc>
          <type name="any" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_take_bytes" c:identifier="tp_asv_take_bytes" version="0.7.29" introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.
The value is stored as a slice-allocated GValue.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*"/>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a non-NULL #GArray of %guchar, ownership of which will be taken by the #GValue</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="any" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="asv_take_object_path" c:identifier="tp_asv_take_object_path" version="0.7.29" introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.
The value is stored as a slice-allocated GValue.
tp_g_value_slice_new_take_object_path()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*"/>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="full">
          <doc xml:whitespace="preserve">value</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_take_string" c:identifier="tp_asv_take_string" version="0.7.29" introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.
The value is stored as a slice-allocated GValue.
tp_g_value_slice_new_take_string()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*"/>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="full">
          <doc xml:whitespace="preserve">value</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="contacts_mixin_add_contact_attributes_iface" c:identifier="tp_contacts_mixin_add_contact_attributes_iface" version="0.7.14" introspectable="0">
      <doc xml:whitespace="preserve">Declare that the given interface has contact attributes which can be added
to the attributes hash using the filler function. All the handles in the
handle array passed to the filler function are guaranteed to be valid and
referenced.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An instance of the implementation that uses this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="interface" transfer-ownership="none">
          <doc xml:whitespace="preserve">Name of the interface that has ContactAttributes</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="fill_contact_attributes" transfer-ownership="none" scope="call">
          <doc xml:whitespace="preserve">Contact attribute filler function</doc>
          <type name="ContactsMixinFillContactAttributesFunc" c:type="TpContactsMixinFillContactAttributesFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="contacts_mixin_class_get_offset_quark" c:identifier="tp_contacts_mixin_class_get_offset_quark" version="0.7.14" introspectable="0">
      <doc xml:whitespace="preserve">&lt;!--no documentation beyond Returns: needed--&gt;</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">the quark used for storing mixin offset on a GObjectClass</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="contacts_mixin_class_init" c:identifier="tp_contacts_mixin_class_init" version="0.7.14" introspectable="0">
      <doc xml:whitespace="preserve">Initialize the contacts mixin. Should be called from the implementation's
class_init function like so:
&lt;informalexample&gt;&lt;programlisting&gt;
tp_contacts_mixin_class_init ((GObjectClass *) klass,
G_STRUCT_OFFSET (SomeObjectClass, contacts_mixin));
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj_cls" transfer-ownership="none">
          <doc xml:whitespace="preserve">The class of the implementation that uses this mixin</doc>
          <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:whitespace="preserve">The byte offset of the TpContactsMixinClass within the class structure</doc>
          <type name="long" c:type="glong"/>
        </parameter>
      </parameters>
    </function>
    <function name="contacts_mixin_finalize" c:identifier="tp_contacts_mixin_finalize" version="0.7.14" introspectable="0">
      <doc xml:whitespace="preserve">Free resources held by the contacts mixin.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object with this mixin.</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="contacts_mixin_get_offset_quark" c:identifier="tp_contacts_mixin_get_offset_quark" version="0.7.14" introspectable="0">
      <doc xml:whitespace="preserve">&lt;!--no documentation beyond Returns: needed--&gt;</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">the quark used for storing mixin offset on a GObject</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="contacts_mixin_iface_init" c:identifier="tp_contacts_mixin_iface_init" version="0.7.14" introspectable="0">
      <doc xml:whitespace="preserve">Fill in the vtable entries needed to implement the contacts interface
using this mixin. This function should usually be called via
G_IMPLEMENT_INTERFACE.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_iface" transfer-ownership="none">
          <doc xml:whitespace="preserve">A pointer to the #TpSvcConnectionInterfaceContacts in an object class</doc>
          <type name="any" c:type="gpointer"/>
        </parameter>
        <parameter name="iface_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">Ignored</doc>
          <type name="any" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="contacts_mixin_init" c:identifier="tp_contacts_mixin_init" version="0.7.14" introspectable="0">
      <doc xml:whitespace="preserve">Initialize the contacts mixin. Should be called from the implementation's
instance init function like so:
&lt;informalexample&gt;&lt;programlisting&gt;
tp_contacts_mixin_init ((GObject *) self,
G_STRUCT_OFFSET (SomeObject, contacts_mixin));
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An instance of the implementation that uses this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:whitespace="preserve">The byte offset of the TpContactsMixin within the object structure</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="contacts_mixin_set_contact_attribute" c:identifier="tp_contacts_mixin_set_contact_attribute" version="0.7.14" introspectable="0">
      <doc xml:whitespace="preserve">Utility function to set attribute for handle to value in the attributes hash
as passed to a TpContactsMixinFillContactAttributesFunc.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="contact_attributes" transfer-ownership="none">
          <doc xml:whitespace="preserve">contacts attribute hash as passed to TpContactsMixinFillContactAttributesFunc</doc>
          <type name="GLib.HashTable" c:type="GHashTable*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">Handle to set the attribute on</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
        <parameter name="attribute" transfer-ownership="none">
          <doc xml:whitespace="preserve">attribute name</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">slice allocated GValue containing the value of the attribute, for instance with tp_g_value_slice_new. Ownership of the GValue is taken over by the mixin</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_check_valid_bus_name" c:identifier="tp_dbus_check_valid_bus_name" version="0.7.1" throws="1">
      <doc xml:whitespace="preserve">Check that the given string is a valid D-Bus bus name of an appropriate
type.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if @name is valid</doc>
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">a possible bus name</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="allow_types" transfer-ownership="none">
          <doc xml:whitespace="preserve">some combination of %TP_DBUS_NAME_TYPE_UNIQUE, %TP_DBUS_NAME_TYPE_WELL_KNOWN or %TP_DBUS_NAME_TYPE_BUS_DAEMON (often this will be %TP_DBUS_NAME_TYPE_NOT_BUS_DAEMON or %TP_DBUS_NAME_TYPE_ANY)</doc>
          <type name="DBusNameType" c:type="TpDBusNameType"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_check_valid_interface_name" c:identifier="tp_dbus_check_valid_interface_name" version="0.7.1" throws="1">
      <doc xml:whitespace="preserve">Check that the given string is a valid D-Bus interface name. This is
also appropriate to use to check for valid error names.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if @name is valid</doc>
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">a possible interface name</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_check_valid_member_name" c:identifier="tp_dbus_check_valid_member_name" version="0.7.1" throws="1">
      <doc xml:whitespace="preserve">Check that the given string is a valid D-Bus member (method or signal) name.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if @name is valid</doc>
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">a possible member name</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_check_valid_object_path" c:identifier="tp_dbus_check_valid_object_path" version="0.7.1" throws="1">
      <doc xml:whitespace="preserve">Check that the given string is a valid D-Bus object path.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if @path is valid</doc>
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="path" transfer-ownership="none">
          <doc xml:whitespace="preserve">a possible object path</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_errors_quark" c:identifier="tp_dbus_errors_quark">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="dbus_g_method_return_not_implemented" c:identifier="tp_dbus_g_method_return_not_implemented" introspectable="0">
      <doc xml:whitespace="preserve">Return the Telepathy error NotImplemented from the method invocation
given by @context.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="context" transfer-ownership="none">
          <doc xml:whitespace="preserve">The D-Bus method invocation context</doc>
          <type name="DBusGMethodInvocation" c:type="DBusGMethodInvocation*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_properties_mixin_class_init" c:identifier="tp_dbus_properties_mixin_class_init" version="0.7.3">
      <doc xml:whitespace="preserve">Initialize the class @cls to use the D-Bus Properties mixin.
The given struct member, of size sizeof(TpDBusPropertiesMixinClass),
will be used to store property implementation information.
Each property and each interface must have been declared as a member of
a GInterface implemented by @cls, using
tp_svc_interface_set_dbus_properties_info().
Before calling this function, the array @interfaces must have been
placed in the #TpDBusPropertiesMixinClass structure; if it would be empty,
it may instead be %NULL.
This function should be called from the class_init callback in such a way
that it will only be called once, even if the class is subclassed.
which means that only interfaces whose properties are set up using
tp_dbus_properties_mixin_implement_interface() will be used.
#TpDBusPropertiesMixinClass can be omitted from @cls.  It is treated as if
it were present, but with all fields (including
TpDBusPropertiesMixinClass::interfaces) being %NULL, so only interfaces
whose properties are set using
tp_dbus_properties_mixin_implement_interface() will be used.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cls" transfer-ownership="none">
          <doc xml:whitespace="preserve">a subclass of #GObjectClass</doc>
          <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:whitespace="preserve">the offset within @cls of a TpDBusPropertiesMixinClass structure</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_properties_mixin_fill_properties_hash" c:identifier="tp_dbus_properties_mixin_fill_properties_hash" version="0.11.11" introspectable="0">
      <doc xml:whitespace="preserve">Retrieves the values of several D-Bus properties from an object, and adds
them to a hash mapping the fully-qualified name of the property to its
value. This is equivalent to calling tp_dbus_properties_mixin_get() for
each property and adding it to the table yourself, with the proviso that
this function will g_assert() if retrieving a property fails (for instance,
because it does not exist).
Note that in particular, @table does not have the same memory-allocation
model as the hash tables required by tp_asv_set_string() and similar
functions.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">an object which uses the D-Bus properties mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="table" transfer-ownership="none">
          <doc xml:whitespace="preserve">a hash table where the keys are strings copied with g_strdup() and the values are slice-allocated #GValue&lt;!-- --&gt;s</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="first_interface" transfer-ownership="none">
          <doc xml:whitespace="preserve">the interface of the first property to be retrieved</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="first_property" transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the first property to be retrieved</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_properties_mixin_get" c:identifier="tp_dbus_properties_mixin_get" version="0.7.13" throws="1">
      <doc xml:whitespace="preserve">Initialize @value with the type of the property @property_name on
by calling the D-Bus method org.freedesktop.DBus.Properties.Get.
If Get would return a D-Bus error, @value remains unset and @error
is filled in instead.
on failure</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE (filling @value) on success, %FALSE (setting @error)</doc>
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">an object with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="interface_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">a D-Bus interface name</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="property_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">a D-Bus property name</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">an unset GValue (initialized to all zeroes)</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_properties_mixin_getter_gobject_properties" c:identifier="tp_dbus_properties_mixin_getter_gobject_properties">
      <doc xml:whitespace="preserve">An implementation of #TpDBusPropertiesMixinGetter which assumes that
the @getter_data is the name of a readable #GObject property of an
appropriate type, and uses it for the value of the D-Bus property.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">The exported object with the properties</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="iface" transfer-ownership="none">
          <doc xml:whitespace="preserve">A quark representing the D-Bus interface name</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">A quark representing the D-Bus property name</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GValue pre-initialized to the right type, into which to put the value</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="getter_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">The getter_data from the #TpDBusPropertiesMixinPropImpl, which must be a string containing the GObject property's name</doc>
          <type name="any" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_properties_mixin_iface_init" c:identifier="tp_dbus_properties_mixin_iface_init">
      <doc xml:whitespace="preserve">Declare that the DBus.Properties interface represented by @g_iface
is implemented using this mixin.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_iface" transfer-ownership="none">
          <doc xml:whitespace="preserve">a pointer to a #TpSvcDBusPropertiesClass structure</doc>
          <type name="any" c:type="gpointer"/>
        </parameter>
        <parameter name="iface_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">ignored</doc>
          <type name="any" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_properties_mixin_implement_interface" c:identifier="tp_dbus_properties_mixin_implement_interface">
      <doc xml:whitespace="preserve">Declare that, in addition to any interfaces set in
tp_dbus_properties_mixin_class_init(), the given class (and its subclasses)
will implement the properties of the interface @iface using the callbacks
This function should be called from the class_init callback in such a way
that it will only be called once, even if the class is subclassed.
Typically, the static array @interfaces in the #TpDBusPropertiesMixinClass
should be used for interfaces whose properties are implemented directly by
the class @cls, and this function should be used for interfaces whose
properties are implemented by mixins.
It is an error for the same interface to appear in the array @interfaces
in the #TpDBusPropertiesMixinClass, and also be set up by this function.
If a class C and a subclass S both implement the properties of the same
interface, only the implementations from the subclass S will be used,
regardless of whether the implementations in C and/or S were set up by
this function or via the array @interfaces in the
#TpDBusPropertiesMixinClass.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cls" transfer-ownership="none">
          <doc xml:whitespace="preserve">a subclass of #GObjectClass</doc>
          <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
        </parameter>
        <parameter name="iface" transfer-ownership="none">
          <doc xml:whitespace="preserve">a quark representing the the name of the interface to implement</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="getter" transfer-ownership="none" scope="call">
          <doc xml:whitespace="preserve">a callback to get properties on this interface, or %NULL if they are all write-only</doc>
          <type name="DBusPropertiesMixinGetter" c:type="TpDBusPropertiesMixinGetter"/>
        </parameter>
        <parameter name="setter" transfer-ownership="none" scope="call">
          <doc xml:whitespace="preserve">a callback to set properties on this interface, or %NULL if they are all read-only</doc>
          <type name="DBusPropertiesMixinSetter" c:type="TpDBusPropertiesMixinSetter"/>
        </parameter>
        <parameter name="props" transfer-ownership="none">
          <doc xml:whitespace="preserve">an array of #TpDBusPropertiesMixinPropImpl representing individual properties, terminated by one with @name == %NULL</doc>
          <type name="DBusPropertiesMixinPropImpl" c:type="TpDBusPropertiesMixinPropImpl*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_properties_mixin_make_properties_hash" c:identifier="tp_dbus_properties_mixin_make_properties_hash" introspectable="0">
      <doc xml:whitespace="preserve">Retrieves the values of several D-Bus properties from an object, and builds
a hash mapping the fully-qualified name of the property to its value.  This
is equivalent to calling tp_dbus_properties_mixin_get() for each property
and building the table yourself, with the proviso that this function will
g_assert() if retrieving a property fails (for instance, because it does not
exist).
Additional keys and values can be inserted into the returned hash table;
if this is done, the inserted keys and values will be freed when the
hash table is destroyed. The keys must be allocated with g_strdup() or
equivalent, and the values must be slice-allocated (for instance with
tp_g_value_slice_new_string() or a similar function).
Note that in particular, tp_asv_set_string() and similar functions should
not be used with this hash table.
GValues, which must be freed by the caller (at which point its
contents will also be freed).</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a hash table mapping (gchar *) fully-qualified property names to</doc>
        <type name="GLib.HashTable" c:type="GHashTable*"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">an object which uses the D-Bus properties mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="first_interface" transfer-ownership="none">
          <doc xml:whitespace="preserve">the interface of the first property to be retrieved</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="first_property" transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the first property to be retrieved</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_properties_mixin_setter_gobject_properties" c:identifier="tp_dbus_properties_mixin_setter_gobject_properties" throws="1">
      <doc xml:whitespace="preserve">An implementation of #TpDBusPropertiesMixinSetter which assumes that the
type, and sets that property to the given value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE</doc>
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">The exported object with the properties</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="iface" transfer-ownership="none">
          <doc xml:whitespace="preserve">A quark representing the D-Bus interface name</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">A quark representing the D-Bus property name</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">The new value for the property</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="setter_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">The setter_data from the #TpDBusPropertiesMixinPropImpl, which must be a string containing the GObject property's name</doc>
          <type name="any" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_divert_messages" c:identifier="tp_debug_divert_messages" version="0.7.1">
      <doc xml:whitespace="preserve">Open the given file for writing and duplicate its file descriptor to
be used for stdout and stderr. This has the effect of closing the previous
stdout and stderr, and sending all messages that would have gone there
to the given file instead.
By default the file is truncated and hence overwritten each time the
process is executed.
Since version 0.7.14, if the filename is prefixed with '+' then the
file is not truncated and output is added at the end of the file.
Passing %NULL to this function is guaranteed to have no effect. This is
so you can call it with the recommended usage
&lt;literal&gt;tp_debug_divert_messages (g_getenv ("MYAPP_LOGFILE"))&lt;/literal&gt;
and it won't do anything if the environment variable is not set.
This function still works if telepathy-glib was compiled without debug
support.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:whitespace="preserve">A file to which to divert stdout and stderr, or %NULL to do nothing</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_set_all_flags" c:identifier="tp_debug_set_all_flags" introspectable="0">
      <doc xml:whitespace="preserve">Activate all possible debug modes. This also activates persistent mode,
which should have been orthogonal.
tp_debug_set_persistent() instead.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="debug_set_flags" c:identifier="tp_debug_set_flags">
      <doc xml:whitespace="preserve">Set the debug flags indicated by @flags_string, in addition to any already
set.
The parsing matches that of g_parse_debug_string().
If telepathy-glib was compiled with --disable-debug (not recommended),
this function has no practical effect, since the debug messages it would
enable were removed at compile time.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="flags_string" transfer-ownership="none">
          <doc xml:whitespace="preserve">The flags to set, comma-separated. If %NULL or empty, no additional flags are set.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_set_flags_from_env" c:identifier="tp_debug_set_flags_from_env" introspectable="0">
      <doc xml:whitespace="preserve">Equivalent to
&lt;literal&gt;tp_debug_set_flags_from_string (g_getenv (var))&lt;/literal&gt;,
and has the same problem with persistence being included in "all".
tp_debug_set_persistent() instead</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="var" transfer-ownership="none">
          <doc xml:whitespace="preserve">The name of the environment variable to parse</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_set_flags_from_string" c:identifier="tp_debug_set_flags_from_string" introspectable="0">
      <doc xml:whitespace="preserve">Set the debug flags indicated by @flags_string, in addition to any already
set. Unlike tp_debug_set_flags(), this enables persistence like
tp_debug_set_persistent() if the "persist" flag is present or the string
is "all" - this turns out to be unhelpful, as persistence should be
orthogonal.
The parsing matches that of g_parse_debug_string().
tp_debug_set_persistent() instead</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="flags_string" transfer-ownership="none">
          <doc xml:whitespace="preserve">The flags to set, comma-separated. If %NULL or empty, no additional flags are set.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_set_persistent" c:identifier="tp_debug_set_persistent">
      <doc xml:whitespace="preserve">Used to enable persistent operation of the connection manager process for
debugging purposes.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="persistent" transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE prevents the connection manager mainloop from exiting, FALSE enables exiting if there are no connections (the default behavior).</doc>
          <type name="boolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_timestamped_log_handler" c:identifier="tp_debug_timestamped_log_handler" version="0.7.1">
      <doc xml:whitespace="preserve">A #GLogFunc that prepends the UTC time (currently in ISO 8601 format,
with microsecond resolution) to the message, then calls
g_log_default_handler.
Intended usage is:
&lt;informalexample&gt;&lt;programlisting&gt;if (g_getenv ("MYPROG_TIMING") != NULL)
g_log_set_default_handler (tp_debug_timestamped_log_handler, NULL);
&lt;/programlisting&gt;&lt;/informalexample&gt;
If telepathy-glib was compiled with --disable-debug (not recommended),
this function is equivalent to g_log_default_handler().
RFC-3339 format. Previously, they were printed in local time, in a
format similar to RFC-3339.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="log_domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">the message's log domain</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="log_level" transfer-ownership="none">
          <doc xml:whitespace="preserve">the log level of the message</doc>
          <type name="GLib.LogLevelFlags" c:type="GLogLevelFlags"/>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:whitespace="preserve">the message to process</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="ignored" transfer-ownership="none">
          <doc xml:whitespace="preserve">not used</doc>
          <type name="any" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="error_get_dbus_name" c:identifier="tp_error_get_dbus_name" version="0.7.31">
      <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the D-Bus error name corresponding to @error.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">a member of the #TpError enum.</doc>
          <type name="Error" c:type="TpError"/>
        </parameter>
      </parameters>
    </function>
    <function name="errors_disconnected_quark" c:identifier="tp_errors_disconnected_quark">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="errors_quark" c:identifier="tp_errors_quark" introspectable="0" deprecated="Use tp_error_quark() instead.">
      <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="errors_removed_from_group_quark" c:identifier="tp_errors_removed_from_group_quark">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="external_group_mixin_finalize" c:identifier="tp_external_group_mixin_finalize" version="0.5.13" introspectable="0">
      <doc xml:whitespace="preserve">Remove the external group mixin. This function should usually be called
in the dispose or finalize function.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the groups interface using an external group mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="external_group_mixin_get_dbus_property" c:identifier="tp_external_group_mixin_get_dbus_property" version="0.7.10" introspectable="0">
      <doc xml:whitespace="preserve">An implementation of #TpDBusPropertiesMixinGetter which assumes that the
interface.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="interface" transfer-ownership="none">
          <doc xml:whitespace="preserve">Must be %TP_IFACE_QUARK_CHANNEL_INTERFACE_GROUP</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">A quark representing the D-Bus property name, either "GroupFlags", "HandleOwners", "LocalPendingMembers", "Members", "RemotePendingMembers" or "SelfHandle"</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GValue pre-initialized to the right type, into which to put the value</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="unused" transfer-ownership="none">
          <doc xml:whitespace="preserve">Ignored</doc>
          <type name="any" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="external_group_mixin_iface_init" c:identifier="tp_external_group_mixin_iface_init" version="0.5.13" introspectable="0">
      <doc xml:whitespace="preserve">Fill in the vtable entries needed to implement the group interface using
the group mixin of another object. This function should usually be called
via G_IMPLEMENT_INTERFACE.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_iface" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #TpSvcChannelInterfaceGroupClass</doc>
          <type name="any" c:type="gpointer"/>
        </parameter>
        <parameter name="iface_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">Unused</doc>
          <type name="any" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="external_group_mixin_init" c:identifier="tp_external_group_mixin_init" version="0.5.13" introspectable="0">
      <doc xml:whitespace="preserve">Fill in the qdata needed to implement the group interface using
the group mixin of another object. This function should usually be called
in the instance constructor.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the groups interface using an external group mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="obj_with_mixin" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GObject with the group mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="external_group_mixin_init_dbus_properties" c:identifier="tp_external_group_mixin_init_dbus_properties" version="0.7.10" introspectable="0">
      <doc xml:whitespace="preserve">Set up #TpDBusPropertiesMixinClass to use this mixin's implementation of
the Group interface's properties.
This uses tp_group_mixin_get_dbus_property() as the property getter and
sets up a list of the supported properties for it.  Having called this, you
should add #TP_CHANNEL_GROUP_FLAG_PROPERTIES to channels containing the
mixin used by this class with tp_group_mixin_change_flags() to indicate that
the DBus properties are available.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cls" transfer-ownership="none">
          <doc xml:whitespace="preserve">The class of an object with this mixin</doc>
          <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
        </parameter>
      </parameters>
    </function>
    <function name="g_set_error_invalid_handle_type" c:identifier="tp_g_set_error_invalid_handle_type" introspectable="0" throws="1">
      <doc xml:whitespace="preserve">Set the error NotImplemented for an invalid handle type,
with an appropriate message.
InvalidArgument.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">An invalid handle type</doc>
          <type name="uint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="g_set_error_unsupported_handle_type" c:identifier="tp_g_set_error_unsupported_handle_type" introspectable="0" throws="1">
      <doc xml:whitespace="preserve">Set the error NotImplemented for a handle type which is valid but is not
supported by this connection manager, with an appropriate message.
InvalidArgument.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">An unsupported handle type</doc>
          <type name="uint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="g_value_slice_new_bytes" c:identifier="tp_g_value_slice_new_bytes" version="0.7.27" introspectable="0">
      <doc xml:whitespace="preserve">Slice-allocate a #GValue containing a byte-array, using
tp_g_value_slice_new_boxed(). This function is convenient to use when
constructing hash tables from string to #GValue, for example.
of @length bytes from @bytes, to be freed with tp_g_value_slice_free() or
g_slice_free()</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a #GValue of type %DBUS_TYPE_G_UCHAR_ARRAY whose value is a copy</doc>
        <type name="GObject.Value" c:type="GValue*"/>
      </return-value>
      <parameters>
        <parameter name="length" transfer-ownership="none">
          <doc xml:whitespace="preserve">number of bytes to copy</doc>
          <type name="uint" c:type="guint"/>
        </parameter>
        <parameter name="bytes" transfer-ownership="none">
          <doc xml:whitespace="preserve">location of an array of bytes to be copied (this may be %NULL if and only if length is 0)</doc>
          <type name="any" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="g_value_slice_new_object_path" c:identifier="tp_g_value_slice_new_object_path" version="0.7.27" introspectable="0">
      <doc xml:whitespace="preserve">Slice-allocate a #GValue containing an object path, using
tp_g_value_slice_new_boxed(). This function is convenient to use when
constructing hash tables from string to #GValue, for example.
of @path, to be freed with tp_g_value_slice_free() or g_slice_free()</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a #GValue of type %DBUS_TYPE_G_OBJECT_PATH whose value is a copy</doc>
        <type name="GObject.Value" c:type="GValue*"/>
      </return-value>
      <parameters>
        <parameter name="path" transfer-ownership="none">
          <doc xml:whitespace="preserve">a valid D-Bus object path which will be copied</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="g_value_slice_new_static_object_path" c:identifier="tp_g_value_slice_new_static_object_path" version="0.7.27" introspectable="0">
      <doc xml:whitespace="preserve">Slice-allocate a #GValue containing an object path, using
tp_g_value_slice_new_static_boxed(). This function is convenient to use when
constructing hash tables from string to #GValue, for example.
to be freed with tp_g_value_slice_free() or g_slice_free()</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a #GValue of type %DBUS_TYPE_G_OBJECT_PATH whose value is @path,</doc>
        <type name="GObject.Value" c:type="GValue*"/>
      </return-value>
      <parameters>
        <parameter name="path" transfer-ownership="none">
          <doc xml:whitespace="preserve">a valid D-Bus object path which must remain valid forever</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="g_value_slice_new_take_bytes" c:identifier="tp_g_value_slice_new_take_bytes" version="0.7.27" introspectable="0">
      <doc xml:whitespace="preserve">Slice-allocate a #GValue containing @bytes, using
tp_g_value_slice_new_boxed(). This function is convenient to use when
constructing hash tables from string to #GValue, for example.
g_slice_free()</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a #GValue of type %DBUS_TYPE_G_UCHAR_ARRAY whose value is</doc>
        <type name="GObject.Value" c:type="GValue*"/>
      </return-value>
      <parameters>
        <parameter name="bytes" transfer-ownership="none">
          <doc xml:whitespace="preserve">a non-NULL #GArray of guchar, ownership of which will be taken by the #GValue</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="any" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="g_value_slice_new_take_object_path" c:identifier="tp_g_value_slice_new_take_object_path" version="0.7.27" introspectable="0">
      <doc xml:whitespace="preserve">Slice-allocate a #GValue containing an object path, using
tp_g_value_slice_new_take_boxed(). This function is convenient to use when
constructing hash tables from string to #GValue, for example.
to be freed with tp_g_value_slice_free() or g_slice_free()</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a #GValue of type %DBUS_TYPE_G_OBJECT_PATH whose value is @path,</doc>
        <type name="GObject.Value" c:type="GValue*"/>
      </return-value>
      <parameters>
        <parameter name="path" transfer-ownership="full">
          <doc xml:whitespace="preserve">a valid D-Bus object path which will be freed with g_free() by the returned #GValue (the caller must own it before calling this function, but no longer owns it after this function returns)</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_bus" c:identifier="tp_get_bus" introspectable="0">
      <doc xml:whitespace="preserve">Returns a connection to the D-Bus daemon on which this process was
activated if it was launched by D-Bus service activation, or the session
bus otherwise.
If dbus_g_bus_get() fails, exit with error code 1.
Note that this function is not suitable for use in applications which can
be useful even in the absence of D-Bus - it is designed for use in
connection managers, which are not at all useful without a D-Bus
connection. See &amp;lt;https://bugs.freedesktop.org/show_bug.cgi?id=18832&amp;gt;.
Most processes should use tp_dbus_daemon_dup() instead.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a connection to the starter or session D-Bus daemon.</doc>
        <type name="DBusGConnection" c:type="DBusGConnection*"/>
      </return-value>
    </function>
    <function name="get_bus_proxy" c:identifier="tp_get_bus_proxy" introspectable="0" deprecated="Use tp_dbus_daemon_dup() in new code." deprecated-version="0.7.26">
      <doc xml:whitespace="preserve">Return a #DBusGProxy for the bus daemon object. The same caveats as for
tp_get_bus() apply.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a proxy for the bus daemon object on the starter or session bus.</doc>
        <type name="DBusGProxy" c:type="DBusGProxy*"/>
      </return-value>
    </function>
    <function name="group_mixin_add_handle_owner" c:identifier="tp_group_mixin_add_handle_owner" introspectable="0">
      <doc xml:whitespace="preserve">Note that the given local handle is an alias within this group
for the given globally-valid handle. It will be returned from subsequent
GetHandleOwner queries where appropriate.
0.17.6, before adding any channel-specific handle to the members,
local-pending members or remote-pending members, you must call either
this function or tp_group_mixin_add_handle_owners().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GObject implementing the group interface with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="local_handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A contact handle valid within this group (may not be 0)</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
        <parameter name="owner_handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A contact handle valid globally, or 0 if the owner of the</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_add_handle_owners" c:identifier="tp_group_mixin_add_handle_owners" introspectable="0">
      <doc xml:whitespace="preserve">Note that the given local handles are aliases within this group
for the given globally-valid handles.
To comply with telepathy-spec 0.17.6, before adding any channel-specific
handle to the members, local-pending members or remote-pending members, you
must call either this function or tp_group_mixin_add_handle_owner().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GObject implementing the group interface with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="local_to_owner_handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A map from contact handles valid within this group (which may not be 0) to either contact handles valid globally, or 0 if the owner of the corresponding key is unknown; all handles are stored using GUINT_TO_POINTER</doc>
          <type name="GLib.HashTable" c:type="GHashTable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_add_members" c:identifier="tp_group_mixin_add_members" introspectable="0" throws="1">
      <doc xml:whitespace="preserve">Request that the given contacts be added to the group as if in response
to user action. If the group's flags prohibit this, raise
PermissionDenied. If any of the handles is invalid, raise InvalidHandle.
Otherwise attempt to add the contacts by calling the callbacks provided
by the channel implementation.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE on success</doc>
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="contacts" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GArray of guint representing contacts</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="any" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:whitespace="preserve">A message associated with the addition request, if supported</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_change_flags" c:identifier="tp_group_mixin_change_flags" introspectable="0">
      <doc xml:whitespace="preserve">Request a change to be made to the flags. If any flags were actually
set or cleared, emits the GroupFlagsChanged signal with the changes.
It is an error to set any of the same bits in both @add and @del.
removing @del had no effect on the existing group flags.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the groups interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="add" transfer-ownership="none">
          <doc xml:whitespace="preserve">Flags to be added</doc>
          <type name="ChannelGroupFlags" c:type="TpChannelGroupFlags"/>
        </parameter>
        <parameter name="del" transfer-ownership="none">
          <doc xml:whitespace="preserve">Flags to be removed</doc>
          <type name="ChannelGroupFlags" c:type="TpChannelGroupFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_change_members" c:identifier="tp_group_mixin_change_members" introspectable="0">
      <doc xml:whitespace="preserve">Change the sets of members as given by the arguments, and emit the
MembersChanged and MembersChangedDetailed signals if the changes were not a
no-op.
This function must be called in response to events on the underlying
IM protocol, and must not be called in direct response to user input;
it does not respect the permissions flags, but changes the group directly.
If any two of add, del, add_local_pending and add_remote_pending have
a non-empty intersection, the result is undefined. Don't do that.
Each of the TpIntSet arguments may be %NULL, which is treated as
equivalent to an empty set.
signals were emitted; %FALSE if nothing actually changed and the signals
were suppressed.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the group was changed and the MembersChanged(Detailed)</doc>
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:whitespace="preserve">A message to be sent to the affected contacts if possible; %NULL is allowed, and is mapped to an empty string</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="add" transfer-ownership="none">
          <doc xml:whitespace="preserve">A set of contact handles to be added to the members (if not already present) and removed from local pending and remote pending (if present)</doc>
          <type name="IntSet" c:type="TpIntSet*"/>
        </parameter>
        <parameter name="del" transfer-ownership="none">
          <doc xml:whitespace="preserve">A set of contact handles to be removed from members, local pending or remote pending, wherever they are present</doc>
          <type name="IntSet" c:type="TpIntSet*"/>
        </parameter>
        <parameter name="add_local_pending" transfer-ownership="none">
          <doc xml:whitespace="preserve">A set of contact handles to be added to local pending, and removed from members and remote pending</doc>
          <type name="IntSet" c:type="TpIntSet*"/>
        </parameter>
        <parameter name="add_remote_pending" transfer-ownership="none">
          <doc xml:whitespace="preserve">A set of contact handles to be added to remote pending, and removed from members and local pending</doc>
          <type name="IntSet" c:type="TpIntSet*"/>
        </parameter>
        <parameter name="actor" transfer-ownership="none">
          <doc xml:whitespace="preserve">The handle of the contact responsible for this change</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
        <parameter name="reason" transfer-ownership="none">
          <doc xml:whitespace="preserve">The reason for this change</doc>
          <type name="ChannelGroupChangeReason" c:type="TpChannelGroupChangeReason"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_change_members_detailed" c:identifier="tp_group_mixin_change_members_detailed" introspectable="0">
      <doc xml:whitespace="preserve">Change the sets of members as given by the arguments, and emit the
MembersChanged and MembersChangedDetailed signals if the changes were not a
no-op.
This function must be called in response to events on the underlying
IM protocol, and must not be called in direct response to user input;
it does not respect the permissions flags, but changes the group directly.
If any two of add, del, add_local_pending and add_remote_pending have
a non-empty intersection, the result is undefined. Don't do that.
Each of the TpIntSet arguments may be %NULL, which is treated as
equivalent to an empty set.
details may contain, among other entries, the well-known
keys (and corresponding type, wrapped in a GValue) defined by the
Group.MembersChangedDetailed signal's specification; these include "actor"
(a handle as G_TYPE_UINT), "change-reason" (an element of
#TpChannelGroupChangeReason as G_TYPE_UINT), "message" (G_TYPE_STRING),
"error" (G_TYPE_STRING), "debug-message" (G_TYPE_STRING).
If all of the information in details could be passed to
tp_group_mixin_change_members() then calling this function instead provides
no benefit. Calling this function without setting
#TP_CHANNEL_GROUP_FLAG_MEMBERS_CHANGED_DETAILED with
tp_group_mixin_change_members() first is not very useful, as clients will
not know to listen for MembersChangedDetailed and thus will miss the
details.
signals were emitted; %FALSE if nothing actually changed and the signals
were suppressed.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the group was changed and the MembersChanged(Detailed)</doc>
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="add" transfer-ownership="none">
          <doc xml:whitespace="preserve">A set of contact handles to be added to the members (if not already present) and removed from local pending and remote pending (if present)</doc>
          <type name="IntSet" c:type="TpIntSet*"/>
        </parameter>
        <parameter name="del" transfer-ownership="none">
          <doc xml:whitespace="preserve">A set of contact handles to be removed from members, local pending or remote pending, wherever they are present</doc>
          <type name="IntSet" c:type="TpIntSet*"/>
        </parameter>
        <parameter name="add_local_pending" transfer-ownership="none">
          <doc xml:whitespace="preserve">A set of contact handles to be added to local pending, and removed from members and remote pending</doc>
          <type name="IntSet" c:type="TpIntSet*"/>
        </parameter>
        <parameter name="add_remote_pending" transfer-ownership="none">
          <doc xml:whitespace="preserve">A set of contact handles to be added to remote pending, and removed from members and local pending</doc>
          <type name="IntSet" c:type="TpIntSet*"/>
        </parameter>
        <parameter name="details" transfer-ownership="none">
          <doc xml:whitespace="preserve">a map from strings to GValues detailing the change</doc>
          <type name="GLib.HashTable" c:type="GHashTable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_change_self_handle" c:identifier="tp_group_mixin_change_self_handle" introspectable="0">
      <doc xml:whitespace="preserve">Change the self-handle for this group to the given value.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="new_self_handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">The new self-handle for this group</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_class_allow_self_removal" c:identifier="tp_group_mixin_class_allow_self_removal" version="0.7.27" introspectable="0">
      <doc xml:whitespace="preserve">Configure the mixin to allow attempts to remove the SelfHandle from this
Group, even if the group flags would otherwise disallow this. The
channel's #TpGroupMixinRemMemberFunc or
#TpGroupMixinRemMemberWithReasonFunc will be called as usual for such
attempts, and may make them fail with %TP_ERROR_PERMISSION_DENIED if
required.
This function should be called from the GObject @class_init callback,
after calling tp_group_mixin_class_init().
(Recent telepathy-spec changes make it valid to try to remove the
self-handle at all times, regardless of group flags. However, if this was
implemented automatically in TpGroupMixin, this would risk crashing
connection manager implementations that assume that TpGroupMixin will
enforce the group flags strictly. As a result, connection managers should
call this function to indicate to the TpGroupMixin that it may call their
removal callback with the self-handle regardless of flag settings.)</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj_cls" transfer-ownership="none">
          <doc xml:whitespace="preserve">The class of an object implementing the group interface using this mixin</doc>
          <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_class_get_offset_quark" c:identifier="tp_group_mixin_class_get_offset_quark" introspectable="0">
      <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">the quark used for storing mixin offset on a GObjectClass</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="group_mixin_class_init" c:identifier="tp_group_mixin_class_init" introspectable="0">
      <doc xml:whitespace="preserve">Configure the mixin for use with the given class.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj_cls" transfer-ownership="none">
          <doc xml:whitespace="preserve">The class of an object implementing the group interface using this mixin</doc>
          <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:whitespace="preserve">The offset of the TpGroupMixinClass structure within the class structure</doc>
          <type name="long" c:type="glong"/>
        </parameter>
        <parameter name="add_func" transfer-ownership="none" scope="call">
          <doc xml:whitespace="preserve">A callback to be used to add contacts to this group</doc>
          <type name="GroupMixinAddMemberFunc" c:type="TpGroupMixinAddMemberFunc"/>
        </parameter>
        <parameter name="rem_func" transfer-ownership="none" scope="call">
          <doc xml:whitespace="preserve">A callback to be used to remove contacts from this group. This must be %NULL if you will subsequently call tp_group_mixin_class_set_remove_with_reason_func().</doc>
          <type name="GroupMixinRemMemberFunc" c:type="TpGroupMixinRemMemberFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_class_set_remove_with_reason_func" c:identifier="tp_group_mixin_class_set_remove_with_reason_func" version="0.5.13" introspectable="0">
      <doc xml:whitespace="preserve">Set a callback to be used to implement RemoveMembers() and
RemoveMembersWithReason(). If this function is called during class
initialization, the given callback will be used instead of the remove
callback passed to tp_group_mixin_class_init() (which must be %NULL
in this case).</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cls" transfer-ownership="none">
          <doc xml:whitespace="preserve">The class of an object implementing the group interface using this mixin</doc>
          <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
        </parameter>
        <parameter name="func" transfer-ownership="none" scope="call">
          <doc xml:whitespace="preserve">A callback to be used to remove contacts from this group with a specified reason.</doc>
          <type name="GroupMixinRemMemberWithReasonFunc" c:type="TpGroupMixinRemMemberWithReasonFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_finalize" c:identifier="tp_group_mixin_finalize" introspectable="0">
      <doc xml:whitespace="preserve">Unreference handles and free resources used by this mixin.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_get_all_members" c:identifier="tp_group_mixin_get_all_members" introspectable="0" throws="1">
      <doc xml:whitespace="preserve">Get the group's current and pending members.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE</doc>
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="members" transfer-ownership="none">
          <doc xml:whitespace="preserve">Used to return a newly-allocated GArray of guint representing the handles of the group's members</doc>
          <array name="GLib.Array" c:type="GArray**">
            <type name="any" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="local_pending" transfer-ownership="none">
          <doc xml:whitespace="preserve">Used to return a newly-allocated GArray of guint representing the handles of the group's local pending members</doc>
          <array name="GLib.Array" c:type="GArray**">
            <type name="any" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="remote_pending" transfer-ownership="none">
          <doc xml:whitespace="preserve">Used to return a newly-allocated GArray of guint representing the handles of the group's remote pending members</doc>
          <array name="GLib.Array" c:type="GArray**">
            <type name="any" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_get_dbus_property" c:identifier="tp_group_mixin_get_dbus_property" version="0.7.10" introspectable="0">
      <doc xml:whitespace="preserve">An implementation of #TpDBusPropertiesMixinGetter which assumes that the</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="interface" transfer-ownership="none">
          <doc xml:whitespace="preserve">Must be %TP_IFACE_QUARK_CHANNEL_INTERFACE_GROUP</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">A quark representing the D-Bus property name, either "GroupFlags", "HandleOwners", "LocalPendingMembers", "Members", "RemotePendingMembers" or "SelfHandle"</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GValue pre-initialized to the right type, into which to put the value</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="unused" transfer-ownership="none">
          <doc xml:whitespace="preserve">Ignored</doc>
          <type name="any" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_get_group_flags" c:identifier="tp_group_mixin_get_group_flags" introspectable="0" throws="1">
      <doc xml:whitespace="preserve">Set the guint pointed to by ret to this group's flags, to be
interpreted according to TpChannelGroupFlags.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE</doc>
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group mixin using this interface</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="ret" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:whitespace="preserve">Used to return the flags</doc>
          <type name="uint" c:type="guint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_get_handle_owners" c:identifier="tp_group_mixin_get_handle_owners" introspectable="0" throws="1">
      <doc xml:whitespace="preserve">If the mixin has the flag %TP_CHANNEL_GROUP_FLAG_CHANNEL_SPECIFIC_HANDLES,
return the global owners of the given local handles, or 0 where
unavailable.
failure</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE (setting @ret) on success, %FALSE (setting @error) on</doc>
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="handles" transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of guint representing locally valid handles</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="any" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="ret" transfer-ownership="none">
          <doc xml:whitespace="preserve">Used to return an array of guint representing globally valid handles, or 0 where unavailable, if %TRUE is returned</doc>
          <array name="GLib.Array" c:type="GArray**">
            <type name="any" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_get_local_pending_members" c:identifier="tp_group_mixin_get_local_pending_members" introspectable="0" throws="1">
      <doc xml:whitespace="preserve">Get the group's local-pending members.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE</doc>
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="ret" transfer-ownership="none">
          <doc xml:whitespace="preserve">Used to return a newly-allocated GArray of guint contact handles</doc>
          <array name="GLib.Array" c:type="GArray**">
            <type name="any" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_get_local_pending_members_with_info" c:identifier="tp_group_mixin_get_local_pending_members_with_info" introspectable="0" throws="1">
      <doc xml:whitespace="preserve">Get the group's local-pending members and information about their
requests to join the channel.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE</doc>
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="ret" transfer-ownership="none">
          <doc xml:whitespace="preserve">Used to return a newly-allocated GPtrArray of D-Bus structures each containing the handle of a local-pending contact, the handle of a contact responsible for adding them to the group (or 0), the reason code and a related message (e.g. their request to join the group)</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray**">
            <type name="any" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_get_members" c:identifier="tp_group_mixin_get_members" introspectable="0" throws="1">
      <doc xml:whitespace="preserve">Get the group's current members</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE</doc>
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="ret" transfer-ownership="none">
          <doc xml:whitespace="preserve">Used to return a newly-allocated GArray of guint contact handles</doc>
          <array name="GLib.Array" c:type="GArray**">
            <type name="any" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_get_offset_quark" c:identifier="tp_group_mixin_get_offset_quark" introspectable="0">
      <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">the quark used for storing mixin offset on a GObject</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="group_mixin_get_remote_pending_members" c:identifier="tp_group_mixin_get_remote_pending_members" introspectable="0" throws="1">
      <doc xml:whitespace="preserve">Get the group's remote-pending members.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE</doc>
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="ret" transfer-ownership="none">
          <doc xml:whitespace="preserve">Used to return a newly-allocated GArray of guint representing the handles of the group's remote pending members</doc>
          <array name="GLib.Array" c:type="GArray**">
            <type name="any" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_get_self_handle" c:identifier="tp_group_mixin_get_self_handle" introspectable="0" throws="1">
      <doc xml:whitespace="preserve">Set the guint pointed to by ret to the local user's handle in this
group, or to 0 if the local user is not present in this group.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE.</doc>
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group mixin using this interface</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="ret" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:whitespace="preserve">Used to return the local user's handle in this group</doc>
          <type name="uint" c:type="guint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_iface_init" c:identifier="tp_group_mixin_iface_init" introspectable="0">
      <doc xml:whitespace="preserve">Fill in the vtable entries needed to implement the group interface using
this mixin. This function should usually be called via
G_IMPLEMENT_INTERFACE.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_iface" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #TpSvcChannelInterfaceGroupClass</doc>
          <type name="any" c:type="gpointer"/>
        </parameter>
        <parameter name="iface_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">Unused</doc>
          <type name="any" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_init" c:identifier="tp_group_mixin_init" introspectable="0">
      <doc xml:whitespace="preserve">Initialize the mixin.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:whitespace="preserve">The offset of the TpGroupMixin structure within the instance structure</doc>
          <type name="long" c:type="glong"/>
        </parameter>
        <parameter name="handle_repo" transfer-ownership="none">
          <doc xml:whitespace="preserve">The connection's handle repository for contacts</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="self_handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">The handle of the local user in this group, if any</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_init_dbus_properties" c:identifier="tp_group_mixin_init_dbus_properties" version="0.7.10" introspectable="0">
      <doc xml:whitespace="preserve">Set up #TpDBusPropertiesMixinClass to use this mixin's implementation of
the Group interface's properties.
This uses tp_group_mixin_get_dbus_property() as the property getter and
sets up a list of the supported properties for it.  Having called this, you
should add #TP_CHANNEL_GROUP_FLAG_PROPERTIES to any channels of this class
with tp_group_mixin_change_flags() to indicate that the DBus properties are
available.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cls" transfer-ownership="none">
          <doc xml:whitespace="preserve">The class of an object with this mixin</doc>
          <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_remove_members" c:identifier="tp_group_mixin_remove_members" introspectable="0" throws="1">
      <doc xml:whitespace="preserve">Request that the given contacts be removed from the group as if in response
to user action. If the group's flags prohibit this, raise
PermissionDenied. If any of the handles is invalid, raise InvalidHandle.
If any of the handles is absent from the group, raise NotAvailable.
Otherwise attempt to remove the contacts by calling the callbacks provided
by the channel implementation.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE on success</doc>
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="contacts" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GArray of guint representing contacts</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="any" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:whitespace="preserve">A message to be sent to those contacts, if supported</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_remove_members_with_reason" c:identifier="tp_group_mixin_remove_members_with_reason" introspectable="0" throws="1">
      <doc xml:whitespace="preserve">Request that the given contacts be removed from the group as if in response
to user action. If the group's flags prohibit this, raise
PermissionDenied. If any of the handles is invalid, raise InvalidHandle.
If any of the handles is absent from the group, raise NotAvailable.
Otherwise attempt to remove the contacts by calling the callbacks provided
by the channel implementation.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE on success</doc>
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="contacts" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GArray of guint representing contacts</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="any" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:whitespace="preserve">A message to be sent to those contacts, if supported</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="reason" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #TpChannelGroupChangeReason</doc>
          <type name="uint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_client_hold" c:identifier="tp_handle_client_hold" introspectable="0" throws="1">
      <doc xml:whitespace="preserve">Hold the given handle on behalf of the named client.
If the client leaves the bus, the reference is automatically discarded.
Handles held multiple times are the same as handles held
if you call tp_handle_client_hold() multiple times, then call
tp_handle_client_release() just once, the client no longer holds the handle.
It is an error for @handle not to be present in the repository.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the client name is valid; else %FALSE with @error set.</doc>
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle repository implementation</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="client" transfer-ownership="none">
          <doc xml:whitespace="preserve">The unique bus name of a D-Bus peer</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle of the type stored in the repository</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_client_release" c:identifier="tp_handle_client_release" introspectable="0" throws="1">
      <doc xml:whitespace="preserve">If the named client holds the given handle, release it.
If this causes the reference count to become zero, delete the handle.
For repository implementations which never free handles (like
#TpStaticHandleRepo) this has no effect.
a reference to the handle, else %FALSE.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the client name is valid and the client previously held</doc>
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle repository implementation</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="client" transfer-ownership="none">
          <doc xml:whitespace="preserve">The unique bus name of a D-Bus peer</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle of the type stored in the repository</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_ensure" c:identifier="tp_handle_ensure" throws="1">
      <doc xml:whitespace="preserve">Return a new reference to the handle for the given string. The handle
is normalized, if possible. If no such handle exists it will be created.
is invalid.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">the handle corresponding to the given string, or 0 if it</doc>
        <type name="Handle" c:type="TpHandle"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle repository implementation</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="id" transfer-ownership="none">
          <doc xml:whitespace="preserve">A string whose handle is required</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="context" transfer-ownership="none">
          <doc xml:whitespace="preserve">User data to be passed to the normalization callback</doc>
          <type name="any" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_get_qdata" c:identifier="tp_handle_get_qdata" introspectable="0">
      <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;
if there is no associated data.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the data associated with a given key on a given handle; %NULL</doc>
        <type name="any" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="repo" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle repository implementation</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle to get data from</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
        <parameter name="key_id" transfer-ownership="none">
          <doc xml:whitespace="preserve">Key id of data to fetch</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_inspect" c:identifier="tp_handle_inspect" introspectable="0">
      <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;
handle is absent from the repository. The string is owned by the
handle repository and will remain valid as long as a reference to
the handle exists.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the string represented by the given handle, or NULL if the</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle repository implementation</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle of the type stored in the repository</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_is_valid" c:identifier="tp_handle_is_valid" introspectable="0" throws="1">
      <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;
else %FALSE</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the handle is nonzero and is present in the repository,</doc>
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle repository implementation</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle of the type stored in the repository @self</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_lookup" c:identifier="tp_handle_lookup" introspectable="0" throws="1">
      <doc xml:whitespace="preserve">Return the handle for the given string, without incrementing its
reference count. The handle is normalized if possible.
does not exist or is invalid</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">the handle corresponding to the given string, or 0 if it</doc>
        <type name="Handle" c:type="TpHandle"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle repository implementation</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="id" transfer-ownership="none">
          <doc xml:whitespace="preserve">A string whose handle is required</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="context" transfer-ownership="none">
          <doc xml:whitespace="preserve">User data to be passed to the normalization callback</doc>
          <type name="any" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_ref" c:identifier="tp_handle_ref" introspectable="0">
      <doc xml:whitespace="preserve">Increase the reference count of the given handle, which must be present
in the repository. For repository implementations which never free handles
(like #TpStaticHandleRepo) this has no effect.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle repository implementation</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle of the type stored in the repository</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_set_qdata" c:identifier="tp_handle_set_qdata" introspectable="0">
      <doc xml:whitespace="preserve">Associates a blob of data with a given handle and a given key
If @destroy is set, then the data is freed when the handle is freed.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="repo" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle repository implementation</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle to set data on</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
        <parameter name="key_id" transfer-ownership="none">
          <doc xml:whitespace="preserve">Key id to associate data with</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">data to associate with handle</doc>
          <type name="any" c:type="gpointer"/>
        </parameter>
        <parameter name="destroy" transfer-ownership="none" scope="call">
          <doc xml:whitespace="preserve">A #GDestroyNotify to call to destroy the data, or NULL if not needed.</doc>
          <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_type_is_valid" c:identifier="tp_handle_type_is_valid" throws="1">
      <doc xml:whitespace="preserve">If the given handle type is valid, return %TRUE. If not, set @error
and return %FALSE.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the handle type is valid.</doc>
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle type, valid or not, to be checked</doc>
          <type name="HandleType" c:type="TpHandleType"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_type_to_string" c:identifier="tp_handle_type_to_string">
      <doc xml:whitespace="preserve">&lt;!----&gt;
For invalid handle types, returns "(no handle)" for 0 or
"(invalid handle type)" for others.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">a human-readable string describing the handle type, e.g. "contact".</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle type, which need not be valid</doc>
          <type name="HandleType" c:type="TpHandleType"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_unref" c:identifier="tp_handle_unref" introspectable="0">
      <doc xml:whitespace="preserve">Decrease the reference count of the given handle. If it reaches zero,
delete the handle. It is an error to attempt to unref a handle
which is not present in the repository.
For repository implementations which never free handles (like
#TpStaticHandleRepo) this has no effect.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle repository implementation</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle of the type stored in the repository</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="handles_are_valid" c:identifier="tp_handles_are_valid" introspectable="0" throws="1">
      <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the handle is present in the repository, else %FALSE</doc>
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle repository implementation</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="handles" transfer-ownership="none">
          <doc xml:whitespace="preserve">Array of TpHandle representing handles of the type stored in the repository @self</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="any" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="allow_zero" transfer-ownership="none">
          <doc xml:whitespace="preserve">If %TRUE, zero is treated like a valid handle</doc>
          <type name="boolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="handles_client_hold" c:identifier="tp_handles_client_hold" introspectable="0" throws="1">
      <doc xml:whitespace="preserve">Hold the given handles on behalf of the named client.
If the client leaves the bus, the reference is automatically discarded.
If any of the handles are zero they will be ignored without error.
It is an error for any other invalid handle to be in @handles:
the caller is expected to have validated them first, e.g. using
tp_handles_are_valid().
Handles appearing multiple times are the same as handles appearing
If %FALSE is returned, the reference counts of all handles are unaffected
(the function either fails completely or succeeds completely).</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the client name is valid; else %FALSE with @error set.</doc>
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle repository implementation</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="client" transfer-ownership="none">
          <doc xml:whitespace="preserve">The D-Bus unique name of a client</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="handles" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GArray of TpHandle representing handles</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="any" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="handles_client_release" c:identifier="tp_handles_client_release" introspectable="0" throws="1">
      <doc xml:whitespace="preserve">Releases a reference to the given handles on behalf of the named client.
If any of the handles are zero they will be ignored without error.
It is an error for any other invalid handle to be in @handles:
the caller is expected to have validated them first, e.g. using
tp_handles_are_valid().
If %FALSE is returned, the reference counts of all handles are unaffected
(the function either fails completely or succeeds completely).
a reference to all the handles, else %FALSE.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the client name is valid and the client previously held</doc>
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle repository implementation</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="client" transfer-ownership="none">
          <doc xml:whitespace="preserve">The D-Bus unique name of a client</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="handles" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GArray of TpHandle representing handles</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="any" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="handles_ref" c:identifier="tp_handles_ref" introspectable="0">
      <doc xml:whitespace="preserve">Increase the reference count of the given handles. If a handle appears
multiple times in @handles it will be referenced that many times. If
any zero entries appear in @handles they will be ignored without error;
it is an error for any other invalid handle to appear in @handles.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle repository implementation</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="handles" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GArray of TpHandle representing handles</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="any" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="handles_supported_and_valid" c:identifier="tp_handles_supported_and_valid" introspectable="0" throws="1">
      <doc xml:whitespace="preserve">Return %TRUE if the given handle type is supported (i.e. repos[handle_type]
is not %NULL) and the given handles are all valid in that repository.
If not, set @error and return %FALSE.
valid.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the handle type is supported and the handles are all</doc>
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="repos" transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of possibly null pointers to handle repositories, indexed by handle type, where a null pointer means an unsupported handle type</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="handle_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">The handle type</doc>
          <type name="HandleType" c:type="TpHandleType"/>
        </parameter>
        <parameter name="handles" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GArray of guint representing handles of the given type</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="any" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="allow_zero" transfer-ownership="none">
          <doc xml:whitespace="preserve">If %TRUE, zero is treated like a valid handle</doc>
          <type name="boolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="handles_unref" c:identifier="tp_handles_unref" introspectable="0">
      <doc xml:whitespace="preserve">Decrease the reference count of the given handles. If a handle appears
multiple times in @handles it will be dereferenced that many times. If
any zero entries appear in @handles they will be ignored without error;
it is an error for any other invalid handle to appear in @handles.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle repository implementation</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="handles" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GArray of TpHandle representing handles</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="any" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="iface_quark_account" c:identifier="tp_iface_quark_account">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_account_interface_avatar" c:identifier="tp_iface_quark_account_interface_avatar">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_account_interface_storage" c:identifier="tp_iface_quark_account_interface_storage">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_account_manager" c:identifier="tp_iface_quark_account_manager">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel" c:identifier="tp_iface_quark_channel">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_dispatch_operation" c:identifier="tp_iface_quark_channel_dispatch_operation">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_dispatcher" c:identifier="tp_iface_quark_channel_dispatcher">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_dispatcher_interface_operation_list" c:identifier="tp_iface_quark_channel_dispatcher_interface_operation_list">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_anonymity" c:identifier="tp_iface_quark_channel_interface_anonymity">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_call_state" c:identifier="tp_iface_quark_channel_interface_call_state">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_chat_state" c:identifier="tp_iface_quark_channel_interface_chat_state">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_destroyable" c:identifier="tp_iface_quark_channel_interface_destroyable">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_dtmf" c:identifier="tp_iface_quark_channel_interface_dtmf">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_group" c:identifier="tp_iface_quark_channel_interface_group">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_hold" c:identifier="tp_iface_quark_channel_interface_hold">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_media_signalling" c:identifier="tp_iface_quark_channel_interface_media_signalling">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_messages" c:identifier="tp_iface_quark_channel_interface_messages">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_password" c:identifier="tp_iface_quark_channel_interface_password">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_service_point" c:identifier="tp_iface_quark_channel_interface_service_point">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_tube" c:identifier="tp_iface_quark_channel_interface_tube">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_request" c:identifier="tp_iface_quark_channel_request">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_contact_list" c:identifier="tp_iface_quark_channel_type_contact_list">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_contact_search" c:identifier="tp_iface_quark_channel_type_contact_search">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_dbus_tube" c:identifier="tp_iface_quark_channel_type_dbus_tube">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_file_transfer" c:identifier="tp_iface_quark_channel_type_file_transfer">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_room_list" c:identifier="tp_iface_quark_channel_type_room_list">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_stream_tube" c:identifier="tp_iface_quark_channel_type_stream_tube">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_streamed_media" c:identifier="tp_iface_quark_channel_type_streamed_media">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_text" c:identifier="tp_iface_quark_channel_type_text">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_tubes" c:identifier="tp_iface_quark_channel_type_tubes">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_client" c:identifier="tp_iface_quark_client">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_client_approver" c:identifier="tp_iface_quark_client_approver">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_client_handler" c:identifier="tp_iface_quark_client_handler">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_client_interface_requests" c:identifier="tp_iface_quark_client_interface_requests">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_client_observer" c:identifier="tp_iface_quark_client_observer">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection" c:identifier="tp_iface_quark_connection">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_aliasing" c:identifier="tp_iface_quark_connection_interface_aliasing">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_anonymity" c:identifier="tp_iface_quark_connection_interface_anonymity">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_avatars" c:identifier="tp_iface_quark_connection_interface_avatars">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_balance" c:identifier="tp_iface_quark_connection_interface_balance">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_capabilities" c:identifier="tp_iface_quark_connection_interface_capabilities">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_cellular" c:identifier="tp_iface_quark_connection_interface_cellular">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_contact_capabilities" c:identifier="tp_iface_quark_connection_interface_contact_capabilities">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_contact_info" c:identifier="tp_iface_quark_connection_interface_contact_info">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_contacts" c:identifier="tp_iface_quark_connection_interface_contacts">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_location" c:identifier="tp_iface_quark_connection_interface_location">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_presence" c:identifier="tp_iface_quark_connection_interface_presence">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_requests" c:identifier="tp_iface_quark_connection_interface_requests">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_service_point" c:identifier="tp_iface_quark_connection_interface_service_point">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_simple_presence" c:identifier="tp_iface_quark_connection_interface_simple_presence">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_manager" c:identifier="tp_iface_quark_connection_manager">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_dbus_daemon" c:identifier="tp_iface_quark_dbus_daemon">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_dbus_introspectable" c:identifier="tp_iface_quark_dbus_introspectable">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_dbus_peer" c:identifier="tp_iface_quark_dbus_peer">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_dbus_properties" c:identifier="tp_iface_quark_dbus_properties">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_debug" c:identifier="tp_iface_quark_debug">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_media_session_handler" c:identifier="tp_iface_quark_media_session_handler">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_media_stream_handler" c:identifier="tp_iface_quark_media_stream_handler">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_properties_interface" c:identifier="tp_iface_quark_properties_interface">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_protocol" c:identifier="tp_iface_quark_protocol">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="intset_fast_iter_init" c:identifier="tp_intset_fast_iter_init" version="0.11.6">
      <doc xml:whitespace="preserve">Initialize @iter to iterate over @set in arbitrary order. @iter will become
invalid if @set is modified.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="iter" transfer-ownership="none">
          <doc xml:whitespace="preserve">an iterator</doc>
          <type name="IntSetFastIter" c:type="TpIntSetFastIter*"/>
        </parameter>
        <parameter name="set" transfer-ownership="none">
          <doc xml:whitespace="preserve">a set</doc>
          <type name="IntSet" c:type="TpIntSet*"/>
        </parameter>
      </parameters>
    </function>
    <function name="intset_fast_iter_next" c:identifier="tp_intset_fast_iter_next" version="0.11.6">
      <doc xml:whitespace="preserve">Advances @iter and retrieves the integer it now points to. Iteration
is not necessarily in numerical order.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%FALSE if the end of the set has been reached</doc>
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="iter" transfer-ownership="none">
          <doc xml:whitespace="preserve">an iterator</doc>
          <type name="IntSetFastIter" c:type="TpIntSetFastIter*"/>
        </parameter>
        <parameter name="output" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:whitespace="preserve">a location to store a new integer, in arbitrary order</doc>
          <type name="uint" c:type="guint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="intset_from_array" c:identifier="tp_intset_from_array">
      <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">A set containing the same integers as @array.</doc>
        <type name="IntSet" c:type="TpIntSet*"/>
      </return-value>
      <parameters>
        <parameter name="array" transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of guint</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="uint"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="intset_iter_next" c:identifier="tp_intset_iter_next">
      <doc xml:whitespace="preserve">If there are integers in (@iter-&gt;set) higher than (@iter-&gt;element), set
(iter-&gt;element) to the next one and return %TRUE. Otherwise return %FALSE.
Usage:
&lt;informalexample&gt;&lt;programlisting&gt;
TpIntSetIter iter = TP_INTSET_INIT (intset);
while (tp_intset_iter_next (&amp;amp;iter))
{
printf ("%u is in the intset\n", iter.element);
}
&lt;/programlisting&gt;&lt;/informalexample&gt;
Since 0.11.6, consider using #TpIntSetFastIter if iteration in
numerical order is not required.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if (@iter-&gt;element) has been advanced</doc>
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="iter" transfer-ownership="none">
          <doc xml:whitespace="preserve">An iterator originally initialized with TP_INTSET_INIT(set)</doc>
          <type name="IntSetIter" c:type="TpIntSetIter*"/>
        </parameter>
      </parameters>
    </function>
    <function name="intset_sized_new" c:identifier="tp_intset_sized_new">
      <doc xml:whitespace="preserve">Allocate a new integer set.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new, empty integer set to be destroyed with tp_intset_destroy()</doc>
        <type name="IntSet" c:type="TpIntSet*"/>
      </return-value>
      <parameters>
        <parameter name="size" transfer-ownership="none">
          <doc xml:whitespace="preserve">ignored (it was previously 1 more than the largest integer you expect to store)</doc>
          <type name="uint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="list_connection_managers" c:identifier="tp_list_connection_managers" version="0.7.1">
      <doc xml:whitespace="preserve">List the available (running or installed) connection managers. Call the
callback when done.
Since 0.7.26, this function will wait for each #TpConnectionManager
to be ready, so all connection managers passed to @callback will be ready
(tp_connection_manager_is_ready() will return %TRUE) unless an error
occurred while launching that connection manager.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="bus_daemon" transfer-ownership="none">
          <doc xml:whitespace="preserve">proxy for the D-Bus daemon</doc>
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </parameter>
        <parameter name="callback" transfer-ownership="none" scope="notified" closure="2" destroy="3">
          <doc xml:whitespace="preserve">callback to be called when listing the CMs succeeds or fails; not called if the @weak_object goes away</doc>
          <type name="ConnectionManagerListCb" c:type="TpConnectionManagerListCb"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">user-supplied data for the callback</doc>
          <type name="any" c:type="gpointer"/>
        </parameter>
        <parameter name="destroy" transfer-ownership="none" scope="call">
          <doc xml:whitespace="preserve">callback to destroy the user-supplied data, called after</doc>
          <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">if not %NULL, will be weakly referenced; the callback will not be called, and the call will be cancelled, if the object has vanished</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="list_connection_names" c:identifier="tp_list_connection_names" version="0.7.1">
      <doc xml:whitespace="preserve">List the bus names of all the connections that currently exist, together
with the connection manager name and the protocol name for each connection.
Call the callback when done.
The bus names passed to the callback can be used to construct #TpConnection
objects for any connections that are of interest.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="bus_daemon" transfer-ownership="none">
          <doc xml:whitespace="preserve">proxy for the D-Bus daemon</doc>
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </parameter>
        <parameter name="callback" transfer-ownership="none" scope="notified" closure="2" destroy="3">
          <doc xml:whitespace="preserve">callback to be called when listing the connections succeeds or fails; not called if the D-Bus connection fails completely or if the</doc>
          <type name="ConnectionNameListCb" c:type="TpConnectionNameListCb"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">user-supplied data for the callback</doc>
          <type name="any" c:type="gpointer"/>
        </parameter>
        <parameter name="destroy" transfer-ownership="none" scope="call">
          <doc xml:whitespace="preserve">callback to destroy the user-supplied data, called after goes away</doc>
          <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">if not %NULL, will be weakly referenced; the callback will not be called if the object has vanished</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="presence_mixin_class_get_offset_quark" c:identifier="tp_presence_mixin_class_get_offset_quark" introspectable="0">
      <doc xml:whitespace="preserve">&lt;!--no documentation beyond Returns: needed--&gt;</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">the quark used for storing mixin offset on a GObjectClass</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="presence_mixin_class_init" c:identifier="tp_presence_mixin_class_init" introspectable="0">
      <doc xml:whitespace="preserve">Initialize the presence mixin. Should be called from the implementation's
class_init function like so:
&lt;informalexample&gt;&lt;programlisting&gt;
tp_presence_mixin_class_init ((GObjectClass *) klass,
G_STRUCT_OFFSET (SomeObjectClass,
presence_mixin));
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj_cls" transfer-ownership="none">
          <doc xml:whitespace="preserve">The class of the implementation that uses this mixin</doc>
          <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:whitespace="preserve">The byte offset of the TpPresenceMixinClass within the class structure</doc>
          <type name="long" c:type="glong"/>
        </parameter>
        <parameter name="status_available" transfer-ownership="none" scope="call">
          <doc xml:whitespace="preserve">A callback to be used to determine if a given presence status is available to be set on the connection. If NULL, all statuses are always considered available. If SimplePresence is implemented, this callback may be called before the connection is connected.</doc>
          <type name="PresenceMixinStatusAvailableFunc" c:type="TpPresenceMixinStatusAvailableFunc"/>
        </parameter>
        <parameter name="get_contact_statuses" transfer-ownership="none" scope="call">
          <doc xml:whitespace="preserve">A callback to be used get the current presence status for contacts. This is used in implementations of various D-Bus methods and hence must be provided.</doc>
          <type name="PresenceMixinGetContactStatusesFunc" c:type="TpPresenceMixinGetContactStatusesFunc"/>
        </parameter>
        <parameter name="set_own_status" transfer-ownership="none" scope="call">
          <doc xml:whitespace="preserve">A callback to be used to commit changes to the user's own presence status to the server. This is used in implementations of various D-Bus methods and hence must be provided.</doc>
          <type name="PresenceMixinSetOwnStatusFunc" c:type="TpPresenceMixinSetOwnStatusFunc"/>
        </parameter>
        <parameter name="statuses" transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of #TpPresenceStatusSpec structures representing all presence statuses supported by the protocol, terminated by a NULL name.</doc>
          <type name="PresenceStatusSpec" c:type="TpPresenceStatusSpec*"/>
        </parameter>
      </parameters>
    </function>
    <function name="presence_mixin_emit_one_presence_update" c:identifier="tp_presence_mixin_emit_one_presence_update" introspectable="0">
      <doc xml:whitespace="preserve">Emit the PresenceUpdate signal for a single contact. This method is just a
convenience wrapper around #tp_presence_mixin_emit_presence_update.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">A connection object with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">The handle of the contact to emit the signal for</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
        <parameter name="status" transfer-ownership="none">
          <doc xml:whitespace="preserve">The new status to emit</doc>
          <type name="PresenceStatus" c:type="TpPresenceStatus*"/>
        </parameter>
      </parameters>
    </function>
    <function name="presence_mixin_emit_presence_update" c:identifier="tp_presence_mixin_emit_presence_update" introspectable="0">
      <doc xml:whitespace="preserve">Emit the PresenceUpdate signal for multiple contacts. For emitting
PresenceUpdate for a single contact, there is a convenience wrapper called
#tp_presence_mixin_emit_one_presence_update.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">A connection object with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="contact_presences" transfer-ownership="none">
          <doc xml:whitespace="preserve">A mapping of contact handles to #TpPresenceStatus structures with the presence data to emit</doc>
          <type name="GLib.HashTable" c:type="GHashTable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="presence_mixin_finalize" c:identifier="tp_presence_mixin_finalize" introspectable="0">
      <doc xml:whitespace="preserve">Free resources held by the presence mixin.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object with this mixin.</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="presence_mixin_get_offset_quark" c:identifier="tp_presence_mixin_get_offset_quark" introspectable="0">
      <doc xml:whitespace="preserve">&lt;!--no documentation beyond Returns: needed--&gt;</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">the quark used for storing mixin offset on a GObject</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="presence_mixin_iface_init" c:identifier="tp_presence_mixin_iface_init" introspectable="0">
      <doc xml:whitespace="preserve">Fill in the vtable entries needed to implement the presence interface using
this mixin. This function should usually be called via G_IMPLEMENT_INTERFACE.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_iface" transfer-ownership="none">
          <doc xml:whitespace="preserve">A pointer to the #TpSvcConnectionInterfacePresenceClass in an object class</doc>
          <type name="any" c:type="gpointer"/>
        </parameter>
        <parameter name="iface_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">Ignored</doc>
          <type name="any" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="presence_mixin_init" c:identifier="tp_presence_mixin_init" introspectable="0">
      <doc xml:whitespace="preserve">Initialize the presence mixin. Should be called from the implementation's
instance init function like so:
&lt;informalexample&gt;&lt;programlisting&gt;
tp_presence_mixin_init ((GObject *) self,
G_STRUCT_OFFSET (SomeObject, presence_mixin));
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An instance of the implementation that uses this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:whitespace="preserve">The byte offset of the TpPresenceMixin within the object structure</doc>
          <type name="long" c:type="glong"/>
        </parameter>
      </parameters>
    </function>
    <function name="presence_mixin_simple_presence_iface_init" c:identifier="tp_presence_mixin_simple_presence_iface_init" version="0.7.13" introspectable="0">
      <doc xml:whitespace="preserve">Fill in the vtable entries needed to implement the simple presence interface
using this mixin. This function should usually be called via
G_IMPLEMENT_INTERFACE.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_iface" transfer-ownership="none">
          <doc xml:whitespace="preserve">A pointer to the #TpSvcConnectionInterfaceSimplePresenceClass in an object class</doc>
          <type name="any" c:type="gpointer"/>
        </parameter>
        <parameter name="iface_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">Ignored</doc>
          <type name="any" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="presence_mixin_simple_presence_init_dbus_properties" c:identifier="tp_presence_mixin_simple_presence_init_dbus_properties" version="0.7.13" introspectable="0">
      <doc xml:whitespace="preserve">Set up #TpDBusPropertiesMixinClass to use this mixin's implementation of
the SimplePresence interface's properties.
This automatically sets up a list of the supported properties for the
SimplePresence interface.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cls" transfer-ownership="none">
          <doc xml:whitespace="preserve">The class of an object with this mixin</doc>
          <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
        </parameter>
      </parameters>
    </function>
    <function name="presence_mixin_simple_presence_register_with_contacts_mixin" c:identifier="tp_presence_mixin_simple_presence_register_with_contacts_mixin" introspectable="0">
      <doc xml:whitespace="preserve">Register the SimplePresence interface with the Contacts interface to make it
inspectable. The Contacts mixin should be initialized before this function
is called</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An instance that of the implementation that uses both the Contacts mixin and this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="svc_interface_set_dbus_properties_info" c:identifier="tp_svc_interface_set_dbus_properties_info" version="0.7.3">
      <doc xml:whitespace="preserve">Declare that @g_interface implements the given D-Bus interface, with the
given properties. This may only be called once per GInterface, usually from
a section of its base_init function that only runs once.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_interface" transfer-ownership="none">
          <doc xml:whitespace="preserve">The #GType of a service interface</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="info" transfer-ownership="none">
          <doc xml:whitespace="preserve">an interface description</doc>
          <type name="DBusPropertiesMixinIfaceInfo" c:type="TpDBusPropertiesMixinIfaceInfo*"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
